<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL练习题]]></title>
    <url>%2FMysql%20%E7%BB%83%E4%B9%A0%E9%A2%98.html</url>
    <content type="text"><![CDATA[练习数据数据表–1.学生表Student(SId,Sname,Sage,Ssex) –SId 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别 –2.课程表Course(CId,Cname,TId)–CId –课程编号,Cname 课程名称,TId 教师编号 –3.教师表Teacher(TId,Tname) –TId 教师编号,Tname 教师姓名 –4.成绩表SC(SId,CId,score) –SId 学生编号,CId 课程编号,score 分数 创建测试数据 学生表 Student create table Student(SId varchar(10),Sname varchar(10),Sage datetime,Ssex varchar(10)); insert into Student values('01' , '赵雷' , '1990-01-01' , '男'); insert into Student values('02' , '钱电' , '1990-12-21' , '男'); insert into Student values('03' , '孙风' , '1990-05-20' , '男'); insert into Student values('04' , '李云' , '1990-08-06' , '男'); insert into Student values('05' , '周梅' , '1991-12-01' , '女'); insert into Student values('06' , '吴兰' , '1992-03-01' , '女'); insert into Student values('07' , '郑竹' , '1989-07-01' , '女'); insert into Student values('09' , '张三' , '2017-12-20' , '女'); insert into Student values('10' , '李四' , '2017-12-25' , '女'); insert into Student values('11' , '李四' , '2017-12-30' , '女'); insert into Student values('12' , '赵六' , '2017-01-01' , '女'); insert into Student values('13' , '孙七' , '2018-01-01' , '女'); 科目表 Course create table Course(CId varchar(10),Cname nvarchar(10),TId varchar(10)) insert into Course values('01' , '语文' , '02') insert into Course values('02' , '数学' , '01') insert into Course values('03' , '英语' , '03') 教师表 Teacher create table Teacher(TId varchar(10),Tname varchar(10)) insert into Teacher values('01' , '张三') insert into Teacher values('02' , '李四') insert into Teacher values('03' , '王五') 成绩表 SC create table SC(SId varchar(10),CId varchar(10),score decimal(18,1)) insert into SC values('01' , '01' , 80) insert into SC values('01' , '02' , 90) insert into SC values('01' , '03' , 99) insert into SC values('02' , '01' , 70) insert into SC values('02' , '02' , 60) insert into SC values('02' , '03' , 80) insert into SC values('03' , '01' , 80) insert into SC values('03' , '02' , 80) insert into SC values('03' , '03' , 80) insert into SC values('04' , '01' , 50) insert into SC values('04' , '02' , 30) insert into SC values('04' , '03' , 20) insert into SC values('05' , '01' , 76) insert into SC values('05' , '02' , 87) insert into SC values('06' , '01' , 31) insert into SC values('06' , '03' , 34) insert into SC values('07' , '02' , 89) insert into SC values('07' , '03' , 98) 练习题目 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数1.1 查询同时存在” 01 “课程和” 02 “课程的情况1.2 查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )1.3 查询不存在” 01 “课程但存在” 02 “课程的情况 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩 查询在 SC 表存在成绩的学生信息 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )4.1 查有成绩的学生信息 查询「李」姓老师的数量 查询学过「张三」老师授课的同学的信息 查询没有学全所有课程的同学的信息 查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息 查询和” 01 “号的同学学习的课程 完全相同的其他同学的信息 查询没学过”张三”老师讲授的任一门课程的学生姓名 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 检索” 01 “课程分数小于 60，按分数降序排列的学生信息 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩 查询各科成绩最高分、最低分和平均分：以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺15.1 按各科成绩进行排序，并显示排名， Score 重复时合并名次 查询学生的总成绩，并进行排名，总分重复时保留名次空缺16.1 查询学生的总成绩，并进行排名，总分重复时不保留名次空缺 统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比 查询各科成绩前三名的记录 查询每门课程被选修的学生数 查询出只选修两门课程的学生学号和姓名 查询男生、女生人数 查询名字中含有「风」字的学生信息 查询同名同性学生名单，并统计同名人数 查询 1990 年出生的学生名单 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩 查询课程名称为「数学」，且分数低于 60 的学生姓名和分数 查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况） 查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数 查询不及格的课程 查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名 求每门课程的学生人数 成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 查询每门功成绩最好的前两名 统计每门课程的学生选修人数（超过 5 人的课程才统计）。 检索至少选修两门课程的学生学号 查询选修了全部课程的学生信息 查询各学生的年龄，只按年份来算 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一 查询本周过生日的学生 查询下周过生日的学生 查询本月过生日的学生 查询下月过生日的学生 参考答案1.查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数 select * from (select SId ,score from sc where sc.CId='01')as t1 , (select SId ,score from sc where sc.CId='02') as t2 where t1.SId=t2.SId and t1.score>t2.score 1.1 查询同时存在” 01 “课程和” 02 “课程的情况 select * from (select SId ,score from sc where sc.CId='01')as t1 , (select SId ,score from sc where sc.CId='02') as t2 where t1.SId=t2.SId 1.2 查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null ) select * from (select SId ,score from sc where sc.CId='01')as t1 left join (select SId ,score from sc where sc.CId='02') as t2 on t1.SId=t2.SId 1.3 查询不存在” 01 “课程但存在” 02 “课程的情况 select * from sc where sc.SId not in (select SId from sc where sc.CId='01') and sc.CId='02' 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩select student.*,t1.avgscore from student inner JOIN( select sc.SId ,AVG(sc.score)as avgscore from sc GROUP BY sc.SId HAVING AVG(sc.score)>=60)as t1 on student.SId=t1.SId 查询在 SC 表存在成绩的学生信息select DISTINCT student.* from student ,sc where student.SId=sc.SId 4.查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为null) select student.SId,student.Sname,t1.sumscore,t1.coursecount from student ,( select SC.SId,sum(sc.score)as sumscore ,count(sc.CId) as coursecount from sc GROUP BY sc.SId) as t1 where student.SId =t1.SId 4.1 查有成绩的学生信息 select * from student where EXISTS(select * from sc where student.SId=sc.SId) 查询「李」姓老师的数量 select count(*) from teacher where teacher.Tname like '李% 查询学过「张三」老师授课的同学的信息 select student.* from teacher ,course ,student,sc where teacher.Tname='张三' and teacher.TId=course.TId and course.CId=sc.CId and sc.SId=student.SId 查询没有学全所有课程的同学的信息 解法1select student.* from sc ,student where sc.SId=student.SId GROUP BY sc.SId Having count(*)&lt;(select count(*) from course) 但这种解法得出来的结果不包括什么课都没选的同学。 解法2select DISTINCT student.* from (select student.SId,course.CId from student,course ) as t1 LEFT JOIN (SELECT sc.SId,sc.CId from sc)as t2 on t1.SId=t2.SId and t1.CId=t2.CId,student where t2.SId is null and t1.SId=student.SId 利用笛卡尔积可以把什么课都没选的同学查询出来 查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息select DISTINCT student.* from sc ,student where sc.CId in (select CId from sc where sc.SId='01') and sc.SId=student.SId 9.查询和” 01 “号的同学学习的课程完全相同的其他同学的信息 select DISTINCT student.* from ( select student.SId,t.CId from student ,(select sc.CId from sc where sc.SId='01') as t) as t1 LEFT JOIN sc on t1.SId=sc.SId and t1.CId=sc.CId,student where sc.SId is null and t1.SId=student.SId 10.查询没学过”张三”老师讲授的任一门课程的学生姓名 select * from student where student.SId not in ( select student.SId from student left join sc on student.SId=sc.SId where EXISTS (select * from teacher ,course where teacher.Tname='张三' and teacher.TId=course.TId and course.CId=sc.CId)) 11.查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 select student.SId,student.Sname,avg(sc.score) from student ,sc where student.SId=sc.SId and sc.score&lt;60 GROUP BY sc.SId HAVING count(*)>=2 检索” 01 “课程分数小于 60，按分数降序排列的学生信息 select student.* from student,sc where sc.CId ='01' and sc.score&lt;60 and student.SId=sc.SId 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩 select sc.SId,sc.CId,sc.score,t1.avgscore from sc left join (select sc.SId,avg(sc.score) as avgscore from sc GROUP BY sc.SId) as t1 on sc.SId =t1.SId ORDER BY t1.avgscore DESC 查询各科成绩最高分、最低分和平均分：以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 select sc.CId ,max(sc.score)as 最高分,min(sc.score)as 最低分,AVG(sc.score)as 平均分,count(*)as 选修人数,sum(case when sc.score>=60 then 1 else 0 end )/count(*)as 及格率,sum(case when sc.score>=70 and sc.score&lt;80 then 1 else 0 end )/count(*)as 中等率,sum(case when sc.score>=80 and sc.score&lt;90 and sc.score&lt;80 then 1 else 0 end )/count(*)as 优良率,sum(case when sc.score>=90 then 1 else 0 end )/count(*)as 优秀率 from sc GROUP BY sc.CId ORDER BY count(*)DESC,sc.CId asc 按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺 select sc.CId ,@curRank:=@curRank+1 as rank,sc.score from (select @curRank:=0) as t ,sc ORDER BY sc.score desc 15.1 按各科成绩进行排序，并显示排名， Score 重复时合并名次 select sc.CId , case when @fontscore=score then @curRank when @fontscore:=score then @curRank:=@curRank+1 end as rank,sc.score from (select @curRank:=0 ,@fontage:=null) as t ,sc ORDER BY sc.score desc 查询学生的总成绩，并进行排名，总分重复时保留名次空缺select t1.*,@currank:= @currank+1 as rank from (select sc.SId, sum(score) from sc GROUP BY sc.SId ORDER BY sum(score) desc) as t1,(select @currank:=0) as t 16.1 查询学生的总成绩，并进行排名，总分重复时不保留名次空缺 select t1.*, case when @fontscore=t1.sumscore then @currank when @fontscore:=t1.sumscore then @currank:=@currank+1 end as rank from (select sc.SId, sum(score) as sumscore from sc GROUP BY sc.SId ORDER BY sum(score) desc) as t1,(select @currank:=0,@fontscore:=null) as t 统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比 select course.CId,course.Cname,t1.* from course LEFT JOIN ( select sc.CId,CONCAT(sum(case when sc.score>=85 and sc.score&lt;=100 then 1 else 0 end )/count(*)*100,'%') as '[85-100]', CONCAT(sum(case when sc.score>=70 and sc.score&lt;85 then 1 else 0 end )/count(*)*100,'%') as '[70-85)', CONCAT(sum(case when sc.score>=60 and sc.score&lt;70 then 1 else 0 end )/count(*)*100,'%') as '[60-70)', CONCAT(sum(case when sc.score>=0 and sc.score&lt;60 then 1 else 0 end )/count(*)*100,'%') as '[0-60)' from sc GROUP BY sc.CId) as t1 on course.CId=t1.CId 查询各科成绩前三名的记录 思路：前三名转化为若大于此成绩的数量少于3即为前三名。 select * from sc where (select count(*) from sc as a where sc.CId =a.CId and sc.score &lt;a.score )&lt;3 ORDER BY CId asc,sc.score desc 查询每门课程被选修的学生数 select sc.CId,count(*) from sc GROUP BY sc.CId 查询出只选修两门课程的学生学号和姓名 select student.SId,student.Sname from sc,student where student.SId=sc.SId GROUP BY sc.SId HAVING count(*)=2 21.查询男生、女生人数 select student.Ssex ,count(*) as 人数 from student GROUP BY student.Ssex 查询名字中含有「风」字的学生信息select * from student where student.Sname like '%风%' 23.查询同名同性学生名单，并统计同名人数 select * from student LEFT JOIN (select Sname,Ssex,COUNT(*)同名人数 from Student group by Sname,Ssex) as t1 on student.Sname =t1.Sname and student.Ssex=t1.Ssex where t1.同名人数>1 24.查询 1990 年出生的学生名单 select * from student where YEAR(student.Sage)=1990 25.查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 select sc.CId,AVG(sc.score) from sc GROUP BY sc.CId ORDER BY AVG(sc.score) desc ,sc.CId asc 26.查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩 select student.SId,student.Sname,t1.avgscore from student INNER JOIN (select sc.SId ,AVG(sc.score) as avgscore from sc GROUP BY sc.SId HAVING AVG(sc.score)>85) as t1 on student.SId=t1.SId 查询课程名称为「数学」，且分数低于 60 的学生姓名和分数 select student.Sname ,t1.score from student INNER JOIN (select sc.SId,sc.score from sc,course where sc.CId=course.CId and course.Cname='数学' and sc.score&lt;60)as t1 on student.SId=t1.SId 查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）Mysql 练习题 select student.SId,sc.CId,sc.score from Student left join sc on student.SId=sc.SId 查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数 select student.Sname,course.Cname,sc.score from student , sc ,course where sc.score>=70 and student.SId=sc.SId and sc.CId=course.CId 30.查询存在不及格的课程 select DISTINCT sc.CId from sc where sc.score &lt;60 31.查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名 select student.SId,student.Sname from student ,sc where sc.CId='01' and student.SId=sc.SId and sc.score>80 求每门课程的学生人数 select sc.CId,count(*) as 学生人数 from sc GROUP BY sc.CId 成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 select student.*,sc.score from student ,course ,teacher ,sc where course.CId=sc.CId and course.TId=teacher.TId and teacher.Tname='张三' and student.SId =sc.SId LIMIT 1 成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 select student.*,t1.score from student INNER JOIN (select sc.SId,sc.score, case when @fontage=sc.score then @rank when @fontage:=sc.score then @rank:=@rank+1 end as rank from course ,teacher ,sc,(select @fontage:=null,@rank:=0) as t where course.CId=sc.CId and course.TId=teacher.TId and teacher.Tname='张三' ORDER BY sc.score DESC) as t1 on student.SId=t1.SId where t1.rank=1 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 select * from sc as t1 where exists(select * from sc as t2 where t1.SId=t2.SId and t1.CId!=t2.CId and t1.score =t2.score ) 36.查询每门功成绩最好的前两名 select * from sc as t1 where (select count(*) from sc as t2 where t1.CId=t2.CId and t2.score >t1.score)&lt;2 ORDER BY t1.CId 37.统计每门课程的学生选修人数（超过 5 人的课程才统计） select sc.CId as 课程编号,count(*) as 选修人数 from sc GROUP BY sc.CId HAVING count(*)>5 38.检索至少选修两门课程的学生学号 select DISTINCT t1.SId from sc as t1 where (select count(* )from sc where t1.SId=sc.SId)>=3 查询选修了全部课程的学生信息select student.* from sc ,student where sc.SId=student.SId GROUP BY sc.SId HAVING count(*) = (select DISTINCT count(*) from course ) 40.查询各学生的年龄，只按年份来算 select student.SId as 学生编号,student.Sname as 学生姓名,TIMESTAMPDIFF(YEAR,student.Sage,CURDATE()) as 学生年龄 from student 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一select student.SId as 学生编号,student.Sname as 学生姓名,TIMESTAMPDIFF(YEAR,student.Sage,CURDATE()) as 学生年龄 from student 42.查询本周过生日的学生 select * from student where YEARWEEK(student.Sage)=YEARWEEK(CURDATE()) 查询下周过生日的学生select * from student where YEARWEEK(student.Sage)=CONCAT(YEAR(CURDATE()),week(CURDATE())+1) 44.查询本月过生日的学生 select * from student where EXTRACT(YEAR_MONTH FROM student.Sage)=EXTRACT(YEAR_MONTH FROM CURDATE()) 45.查询下月过生日的学生 select * from student where EXTRACT(YEAR_MONTH FROM student.Sage)=EXTRACT(YEAR_MONTH FROM DATE_ADD(CURDATE(),INTERVAL 1 MONTH))]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github上10个开源免费且优秀的后台控制面板]]></title>
    <url>%2FGithub%E4%B8%8A10%E4%B8%AA%E5%BC%80%E6%BA%90%E5%85%8D%E8%B4%B9%E4%B8%94%E4%BC%98%E7%A7%80%E7%9A%84%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF.html</url>
    <content type="text"><![CDATA[Web 开发中几乎的平台都需要一个后台管理，但是从零开发一套后台控制面板并不容易，幸运的是有很多开源免费的后台控制面板可以给开发者使用，那么有哪些优秀的开源免费的控制面板呢？我在 Github 上收集了一些优秀的后台控制面板，并总结得出 Top 10 AdminLTEGithub Star 数 24969 ， Github 地址： https://github.com/almasaeed2010/AdminLTE 非常流行的基于 Bootstrap 3.x 的免费的后台 UI 框架。 vue-Element-AdminGithub Star 数 19546， Github 地址： https://github.com/PanJiaChen/vue-element-admin 一个基于 vue2.0 和 Eelement 的控制面板 UI 框架。 tablerGithub Star 数 15870， Github 地址： https://github.com/tabler/tabler 构建在 BootStrap 4 之上的免费的 HTML 控制面板框架 GentelellaGithub Star 数 15654， Github 地址： https://github.com/puikinsh/gentelella 一个基于 Bootstarp 的免费的后台控制面板。 ng2-adminGithub Star 数 13181， Github 地址： https://github.com/akveo/ngx-admin ant-design-proGithub Star 数 12707，Github 地址： https://github.com/ant-design/ant-design-pro 开箱即用的中台前端/设计解决方案 blur-adminGithub Star 数 9241，Github 地址： https://github.com/akveo/blur-admin 基于 Angular 和 Bootstrap 的后台管理面板框架。 vue-adminGithub Star 数 8676，Github 地址： https://github.com/vue-bulma/vue-admin 基于 Vue 和 Bulma 的控制面板。 iview-adminGithub Star 数 8668，Github 地址： https://github.com/iview/iview-admin 基于 iView 的 Vue 2.0 控制面板。 material-dashboardGithub Star 数 7111，Github 地址： https://github.com/creativetimofficial/material-dashboard 基于 Bootstrap 4 和 Material 风格的控制面板。]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的强引用、软引用、弱引用和虚引用]]></title>
    <url>%2FJava%E7%9A%84%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8.html</url>
    <content type="text"><![CDATA[Java执行GC判断对象是否存活有两种方式其中一种是引用计数。 引用计数：Java堆中每一个对象都有一个引用计数属性，引用每新增1次计数加1，引用每释放1次计数减1。 在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。 1. 强引用(StrongReference) 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下： Object strongReference = new Object(); 当内存空间不足时，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果强引用对象不使用时，需要弱化从而使GC能够回收，如下： strongReference = null; 显式地设置strongReference对象为null，或让其超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于GC算法。 public void test() { Object strongReference = new Object(); // 省略其他操作 } 在一个方法的内部有一个强引用，这个引用保存在Java栈中，而真正的引用内容(Object)保存在Java堆中。当这个方法运行完成后，就会退出方法栈，则引用对象的引用数为0，这个对象会被回收。但是如果这个strongReference是全局变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。ArrayList的Clear方法：在ArrayList类中定义了一个elementData数组，在调用clear方法清空数组时，每个数组元素被赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用add()等方法添加元素时进行内存的重新分配。使用如clear()方法内存数组中存放的引用类型进行内存释放特别适用，这样就可以及时释放内存。 2. 软引用(SoftReference) 如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 软引用可用来实现内存敏感的高速缓存。 // 强引用 String strongReference = new String("abc"); // 软引用 String str = new String("abc"); SoftReference&lt;String> softReference = new SoftReference&lt;String>(str); 软引用可以和一个引用队列(ReferenceQueue)联合使用。如果软引用所引用对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。 ReferenceQueue&lt;String> referenceQueue = new ReferenceQueue&lt;>(); String str = new String("abc"); SoftReference&lt;String> softReference = new SoftReference&lt;>(str, referenceQueue); str = null; // Notify GC System.gc(); System.out.println(softReference.get()); // abc Reference&lt;? extends String> reference = referenceQueue.poll(); System.out.println(reference); //null 注意：软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收。 当内存不足时，JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收： if(JVM内存不足) { // 将软引用中的对象引用置为null str = null; // 通知垃圾回收器进行回收 System.gc(); } 也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。对那些刚构建的或刚使用过的”较新的”软对象会被虚拟机尽可能保留，这就是引入引用队列ReferenceQueue的原因。应用场景：浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。 如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建；如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。 这时候就可以使用软引用，很好的解决了实际的问题： // 获取浏览器对象进行浏览 Browser browser = new Browser(); // 从后台程序加载浏览页面 BrowserPage page = browser.getPage(); // 将浏览完毕的页面置为软引用 SoftReference softReference = new SoftReference(page); // 回退或者再次浏览此页面时 if(softReference.get() != null) { // 内存充足，还没有被回收器回收，直接获取缓存 page = softReference.get(); } else { // 内存不足，软引用的对象已经回收 page = browser.getPage(); // 重新构建软引用 softReference = new SoftReference(page); } 3. 弱引用(WeakReference) 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 String str = new String("abc"); WeakReference&lt;String> weakReference = new WeakReference&lt;>(str); str = null; JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收： str = null; System.gc(); 注意：如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。 下面的代码会让一个弱引用再次变为一个强引用： String str = new String("abc"); WeakReference&lt;String> weakReference = new WeakReference&lt;>(str); // 弱引用转强引用 String strongReference = weakReference.get(); 同样，弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。简单测试：GCTarget.java public class GCTarget { // 对象的ID public String id; // 占用内存空间 byte[] buffer = new byte[1024]; public GCTarget(String id) { this.id = id; } protected void finalize() throws Throwable { // 执行垃圾回收时打印显示对象ID System.out.println("Finalizing GCTarget, id is : " + id); } } GCTargetWeakReference.java public class GCTargetWeakReference extends WeakReference&lt;GCTarget> { // 弱引用的ID public String id; public GCTargetWeakReference(GCTarget gcTarget, ReferenceQueue&lt;? super GCTarget> queue) { super(gcTarget, queue); this.id = gcTarget.id; } protected void finalize() { System.out.println("Finalizing GCTargetWeakReference " + id); } } WeakReferenceTest.java public class WeakReferenceTest { // 弱引用队列 private final static ReferenceQueue&lt;GCTarget> REFERENCE_QUEUE = new ReferenceQueue&lt;>(); public static void main(String[] args) { LinkedList&lt;GCTargetWeakReference> gcTargetList = new LinkedList&lt;>(); // 创建弱引用的对象，依次加入链表中 for (int i = 0; i &lt; 5; i++) { GCTarget gcTarget = new GCTarget(String.valueOf(i)); GCTargetWeakReference weakReference = new GCTargetWeakReference(gcTarget, REFERENCE_QUEUE); gcTargetList.add(weakReference); System.out.println("Just created GCTargetWeakReference obj: " + gcTargetList.getLast()); } // 通知GC进行垃圾回收 System.gc(); try { // 休息几分钟，等待上面的垃圾回收线程运行完成 Thread.sleep(6000); } catch (InterruptedException e) { e.printStackTrace(); } // 检查关联的引用队列是否为空 Reference&lt;? extends GCTarget> reference; while((reference = REFERENCE_QUEUE.poll()) != null) { if(reference instanceof GCTargetWeakReference) { System.out.println("In queue, id is: " + ((GCTargetWeakReference) (reference)).id); } } } } 运行WeakReferenceTest.java，运行结果如下：可见WeakReference对象的生命周期基本由垃圾回收器决定，一旦垃圾回收线程发现了弱引用对象，在下一次GC过程中就会对其进行回收。 4. 虚引用(PhantomReference) 虚引用顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 应用场景：虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 String str = new String("abc"); ReferenceQueue queue = new ReferenceQueue(); // 创建虚引用，要求必须与一个引用队列关联 PhantomReference pr = new PhantomReference(str, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 总结:Java中4种引用的级别和强度由高到低依次为：强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收。通过表格来说明一下，如下： 引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 当内存不足时 对象缓存 内存不足时终止 弱引用 正常垃圾回收时 对象缓存 垃圾回收后终止 虚引用 正常垃圾回收时 跟踪对象的垃圾回收 垃圾回收后终止]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC 容器源码分析]]></title>
    <url>%2FSpring%2BIOC%2B%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。 本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。 阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。 希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。 引言先看下最基本的启动 Spring 容器的例子： public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationfile.xml"); } 以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。 &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;version>4.3.11.RELEASE&lt;/version> &lt;/dependency> spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。 多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。 废话说完，我们继续。ApplicationContext context = new ClassPathXmlApplicationContext(...) 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的： 读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。 当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。 我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext 这两个类。 FileSystemXmlApplicationContext 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。 AnnotationConfigApplicationContext 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。 不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。 我们先来一个简单的例子来看看怎么实例化 ApplicationContext。 首先，定义一个接口： public interface MessageService { String getMessage(); } 定义接口实现类： public class MessageServiceImpl implements MessageService { public String getMessage() { return "hello world"; } } 接下来，我们在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了： &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-autowire="byName"> &lt;bean id="messageService" class="com.javadoop.example.MessageServiceImpl"/> &lt;/beans> 这样，我们就可以跑起来了： public class App { public static void main(String[] args) { // 用我们的配置文件来启动一个 ApplicationContext ApplicationContext context = new ClassPathXmlApplicationContext("classpath:application.xml"); System.out.println("context 启动成功"); // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式 MessageService messageService = context.getBean(MessageService.class); // 这句将输出: hello world System.out.println(messageService.getMessage()); } } 以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。 BeanFactory 简介BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。 初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构： 我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。 ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。 ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。 AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。 ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。 请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。 然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。 启动过程分析下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。 第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。 public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext { private Resource[] configResources; // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法 public ClassPathXmlApplicationContext(ApplicationContext parent) { super(parent); } ... public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException { super(parent); // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割) setConfigLocations(configLocations); if (refresh) { refresh(); // 核心方法 } } ... } 接下来，就是 refresh()，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。 往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。 @Override public void refresh() throws BeansException, IllegalStateException { // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛 synchronized (this.startupShutdownMonitor) { // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中， // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了， // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map) ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean // 这块待会会展开说 prepareBeanFactory(beanFactory); try { // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口， // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】 // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化 // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事 postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法 invokeBeanFactoryPostProcessors(beanFactory); // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别 // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化 registerBeanPostProcessors(beanFactory); // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了 initMessageSource(); // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了 initApplicationEventMulticaster(); // 从方法名就可以知道，典型的模板方法(钩子方法)， // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过 registerListeners(); // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // 最后，广播事件，ApplicationContext 初始化完成 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); } // Destroy already created singletons to avoid dangling resources. // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源 destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // 把异常往外抛 throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } 下面，我们开始一步步来肢解这个 refresh() 方法。 创建 Bean 容器前的准备工作这个比较简单，直接看代码中的几个注释即可。 protected void prepareRefresh() { // 记录启动时间， // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型 this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isInfoEnabled()) { logger.info("Refreshing " + this); } // Initialize any placeholder property sources in the context environment initPropertySources(); // 校验 xml 配置文件 getEnvironment().validateRequiredProperties(); this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent>(); } 创建 Bean 容器，加载并注册 Bean我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。 注意，这个方法是全文最重要的部分之一，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。 当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。 // AbstractApplicationContext.java protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等 refreshBeanFactory(); // 返回刚刚创建的 BeanFactory ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) { logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory); } return beanFactory; } // AbstractRefreshableApplicationContext.java 120 @Override protected final void refreshBeanFactory() throws BeansException { // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前 // ApplicationContext 是否有 BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。 DefaultListableBeanFactory beanFactory = createBeanFactory(); // 用于 BeanFactory 的序列化，我想不部分人应该都用不到 beanFactory.setSerializationId(getId()); // 下面这两个方法很重要，别跟丢了，具体细节之后说 // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用 customizeBeanFactory(beanFactory); // 加载 Bean 到 BeanFactory 中 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex); } } 看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。 我们说说为什么选择实例化 DefaultListableBeanFactory ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下： 我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。 如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？ 之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。 在继续往下之前，我们需要先了解 BeanDefinition。我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？ 这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。 所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以认为是 BeanDefinition 的实例。 BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。 BeanDefinition 接口定义我们来看下 BeanDefinition 的接口定义： public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement { // 我们可以看到，默认只提供 sington 和 prototype 两种， // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种， // 不过，它们属于基于 web 的扩展。 String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; // 比较不重要，直接跳过吧 int ROLE_APPLICATION = 0; int ROLE_SUPPORT = 1; int ROLE_INFRASTRUCTURE = 2; // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍 // 一句话就是：继承父 Bean 的配置信息而已 void setParentName(String parentName); // 获取父 Bean String getParentName(); // 设置 Bean 的类名称，将来是要通过反射来生成实例的 void setBeanClassName(String beanClassName); // 获取 Bean 的类名称 String getBeanClassName(); // 设置 bean 的 scope void setScope(String scope); String getScope(); // 设置是否懒加载 void setLazyInit(boolean lazyInit); boolean isLazyInit(); // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)， // 是 depends-on="" 属性设置的值。 void setDependsOn(String... dependsOn); // 返回该 Bean 的所有依赖 String[] getDependsOn(); // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效， // 如果根据名称注入，即使这边设置了 false，也是可以的 void setAutowireCandidate(boolean autowireCandidate); // 该 Bean 是否可以注入到其他 Bean 中 boolean isAutowireCandidate(); // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean void setPrimary(boolean primary); // 是否是 primary 的 boolean isPrimary(); // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录 // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的 void setFactoryBeanName(String factoryBeanName); // 获取工厂名称 String getFactoryBeanName(); // 指定工厂类中的 工厂方法名称 void setFactoryMethodName(String factoryMethodName); // 获取工厂类中的 工厂方法名称 String getFactoryMethodName(); // 构造器参数 ConstructorArgumentValues getConstructorArgumentValues(); // Bean 中的属性值，后面给 bean 注入属性值的时候会说到 MutablePropertyValues getPropertyValues(); // 是否 singleton boolean isSingleton(); // 是否 prototype boolean isPrototype(); // 如果这个 Bean 是被设置为 abstract，那么不能实例化， // 常用于作为 父bean 用于继承，其实也很少用...... boolean isAbstract(); int getRole(); String getDescription(); String getResourceDescription(); BeanDefinition getOriginatingBeanDefinition(); } 这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。 这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。 有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分： customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); 虽然只有两个方法，但路还很长啊。。。 customizeBeanFactorycustomizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。 protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) { if (this.allowBeanDefinitionOverriding != null) { // 是否允许 Bean 定义覆盖 beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); } if (this.allowCircularReferences != null) { // 是否允许 Bean 间的循环依赖 beanFactory.setAllowCircularReferences(this.allowCircularReferences); } } BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。 循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。 默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。 至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。 之后的源码中还会出现这两个属性，读者有个印象就可以了。 加载 Bean: loadBeanDefinitions接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。 读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。 // AbstractXmlApplicationContext.java 80 /** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/ @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的， // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧 initBeanDefinitionReader(beanDefinitionReader); // 重点来了，继续往下 loadBeanDefinitions(beanDefinitionReader); } 现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。 // AbstractXmlApplicationContext.java 120 protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource[] configResources = getConfigResources(); if (configResources != null) { // 往下看 reader.loadBeanDefinitions(configResources); } String[] configLocations = getConfigLocations(); if (configLocations != null) { // 2 reader.loadBeanDefinitions(configLocations); } } // 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里 @Override public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException { Assert.notNull(resources, "Resource array must not be null"); int counter = 0; // 注意这里是个 for 循环，也就是每个文件是一个 resource for (Resource resource : resources) { // 继续往下看 counter += loadBeanDefinitions(resource); } // 最后返回 counter，表示总共加载了多少的 BeanDefinition return counter; } // XmlBeanDefinitionReader 303 @Override public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { return loadBeanDefinitions(new EncodedResource(resource)); } // XmlBeanDefinitionReader 314 public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, "EncodedResource must not be null"); if (logger.isInfoEnabled()) { logger.info("Loading XML bean definitions from " + encodedResource.getResource()); } // 用一个 ThreadLocal 来存放配置文件资源 Set&lt;EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;EncodedResource>(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( "Detected cyclic loading of " + encodedResource + " - check your import definitions!"); } try { InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } // 核心部分是这里，往下面看 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( "IOException parsing XML document from " + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } } } // 还在这个文件中，第 388 行 protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 这里就不看了，将 xml 文件转换为 Document 对象 Document doc = doLoadDocument(inputSource, resource); // 继续 return registerBeanDefinitions(doc, resource); } catch (... } // 还在这个文件中，第 505 行 // 返回值：返回从当前配置文件加载了多少数量的 Bean public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // 这里 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore; } // DefaultBeanDefinitionDocumentReader 90 @Override public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; logger.debug("Loading bean definitions"); Element root = doc.getDocumentElement(); // 从 xml 根节点开始解析文件 doRegisterBeanDefinitions(root); } 经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析： doRegisterBeanDefinitions：// DefaultBeanDefinitionDocumentReader 116 protected void doRegisterBeanDefinitions(Element root) { // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义， // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题， // 因为 &lt;beans /> 内部是可以定义 &lt;beans /> 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /> 节点，从源码分析的角度，我们当做根节点就好了 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { // 这块说的是根节点 &lt;beans ... profile="dev" /> 中的 profile 是否是当前环境需要的， // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /> 解析 // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isInfoEnabled()) { logger.info("Skipped XML bean definition file due to specified profiles [" + profileSpec + "] not matching: " + getReaderContext().getResource()); } return; } } } preProcessXml(root); // 钩子 // 往下看 parseBeanDefinitions(root, this.delegate); postProcessXml(root); // 钩子 this.delegate = parent; } preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。 这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。 接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) : // default namespace 涉及到的就四个标签 &lt;import />、&lt;alias />、&lt;bean /> 和 &lt;beans />， // 其他的属于 custom 的 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { // 解析 default namespace 下面的几个元素 parseDefaultElement(ele, delegate); } else { // 解析其他 namespace 的元素 delegate.parseCustomElement(ele); } } } } else { delegate.parseCustomElement(root); } } 从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。 parseDefaultElement(ele, delegate) 代表解析的节点是 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt; 这几个。 这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的： http://www.springframework.org/schema/beans 又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。 &lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-autowire="byName"> 而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;等。 这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。 假如读者想分析 &lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt; 的实现原理，就应该到 ContextNamespaceHandler 中找答案。 &lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd " default-autowire="byName"> 回过神来，看看处理 default 标签的方法： private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { // 处理 &lt;import /> 标签 importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { // 处理 &lt;alias /> 标签定义 // &lt;alias name="fromName" alias="toName"/> processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { // 处理 &lt;bean /> 标签定义，这也算是我们的重点吧 processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // 如果碰到的是嵌套的 &lt;beans /> 标签，需要递归 doRegisterBeanDefinitions(ele); } } 如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 &lt;bean /&gt; 标签出来说。 processBeanDefinition 解析 bean 标签下面是 processBeanDefinition 解析 &lt;bean /&gt; 标签： // DefaultBeanDefinitionDocumentReader 298 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // 将 &lt;bean /> 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的 if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error("Failed to register bean definition with name '" + bdHolder.getBeanName() + "'", ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 继续往下看怎么解析之前，我们先看下 &lt;bean /&gt; 标签中可以定义哪些属性： Property class 类的全限定名 name 可指定 id、name(用逗号、分号、空格分隔) scope 作用域 constructor arguments 指定构造参数 properties 设置属性的值 autowiring mode no(默认值)、byName、byType、 constructor lazy-initialization mode 是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了) initialization method bean 属性设置完成后，会调用这个方法 destruction method bean 销毁后的回调方法 上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。 简单地说就是像下面这样子： &lt;bean id="exampleBean" name="name1, name2, name3" class="com.javadoop.ExampleBean" scope="singleton" lazy-init="true" init-method="init" destroy-method="cleanup"> &lt;!-- 可以用下面三种形式指定构造参数 --> &lt;constructor-arg type="int" value="7500000"/> &lt;constructor-arg name="years" value="7500000"/> &lt;constructor-arg index="0" value="7500000"/> &lt;!-- property 的几种情况 --> &lt;property name="beanOne"> &lt;ref bean="anotherExampleBean"/> &lt;/property> &lt;property name="beanTwo" ref="yetAnotherBean"/> &lt;property name="integerProperty" value="1"/> &lt;/bean> 当然，除了上面举例出来的这些，还有 factory-bean、factory-method、&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt; 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。 有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。 // BeanDefinitionParserDelegate 428 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null); } public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) { String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String> aliases = new ArrayList&lt;String>(); // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组， // 当然，如果你不定义 name 属性的话，就是空的了 // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了 if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; // 如果没有指定id, 那么用别名列表的第一个名字作为beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isDebugEnabled()) { logger.debug("No XML 'id' specified - using '" + beanName + "' as bean name and " + aliases + " as aliases"); } } if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } // 根据 &lt;bean ...>...&lt;/bean> 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中, // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); // 到这里，整个 &lt;bean /> 标签就算解析结束了，一个 BeanDefinition 就形成了。 if (beanDefinition != null) { // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生 // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要 if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) {// 按照我们的思路，这里 containingBean 是 null 的 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { // 如果我们不定义 id 和 name，那么我们引言里的那个例子： // 1. beanName 为：com.javadoop.example.MessageServiceImpl#0 // 2. beanClassName 为：com.javadoop.example.MessageServiceImpl beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() > beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { // 把 beanClassName 设置为 Bean 的别名 aliases.add(beanClassName); } } if (logger.isDebugEnabled()) { logger.debug("Neither XML 'id' nor 'name' specified - " + "using generated bean name [" + beanName + "]"); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回 BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null; } 然后，我们再看看怎么根据配置创建 BeanDefinition 实例的： public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } try { String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了 AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); /** * 下面的一堆是解析 &lt;bean>......&lt;/bean> 内部的子元素， * 解析出来以后的信息都放到 bd 的属性中 */ // 解析 &lt;meta /> parseMetaElements(ele, bd); // 解析 &lt;lookup-method /> parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;replaced-method /> parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;constructor-arg /> parseConstructorArgElements(ele, bd); // 解析 &lt;property /> parsePropertyElements(ele, bd); // 解析 &lt;qualifier /> parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error("Bean class [" + className + "] not found", ele, ex); } catch (NoClassDefFoundError err) { error("Class that bean class [" + className + "] depends on not found", ele, err); } catch (Throwable ex) { error("Unexpected failure during bean definition parsing", ele, ex); } finally { this.parseState.pop(); } return null; } 到这里，我们已经完成了根据 &lt;bean /&gt; 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。 我们回到解析 &lt;bean /&gt; 的入口方法: protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // 将 &lt;bean /> 节点转换为 BeanDefinitionHolder，就是上面说的一堆 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // 如果有自定义属性的话，进行相应的解析，先忽略 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // 我们把这步叫做 注册Bean 吧 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error("Failed to register bean definition with name '" + bdHolder.getBeanName() + "'", ele, ex); } // 注册完成后，发送事件，本文不展开说这个 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 &lt;bean /&gt; 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上： public class BeanDefinitionHolder implements BeanMetadataElement { private final BeanDefinition beanDefinition; private final String beanName; private final String[] aliases; ... 然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。 下面，我们开始说说注册 Bean 吧。 注册 Bean// BeanDefinitionReaderUtils 143 public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); // 注册这个 Bean registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了 String[] aliases = definitionHolder.getAliases(); if (aliases != null) { for (String alias : aliases) { // alias -> beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了， // 获取的时候，会先将 alias 转换为 beanName，然后再查找 registry.registerAlias(beanName, alias); } } } 别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。 // DefaultListableBeanFactory 793 @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, "Bean name must not be empty"); Assert.notNull(beanDefinition, "BeanDefinition must not be null"); if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(...); } } // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding BeanDefinition oldBeanDefinition; // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中 oldBeanDefinition = this.beanDefinitionMap.get(beanName); // 处理重复名称的 Bean 定义的情况 if (oldBeanDefinition != null) { if (!isAllowBeanDefinitionOverriding()) { // 如果不允许覆盖的话，抛异常 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()... } else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) { // log...用框架定义的 Bean 覆盖用户自定义的 Bean } else if (!beanDefinition.equals(oldBeanDefinition)) { // log...用新的 Bean 覆盖旧的 Bean } else { // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean } // 覆盖 this.beanDefinitionMap.put(beanName, beanDefinition); } else { // 判断是否已经有其他的 Bean 开始初始化了. // 注意，"注册Bean" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程， // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans if (hasBeanCreationStarted()) { // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) { this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String> updatedDefinitions = new ArrayList&lt;String>(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) { Set&lt;String> updatedSingletons = new LinkedHashSet&lt;String>(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; } } } else { // 最正常的应该是进到这个分支。 // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition this.beanDefinitionMap.put(beanName, beanDefinition); // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字 this.beanDefinitionNames.add(beanName); // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean， // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的 // 手动指的是通过调用以下方法注册的 bean ： // registerSingleton(String beanName, Object singletonObject) // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面"手动"注册一些 Bean， // 如 "environment"、"systemProperties" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的 this.manualSingletonNames.remove(beanName); } // 这个不重要，在预初始化的时候会用到，不必管它。 this.frozenBeanDefinitionNames = null; } if (oldBeanDefinition != null || containsSingleton(beanName)) { resetBeanDefinition(beanName); } } 总结一下，到这里已经初始化了 Bean 容器，&lt;bean /&gt; 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。 到这里是一个分水岭，前面的内容都还算比较简单，大家要清楚地知道前面都做了哪些事情。 Bean 容器实例化完成后说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。 考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。 @Override public void refresh() throws BeansException, IllegalStateException { // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛 synchronized (this.startupShutdownMonitor) { // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中， // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了， // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map) ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean // 这块待会会展开说 prepareBeanFactory(beanFactory); try { // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口， // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】 // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化 // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事 postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法 invokeBeanFactoryPostProcessors(beanFactory); // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别 // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机 registerBeanPostProcessors(beanFactory); // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了 initMessageSource(); // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了 initApplicationEventMulticaster(); // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说 // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过 registerListeners(); // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // 最后，广播事件，ApplicationContext 初始化完成，不展开 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); } // Destroy already created singletons to avoid dangling resources. // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源 destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // 把异常往外抛 throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } 准备 Bean 容器: prepareBeanFactory之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。 这里简单介绍下 prepareBeanFactory(factory) 方法： /** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */ protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器， // 这里设置为加载当前 ApplicationContext 类的类加载器 beanFactory.setBeanClassLoader(getClassLoader()); // 设置 BeanExpressionResolver beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // 添加一个 BeanPostProcessor，这个 processor 比较简单： // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调， // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware // 注意：它不仅仅回调 ApplicationContextAware， // 还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们， // Spring 会通过其他方式来处理这些依赖。 beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); /** * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值， * 之前我们说过，"当前 ApplicationContext 持有一个 BeanFactory"，这里解释了第一行 * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean */ beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类， // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它 // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样， // 感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } /** * 从下面几行代码我们可以知道，Spring 往往很 "智能" 就是因为它会帮我们默认注册一些有用的 bean， * 我们也可以选择覆盖 */ // 如果没有定义 "environment" 这个 bean，那么 Spring 会 "手动" 注册一个 if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } // 如果没有定义 "systemProperties" 这个 bean，那么 Spring 会 "手动" 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } // 如果没有定义 "systemEnvironment" 这个 bean，那么 Spring 会 "手动" 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); } } 在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。 初始化所有的 singleton beans我们的重点当然是 finishBeanFactoryInitialization(beanFactory); 这个巨头了，这里会负责初始化所有的 singleton beans。 注意，后面的描述中，我都会使用初始化或预初始化来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。 我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 ‘environment’、‘systemProperties’ 等。 剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。 // AbstractApplicationContext.java 834 // 初始化剩余的 singleton beans protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了 // 什么，看代码这里没有初始化 Bean 啊！ // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) { beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); } // Register a default embedded value resolver if no bean post-processor // (such as a PropertyPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values. if (!beanFactory.hasEmbeddedValueResolver()) { beanFactory.addEmbeddedValueResolver(new StringValueResolver() { @Override public String resolveStringValue(String strVal) { return getEnvironment().resolvePlaceholders(strVal); } }); } // 先初始化 LoadTimeWeaverAware 类型的 Bean // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) { getBean(weaverAwareName); } // Stop using the temporary ClassLoader for type matching. beanFactory.setTempClassLoader(null); // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了， // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。 beanFactory.freezeConfiguration(); // 开始初始化 beanFactory.preInstantiateSingletons(); } 从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。 preInstantiateSingletons// DefaultListableBeanFactory 728 @Override public void preInstantiateSingletons() throws BeansException { if (this.logger.isDebugEnabled()) { this.logger.debug("Pre-instantiating singletons in " + this); } // this.beanDefinitionNames 保存了所有的 beanNames List&lt;String> beanNames = new ArrayList&lt;String>(this.beanDefinitionNames); // 触发所有的非懒加载的 singleton beans 的初始化操作 for (String beanName : beanNames) { // 合并父 Bean 中的配置，注意 &lt;bean id="" class="" parent="" /> 中的 parent，用的不多吧， // 考虑到这可能会影响大家的理解，我在附录中解释了一下 "Bean 继承"，不了解的请到附录中看一下 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 非抽象、非懒加载的 singletons。如果配置了 'abstract = true'，那是不需要初始化的 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) { // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解) if (isFactoryBean(beanName)) { // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急 final FactoryBean&lt;?> factory = (FactoryBean&lt;?>) getBean(FACTORY_BEAN_PREFIX + beanName); // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过 boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean>() { @Override public Boolean run() { return ((SmartFactoryBean&lt;?>) factory).isEagerInit(); } }, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?>) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } else { // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了 getBean(beanName); } } } // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化 // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略 for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged(new PrivilegedAction&lt;Object>() { @Override public Object run() { smartSingleton.afterSingletonsInstantiated(); return null; } }, getAccessControlContext()); } else { smartSingleton.afterSingletonsInstantiated(); } } } } 接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。 getBean在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。 // AbstractBeanFactory 196 @Override public Object getBean(String name) throws BeansException { return doGetBean(name, null, null, false); } // 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路， // 已经初始化过了就从容器中直接返回，否则就先初始化再返回 @SuppressWarnings("unchecked") protected &lt;T> T doGetBean( final String name, final Class&lt;T> requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException { // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)， // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的 final String beanName = transformedBeanName(name); // 注意跟着这个，这个是返回值 Object bean; // 检查下是不是已经创建过了 Object sharedInstance = getSingleton(beanName); // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)， // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean if (sharedInstance != null &amp;&amp; args == null) { if (logger.isDebugEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.debug("..."); } else { logger.debug("Returning cached instance of singleton bean '" + beanName + "'"); } } // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance， // 如果是 FactoryBean 的话，返回它创建的那个实例对象 // (FactoryBean 知识，读者若不清楚请移步附录) bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { if (isPrototypeCurrentlyInCreation(beanName)) { // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常， // 往往是因为陷入了循环引用 throw new BeanCurrentlyInCreationException(beanName); } // 检查一下这个 BeanDefinition 在容器中是否存在 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) { // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有 String nameToLookup = originalBeanName(name); if (args != null) { // 返回父容器的查询结果 return (T) parentBeanFactory.getBean(nameToLookup, args); } else { // No args -> delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } } if (!typeCheckOnly) { // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。 markBeanAsCreated(beanName); } /* * 稍稍总结一下： * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean； * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。 */ try { final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 先初始化依赖的所有 Bean，这个很好理解。 // 注意，这里的依赖指的是 depends-on 中定义的依赖 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了 if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'"); } // 注册一下依赖关系 registerDependentBean(dep, beanName); // 先初始化被依赖项 getBean(dep); } } // 如果是 singleton scope 的，创建 singleton 的实例 if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object>() { @Override public Object getObject() throws BeansException { try { // 执行创建 Bean，详情后面再说 return createBean(beanName, mbd, args); } catch (BeansException ex) { destroySingleton(beanName); throw ex; } } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } // 如果是 prototype scope 的，创建 prototype 的实例 else if (mbd.isPrototype()) { // It's a prototype -> create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); // 执行创建 Bean prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理 else { String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'"); } try { Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object>() { @Override public Object getObject() throws BeansException { beforePrototypeCreation(beanName); try { // 执行创建 Bean return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } } }); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new BeanCreationException(beanName, "Scope '" + scopeName + "' is not active for the current thread; consider " + "defining a scoped proxy for this bean if you intend to refer to it from a singleton", ex); } } } catch (BeansException ex) { cleanupAfterBeanCreationFailure(beanName); throw ex; } } // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) { try { return getTypeConverter().convertIfNecessary(bean, requiredType); } catch (TypeMismatchException ex) { if (logger.isDebugEnabled()) { logger.debug("Failed to convert bean '" + name + "' to required type '" + ClassUtils.getQualifiedName(requiredType) + "'", ex); } throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } } return (T) bean; } 大家应该也猜到了，接下来当然是分析 createBean 方法： protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException; 第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。 这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。 主要是为了以下场景，采用 @Autowired 注解注入属性值： public class MessageServiceImpl implements MessageService { @Autowired private UserService userService; public String getMessage() { return userService.getMessage(); } } &lt;bean id="messageService" class="com.javadoop.example.MessageServiceImpl" /> 以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。 好了，读者要知道这么回事就可以了，继续向前。 // AbstractAutowireCapableBeanFactory 447 /** * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */ @Override protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException { if (logger.isDebugEnabled()) { logger.debug("Creating instance of bean '" + beanName + "'"); } RootBeanDefinition mbdToUse = mbd; // 确保 BeanDefinition 中的 Class 被加载 Class&lt;?> resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /> // 和 &lt;replaced-method />，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。 // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看 try { mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", ex); } try { // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理， // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", ex); } // 重头戏，创建 bean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) { logger.debug("Finished creating instance of bean '" + beanName + "'"); } return beanInstance; } 创建 Bean我们继续往里看 doCreateBean 这个方法： /** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks. * &lt;p>Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */ protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说 instanceWrapper = createBeanInstance(beanName, mbd, args); } // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 "bean 实例" final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); // 类型 Class&lt;?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", ex); } mbd.postProcessed = true; } } // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isDebugEnabled()) { logger.debug("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references"); } addSingletonFactory(beanName, new ObjectFactory&lt;Object>() { @Override public Object getObject() throws BeansException { return getEarlyBeanReference(beanName, mbd, bean); } }); } // Initialize the bean instance. Object exposedObject = bean; try { // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) { // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？ // 这里就是处理 bean 初始化完成后的各种回调 exposedObject = initializeBean(beanName, exposedObject, mbd); } } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex); } } if (earlySingletonExposure) { // Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set&lt;String> actualDependentBeans = new LinkedHashSet&lt;String>(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been " + "wrapped. This means that said other beans do not use the final version of the " + "bean. This is often the result of over-eager type matching - consider using " + "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."); } } } } // Register bean as disposable. try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex); } return exposedObject; } 到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。 接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。 创建 Bean 实例我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。 protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) { // 确保已经加载了此 class Class&lt;?> beanClass = resolveBeanClass(mbd, beanName); // 校验一下这个类的访问权限 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Bean class isn't public, and non-public access not allowed: " + beanClass.getName()); } if (mbd.getFactoryMethodName() != null) { // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean return instantiateUsingFactoryMethod(beanName, mbd, args); } // 如果不是第一次创建，比如第二次创建 prototype bean。 // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化 boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { if (autowireNecessary) { // 构造函数依赖注入 return autowireConstructor(beanName, mbd, null, null); } else { // 无参构造函数 return instantiateBean(beanName, mbd); } } // 判断是否采用有参构造函数 Constructor&lt;?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { // 构造函数依赖注入 return autowireConstructor(beanName, mbd, ctors, args); } // 调用无参构造函数 return instantiateBean(beanName, mbd); } 挑个简单的无参构造函数构造实例来看看： protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) { try { Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) { beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object>() { @Override public Object run() { return getInstantiationStrategy().instantiate(mbd, beanName, parent); } }, getAccessControlContext()); } else { // 实例化 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); } // 包装一下，返回 BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; } catch (Throwable ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex); } } 我们可以看到，关键的地方在于： beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); 这里会进行实际的实例化过程，我们进去看看: // SimpleInstantiationStrategy 59 @Override public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) { // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB, // 方法覆写 请参见附录"方法注入"中对 lookup-method 和 replaced-method 的介绍 if (bd.getMethodOverrides().isEmpty()) { Constructor&lt;?> constructorToUse; synchronized (bd.constructorArgumentLock) { constructorToUse = (Constructor&lt;?>) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) { final Class&lt;?> clazz = bd.getBeanClass(); if (clazz.isInterface()) { throw new BeanInstantiationException(clazz, "Specified class is an interface"); } try { if (System.getSecurityManager() != null) { constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?>>() { @Override public Constructor&lt;?> run() throws Exception { return clazz.getDeclaredConstructor((Class[]) null); } }); } else { constructorToUse = clazz.getDeclaredConstructor((Class[]) null); } bd.resolvedConstructorOrFactoryMethod = constructorToUse; } catch (Throwable ex) { throw new BeanInstantiationException(clazz, "No default constructor found", ex); } } } // 利用构造方法进行实例化 return BeanUtils.instantiateClass(constructorToUse); } else { // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。 // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持 return instantiateWithMethodInjection(bd, beanName, owner); } } 到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。 bean 属性注入看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。 // AbstractAutowireCapableBeanFactory 1203 protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) { // bean 实例的所有属性都在这里了 PropertyValues pvs = mbd.getPropertyValues(); if (bw == null) { if (!pvs.isEmpty()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance"); } else { // Skip property population phase for null instance. return; } } // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值， // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改， // 我也没找到有实际的使用，所以我们暂且忽略这块吧 boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { continueWithPropertyPopulation = false; break; } } } } if (!continueWithPropertyPopulation) { return; } if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // 通过类型装配。复杂一些 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) { PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) { return; } } } } if (needsDepCheck) { checkDependencies(beanName, mbd, filteredPds, pvs); } } // 设置 bean 实例的属性值 applyPropertyValues(beanName, mbd, bw, pvs); } initializeBean属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。 protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged(new PrivilegedAction&lt;Object>() { @Override public Object run() { invokeAwareMethods(beanName, bean); return null; } }, getAccessControlContext()); } else { // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调 invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor 的 postProcessBeforeInitialization 回调 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { // 处理 bean 中定义的 init-method， // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法 invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); } if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor 的 postProcessAfterInitialization 回调 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean; } 大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？ 附录id 和 name每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。 我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。 beanFactory.getBean("beanName or alias"); 在配置 &lt;bean /&gt; 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。 &lt;bean id="messageService" name="m1, m2, m3" class="com.javadoop.example.MessageServiceImpl"> 以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。 &lt;bean name="m1, m2, m3" class="com.javadoop.example.MessageServiceImpl" /> 以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。 &lt;bean class="com.javadoop.example.MessageServiceImpl"> beanName 为：com.javadoop.example.MessageServiceImpl#0， 别名 1 个，为： com.javadoop.example.MessageServiceImpl &lt;bean id="messageService" class="com.javadoop.example.MessageServiceImpl"> 以上配置的结果就是：beanName 为 messageService，没有别名。 配置是否允许 Bean 覆盖、是否允许循环依赖我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。 可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。 循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。 它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。 添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。 public class NoBeanOverridingContextLoader extends ContextLoader { @Override protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) { super.customizeContext(servletContext, applicationContext); AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext; arac.setAllowBeanDefinitionOverriding(false); } } public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener { @Override protected ContextLoader createContextLoader() { return new NoBeanOverridingContextLoader(); } } &lt;listener> &lt;listener-class>com.javadoop.MyContextLoaderListener&lt;/listener-class> &lt;/listener> 如果以上方式不能满足你的需求，请参考这个链接：解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题 profile我们可以把不同环境的配置分别配置到单独的文件中，举个例子： &lt;beans profile="development" xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xsi:schemaLocation="..."> &lt;jdbc:embedded-database id="dataSource"> &lt;jdbc:script location="classpath:com/bank/config/sql/schema.sql"/> &lt;jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/> &lt;/jdbc:embedded-database> &lt;/beans> &lt;beans profile="production" xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jee="http://www.springframework.org/schema/jee" xsi:schemaLocation="..."> &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/> &lt;/beans> 应该不必做过多解释了吧，看每个文件第一行的 profile=””。 当然，我们也可以在一个配置文件中使用： &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:jee="http://www.springframework.org/schema/jee" xsi:schemaLocation="..."> &lt;beans profile="development"> &lt;jdbc:embedded-database id="dataSource"> &lt;jdbc:script location="classpath:com/bank/config/sql/schema.sql"/> &lt;jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/> &lt;/jdbc:embedded-database> &lt;/beans> &lt;beans profile="production"> &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/> &lt;/beans> &lt;/beans> 理解起来也很简单吧。 接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？ Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。 最简单的方式莫过于在程序启动的时候指定： -Dspring.profiles.active="profile1,profile2" profile 可以激活多个 当然，我们也可以通过代码的形式从 Environment 中设置 profile： AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.getEnvironment().setActiveProfiles("development"); ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class); ctx.refresh(); // 重启 如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile： java -Dspring.profiles.active=prod -jar JavaDoop.jar 如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。 工厂模式生成 Bean请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。 设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。 静态工厂： &lt;bean id="clientService" class="examples.ClientService" factory-method="createInstance"/> public class ClientService { private static ClientService clientService = new ClientService(); private ClientService() {} // 静态方法 public static ClientService createInstance() { return clientService; } } 实例工厂： &lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"> &lt;!-- inject any dependencies required by this locator bean --> &lt;/bean> &lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/> &lt;bean id="accountService" factory-bean="serviceLocator" factory-method="createAccountServiceInstance"/> public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } public AccountService createAccountServiceInstance() { return accountService; } } FactoryBeanFactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。 public interface FactoryBean&lt;T> { T getObject() throws Exception; Class&lt;T> getObjectType(); boolean isSingleton(); } public class Person { private Car car ; private void setCar(Car car){ this.car = car; } } 我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来： public class MyCarFactoryBean implements FactoryBean&lt;Car>{ private String make; private int year ; public void setMake(String m){ this.make =m ; } public void setYear(int y){ this.year = y; } public Car getObject(){ // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种 CarBuilder cb = CarBuilder.car(); if(year!=0) cb.setYear(this.year); if(StringUtils.hasText(this.make)) cb.setMake( this.make ); return cb.factory(); } public Class&lt;Car> getObjectType() { return Car.class ; } public boolean isSingleton() { return false; } } 我们看看装配的时候是怎么配置的： &lt;bean class = "com.javadoop.MyCarFactoryBean" id = "car"> &lt;property name = "make" value ="Honda"/> &lt;property name = "year" value ="1984"/> &lt;/bean> &lt;bean class = "com.javadoop.Person" id = "josh"> &lt;property name = "car" ref = "car"/> &lt;/bean> 看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。 说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java config 的方式来配置，这里有什么不一样呢？ @Configuration public class CarConfiguration { @Bean public MyCarFactoryBean carFactoryBean(){ MyCarFactoryBean cfb = new MyCarFactoryBean(); cfb.setMake("Honda"); cfb.setYear(1984); return cfb; } @Bean public Person aPerson(){ Person person = new Person(); // 注意这里的不同 person.setCar(carFactoryBean().getObject()); return person; } } 这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。 初始化 Bean 的回调有以下四种方案： &lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/> public class AnotherExampleBean implements InitializingBean { public void afterPropertiesSet() { // do some initialization work } } @Bean(initMethod = "init") public Foo foo() { return new Foo(); } @PostConstruct public void init() { } 销毁 Bean 的回调&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/> public class AnotherExampleBean implements DisposableBean { public void destroy() { // do some destruction work (like releasing pooled connections) } } @Bean(destroyMethod = "cleanup") public Bar bar() { return new Bar(); } @PreDestroy public void cleanup() { } ConversionService既然文中说到了这个，顺便提一下好了。 最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。 像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。 &lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"> &lt;property name="converters"> &lt;list> &lt;bean class="com.javadoop.learning.utils.StringToEnumConverterFactory"/> &lt;/list> &lt;/property> &lt;/bean> ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。 下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。 来看一个很简单的例子，这样比什么都管用。 public class StringToDateConverter implements Converter&lt;String, Date> { @Override public Date convert(String source) { try { return DateUtils.parseDate(source, "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "HH:mm:ss", "HH:mm"); } catch (ParseException e) { return null; } } } 只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。 Bean 继承在初始化 Bean 的地方，我们说过了这个： RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); 这里涉及到的就是 &lt;bean parent=&quot;&quot; /&gt; 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。 首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。 Spring 中提供了继承自 AbstractBeanDefinition 的 ChildBeanDefinition 来表示 child bean。 看如下一个例子: &lt;bean id="inheritedTestBean" abstract="true" class="org.springframework.beans.TestBean"> &lt;property name="name" value="parent"/> &lt;property name="age" value="1"/> &lt;/bean> &lt;bean id="inheritsWithDifferentClass" class="org.springframework.beans.DerivedTestBean" parent="inheritedTestBean" init-method="initialize"> &lt;property name="name" value="override"/> &lt;/bean> parent bean 设置了 abstract=&quot;true&quot; 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。 child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。 当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。 比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。 &lt;bean id="inheritedTestBeanWithoutClass" abstract="true"> &lt;property name="name" value="parent"/> &lt;property name="age" value="1"/> &lt;/bean> 方法注入一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。 但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。 一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。 另一种解决方案就是这里要介绍的通过使用 Lookup method。 lookup-method我们来看一下 Spring Reference 中提供的一个例子： package fiona.apple; // no more Spring imports! public abstract class CommandManager { public Object process(Object commandState) { // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); } // okay... but where is the implementation of this method? protected abstract Command createCommand(); } xml 配置 &lt;lookup-method /&gt;： &lt;!-- a stateful bean deployed as a prototype (non-singleton) --> &lt;bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype"> &lt;!-- inject dependencies here as required --> &lt;/bean> &lt;!-- commandProcessor uses statefulCommandHelper --> &lt;bean id="commandManager" class="fiona.apple.CommandManager"> &lt;lookup-method name="createCommand" bean="myCommand"/> &lt;/bean> Spring 采用 CGLIB 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。 lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 &lt;lookup-method /&gt; 了，其他不变： public abstract class CommandManager { public Object process(Object commandState) { MyCommand command = createCommand(); command.setState(commandState); return command.execute(); } @Lookup("myCommand") protected abstract Command createCommand(); } 注意，既然用了注解，要配置注解扫描：&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt; 甚至，我们可以像下面这样： public abstract class CommandManager { public Object process(Object commandState) { MyCommand command = createCommand(); command.setState(commandState); return command.execute(); } @Lookup protected abstract MyCommand createCommand(); } 上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。 replaced-method记住它的功能，就是替换掉 bean 中的一些方法。 public class MyValueCalculator { public String computeValue(String input) { // some real code... } // some other methods... } 方法覆写，注意要实现 MethodReplacer 接口： public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer { public Object reimplement(Object o, Method m, Object[] args) throws Throwable { // get the input value, work with it, and return a computed result String input = (String) args[0]; ... return ...; } } 配置也很简单： &lt;bean id="myValueCalculator" class="x.y.z.MyValueCalculator"> &lt;!-- 定义 computeValue 这个方法要被替换掉 --> &lt;replaced-method name="computeValue" replacer="replacementComputeValue"> &lt;arg-type>String&lt;/arg-type> &lt;/replaced-method> &lt;/bean> &lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/> arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。 BeanPostProcessor应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义： public interface BeanPostProcessor { Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; } 看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。 首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。 我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。 那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。 最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？ 如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。 首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。 总结按理说，总结应该写在附录前面，我就不讲究了。 在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。 本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。 （全文完）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos 7 安装Erlang]]></title>
    <url>%2Fcentos%207%20%E5%AE%89%E8%A3%85Erlang.html</url>
    <content type="text"><![CDATA[1.安装Erlang编译依赖yum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget 2.下载Erlangwget http://www.erlang.org/download/otp_src_19.3.tar.gz 3.解压并安装tar -xzvf otp_src_19.3.tar.gz cd otp_src_19.3 ./configure --prefix=/usr/local/erlang make && make install 4.配置环境变量vi /etc/profile /usr/local/erlang/otp_src_19.3/bin 添加配置： --------------- ER_LANG=/usr/local/erlang/otp_src_19.3 PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$MAVEN_HOME/bin:$ER_LANG/bin: ---------------- source /etc/profile 查看环境变量配置： echo $PATH 5.验证Erlang 安装成功erl #进入编辑器； halt(). #退出编辑器,最后的点别忘记]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析]]></title>
    <url>%2FJava7%E5%92%8C8%2B%E4%B8%AD%E7%9A%84%2BHashMap%2B%E5%92%8C%2BConcurrentHashMap%2B%E5%85%A8%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。阅读建议：四节基本上可以进行独立阅读，建议初学者可按照 Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap 顺序进行阅读，可适当降低阅读门槛。 阅读前提：本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。 Java7 HashMapHashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。 首先，我们用下面这张图来介绍 HashMap 的结构。 这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。 大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。 上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 loadFactor：负载因子，默认为 0.75。 threshold：扩容的阈值，等于 capacity * loadFactor put 过程分析还是比较简单的，跟着代码走一遍吧。 public V put(K key, V value) { // 当插入第一个元素的时候，需要先初始化数组大小 if (table == EMPTY_TABLE) { inflateTable(threshold); } // 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中 if (key == null) return putForNullKey(value); // 1. 求 key 的 hash 值 int hash = hash(key); // 2. 找到对应的数组下标 int i = indexFor(hash, table.length); // 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在， // 如果有，直接覆盖，put 方法返回旧值就结束了 for (Entry&lt;K,V> e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; // 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说 addEntry(hash, key, value, i); return null; } 数组初始化在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。 private void inflateTable(int toSize) { // 保证数组大小一定是 2 的 n 次方。 // 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32 int capacity = roundUpToPowerOf2(toSize); // 计算扩容阈值：capacity * loadFactor threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); // 算是初始化数组吧 table = new Entry[capacity]; initHashSeedAsNeeded(capacity); //ignore } 这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。 计算具体数组位置这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。 static int indexFor(int hash, int length) { // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return hash &amp; (length-1); } 这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。 添加节点到链表中找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。 void addEntry(int hash, K key, V value, int bucketIndex) { // 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容 if ((size >= threshold) &amp;&amp; (null != table[bucketIndex])) { // 扩容，后面会介绍一下 resize(2 * table.length); // 扩容以后，重新计算 hash 值 hash = (null != key) ? hash(key) : 0; // 重新计算扩容后的新的下标 bucketIndex = indexFor(hash, table.length); } // 往下看 createEntry(hash, key, value, bucketIndex); } // 这个很简单，其实就是将新值放到链表的表头，然后 size++ void createEntry(int hash, K key, V value, int bucketIndex) { Entry&lt;K,V> e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;>(hash, key, value, e); size++; } 这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。 数组扩容前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。 void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } // 新的数组 Entry[] newTable = new Entry[newCapacity]; // 将原来数组中的值迁移到新的更大的数组中 transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } 扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。 由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。 get 过程分析相对于 put 过程，get 过程是非常简单的。 根据 key 计算 hash 值。 找到相应的数组下标：hash &amp; (length - 1)。 遍历该数组位置处的链表，直到找到相等(==或equals)的 key。 public V get(Object key) { // 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了 if (key == null) return getForNullKey(); // Entry&lt;K,V> entry = getEntry(key); return null == entry ? null : entry.getValue(); } getEntry(key): final Entry&lt;K,V> getEntry(Object key) { if (size == 0) { return null; } int hash = (key == null) ? 0 : hash(key); // 确定数组下标，然后从头开始遍历链表，直到找到为止 for (Entry&lt;K,V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } return null; } Java7 ConcurrentHashMapConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。 整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。 简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。 再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 初始化initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。 loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。 public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor > 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel > MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // Find power-of-two sizes best matching arguments int sshift = 0; int ssize = 1; // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方 while (ssize &lt; concurrencyLevel) { ++sshift; ssize &lt;&lt;= 1; } // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4 // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值 this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // initialCapacity 是设置整个 map 初始的大小， // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小 // 如 initialCapacity 为 64，那么每个 Segment 或称之为"槽"可以分到 4 个 int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上， // 插入一个元素不至于扩容，插入第二个的时候才会扩容 int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // 创建 Segment 数组， // 并创建数组的第一个元素 segment[0] Segment&lt;K,V> s0 = new Segment&lt;K,V>(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V>[])new HashEntry[cap]); Segment&lt;K,V>[] ss = (Segment&lt;K,V>[])new Segment[ssize]; // 往数组写入 segment[0] UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; } 初始化完成，我们得到了一个 Segment 数组。 我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后： Segment 数组长度为 16，不可以扩容 Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容 这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍 当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到 put 过程分析我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。 public V put(K key, V value) { Segment&lt;K,V> s; if (value == null) throw new NullPointerException(); // 1. 计算 key 的 hash 值 int hash = hash(key); // 2. 根据 hash 值找到 Segment 数组中的位置 j // hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位， // 然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标 int j = (hash >>> segmentShift) &amp; segmentMask; // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null， // ensureSegment(j) 对 segment[j] 进行初始化 if ((s = (Segment&lt;K,V>)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); // 3. 插入新值到 槽 s 中 return s.put(key, hash, value, false); } 第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。 Segment 内部是由 数组+链表 组成的。 final V put(K key, int hash, V value, boolean onlyIfAbsent) { // 在往该 segment 写入前，需要先获取该 segment 的独占锁 // 先看主流程，后面还会具体介绍这部分内容 HashEntry&lt;K,V> node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { // 这个是 segment 内部的数组 HashEntry&lt;K,V>[] tab = table; // 再利用 hash 值，求应该放置的数组下标 int index = (tab.length - 1) &amp; hash; // first 是数组该位置处的链表的表头 HashEntry&lt;K,V> first = entryAt(tab, index); // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况 for (HashEntry&lt;K,V> e = first;;) { if (e != null) { K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { // 覆盖旧值 e.value = value; ++modCount; } break; } // 继续顺着链表走 e = e.next; } else { // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。 // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。 if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V>(hash, key, value, first); int c = count + 1; // 如果超过了该 segment 的阈值，这个 segment 需要扩容 if (c > threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); // 扩容后面也会具体分析 else // 没有达到阈值，将 node 放到数组 tab 的 index 位置， // 其实就是将新的节点设置成原链表的表头 setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { // 解锁 unlock(); } return oldValue; } 整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。 到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。 初始化槽: ensureSegmentConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。 这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。 private Segment&lt;K,V> ensureSegment(int k) { final Segment&lt;K,V>[] ss = this.segments; long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset Segment&lt;K,V> seg; if ((seg = (Segment&lt;K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) { // 这里看到为什么之前要初始化 segment[0] 了， // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k] // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了 Segment&lt;K,V> proto = ss[0]; int cap = proto.table.length; float lf = proto.loadFactor; int threshold = (int)(cap * lf); // 初始化 segment[k] 内部的数组 HashEntry&lt;K,V>[] tab = (HashEntry&lt;K,V>[])new HashEntry[cap]; if ((seg = (Segment&lt;K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) { // 再次检查一遍该槽是否被其他线程初始化了。 Segment&lt;K,V> s = new Segment&lt;K,V>(lf, threshold, tab); // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出 while ((seg = (Segment&lt;K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) { if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s)) break; } } } return seg; } 总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。 我没搞懂这里为什么要搞一个 while 循环，CAS 失败不就代表有其他线程成功了吗，为什么要再进行判断？ 感谢评论区的李子木，如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。 获取写入锁: scanAndLockForPut前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。 下面我们来具体分析这个方法中是怎么控制加锁的。 private HashEntry&lt;K,V> scanAndLockForPut(K key, int hash, V value) { HashEntry&lt;K,V> first = entryForHash(this, hash); HashEntry&lt;K,V> e = first; HashEntry&lt;K,V> node = null; int retries = -1; // negative while locating node // 循环获取锁 while (!tryLock()) { HashEntry&lt;K,V> f; // to recheck first below if (retries &lt; 0) { if (e == null) { if (node == null) // speculatively create node // 进到这里说明数组该位置的链表是空的，没有任何元素 // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置 node = new HashEntry&lt;K,V>(hash, key, value, null); retries = 0; } else if (key.equals(e.key)) retries = 0; else // 顺着链表往下走 e = e.next; } // 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁 // lock() 是阻塞方法，直到获取锁后返回 else if (++retries > MAX_SCAN_RETRIES) { lock(); break; } else if ((retries &amp; 1) == 0 &amp;&amp; // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头 // 所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法 (f = entryForHash(this, hash)) != first) { e = first = f; // re-traverse if entry changed retries = -1; } } return node; } 这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。 这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。 扩容: rehash重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry\&lt;K,V&gt;[] 进行扩容，扩容后，容量为原来的 2 倍。 首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。 该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。 // 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。 private void rehash(HashEntry&lt;K,V> node) { HashEntry&lt;K,V>[] oldTable = table; int oldCapacity = oldTable.length; // 2 倍 int newCapacity = oldCapacity &lt;&lt; 1; threshold = (int)(newCapacity * loadFactor); // 创建新数组 HashEntry&lt;K,V>[] newTable = (HashEntry&lt;K,V>[]) new HashEntry[newCapacity]; // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’ int sizeMask = newCapacity - 1; // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置 for (int i = 0; i &lt; oldCapacity ; i++) { // e 是链表的第一个元素 HashEntry&lt;K,V> e = oldTable[i]; if (e != null) { HashEntry&lt;K,V> next = e.next; // 计算应该放置在新数组中的位置， // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19 int idx = e.hash &amp; sizeMask; if (next == null) // 该位置处只有一个元素，那比较好办 newTable[idx] = e; else { // Reuse consecutive sequence at same slot // e 是链表表头 HashEntry&lt;K,V> lastRun = e; // idx 是当前链表的头结点 e 的新位置 int lastIdx = idx; // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的 for (HashEntry&lt;K,V> last = next; last != null; last = last.next) { int k = last.hash &amp; sizeMask; if (k != lastIdx) { lastIdx = k; lastRun = last; } } // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置 newTable[lastIdx] = lastRun; // 下面的操作是处理 lastRun 之前的节点， // 这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中 for (HashEntry&lt;K,V> p = e; p != lastRun; p = p.next) { V v = p.value; int h = p.hash; int k = h &amp; sizeMask; HashEntry&lt;K,V> n = newTable[k]; newTable[k] = new HashEntry&lt;K,V>(h, p.key, v, n); } } } } // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部 int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; table = newTable; } 这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？ 仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。 我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。 get 过程分析相对于 put 来说，get 真的不要太简单。 计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽” 槽中也是一个数组，根据 hash 找到数组中具体的位置 到这里是链表了，顺着链表进行查找即可 public V get(Object key) { Segment&lt;K,V> s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V>[] tab; // 1. hash 值 int h = hash(key); long u = (((h >>> segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; // 2. 根据 hash 找到对应的 segment if ((s = (Segment&lt;K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) { // 3. 找到segment 内部数组相应位置的链表，遍历 for (HashEntry&lt;K,V> e = (HashEntry&lt;K,V>) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) { K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; } } return null; } 并发问题分析现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。 添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。 put 操作的线程安全性。 初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。 添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。 扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。 remove 操作的线程安全性。 remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。 get 操作需要遍历链表，但是 remove 操作会”破坏”链表。 如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。 如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。 Java8 HashMapJava8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。 为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 来一张图简单示意一下吧： 注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。 下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。 Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。 我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。 put 过程分析public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } // 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作 // 第四个参数 evict 我们这里不关心 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V>[] tab; Node&lt;K,V> p; int n, i; // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度 // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else {// 数组该位置有数据 Node&lt;K,V> e; K k; // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value); else { // 到这里，说明数组该位置上是一个链表 for (int binCount = 0; ; ++binCount) { // 插入到链表的最后面(Java7 是插入到链表的最前面) if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个 // 会触发下面的 treeifyBin，也就是将链表转换为红黑树 if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 如果在该链表中找到了"相等"的 key(== 或 equals) if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node break; p = e; } } // e!=null 说明存在旧值的key与要插入的key"相等" // 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值 if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容 if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } 和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。 数组扩容resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。 final Node&lt;K,V>[] resize() { Node&lt;K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 对应数组扩容 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 将数组大小扩大一倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap >= DEFAULT_INITIAL_CAPACITY) // 将阈值扩大一倍 newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr > 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候 newCap = oldThr; else {// 对应使用 new HashMap() 初始化后，第一次 put 的时候 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; // 用新的数组大小初始化新的数组 Node&lt;K,V>[] newTab = (Node&lt;K,V>[])new Node[newCap]; table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可 if (oldTab != null) { // 开始遍历原数组，进行数据迁移。 for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果是红黑树，具体我们就不展开了 else if (e instanceof TreeNode) ((TreeNode&lt;K,V>)e).split(this, newTab, j, oldCap); else { // 这块是处理链表的情况， // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序 // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的 Node&lt;K,V> loHead = null, loTail = null; Node&lt;K,V> hiHead = null, hiTail = null; Node&lt;K,V> next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; // 第一条链表 newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; // 第二条链表的新的位置是 j + oldCap，这个很好理解 newTab[j + oldCap] = hiHead; } } } } } return newTab; } get 过程分析相对于 put 来说，get 真的太简单了。 计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1) 判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步 判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步 遍历链表，直到找到相等(==或equals)的 key public V get(Object key) { Node&lt;K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&lt;K,V> getNode(int hash, Object key) { Node&lt;K,V>[] tab; Node&lt;K,V> first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) > 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 判断第一个节点是不是就是需要的 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { // 判断是否是红黑树 if (first instanceof TreeNode) return ((TreeNode&lt;K,V>)first).getTreeNode(hash, key); // 链表遍历 do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } Java8 ConcurrentHashMapJava7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。 说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。 我们先用一个示意图来描述下其结构： 结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。 初始化// 这构造函数里，什么都不干 public ConcurrentHashMap() { } public ConcurrentHashMap(int initialCapacity) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1)); this.sizeCtl = cap; } 这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。 sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。 如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。 put 过程分析仔细地一行一行代码看下去： public V put(K key, V value) { return putVal(key, value, false); } final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); // 得到 hash 值 int hash = spread(key.hashCode()); // 用于记录相应链表的长度 int binCount = 0; for (Node&lt;K,V>[] tab = table;;) { Node&lt;K,V> f; int n, i, fh; // 如果数组"空"，进行数组初始化 if (tab == null || (n = tab.length) == 0) // 初始化数组，后面会详细介绍 tab = initTable(); // 找该 hash 值对应的数组下标，得到第一个节点 f else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { // 如果数组该位置为空， // 用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了 // 如果 CAS 失败，那就是有并发操作，进到下一个循环就好了 if (casTabAt(tab, i, null, new Node&lt;K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容 else if ((fh = f.hash) == MOVED) // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了 tab = helpTransfer(tab, f); else { // 到这里就是说，f 是该位置的头结点，而且不为空 V oldVal = null; // 获取数组该位置的头结点的监视器锁 synchronized (f) { if (tabAt(tab, i) == f) { if (fh >= 0) { // 头结点的 hash 值大于 0，说明是链表 // 用于累加，记录链表的长度 binCount = 1; // 遍历链表 for (Node&lt;K,V> e = f;; ++binCount) { K ek; // 如果发现了"相等"的 key，判断是否要进行值覆盖，然后也就可以 break 了 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } // 到了链表的最末端，将这个新值放到链表的最后面 Node&lt;K,V> pred = e; if ((e = e.next) == null) { pred.next = new Node&lt;K,V>(hash, key, value, null); break; } } } else if (f instanceof TreeBin) { // 红黑树 Node&lt;K,V> p; binCount = 2; // 调用红黑树的插值方法插入新节点 if ((p = ((TreeBin&lt;K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8 if (binCount >= TREEIFY_THRESHOLD) // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换， // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树 // 具体源码我们就不看了，扩容部分后面说 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // addCount(1L, binCount); return null; } put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。 初始化数组：initTable这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。 初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。 private final Node&lt;K,V>[] initTable() { Node&lt;K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { // 初始化的"功劳"被其他线程"抢去"了 if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { try { if ((tab = table) == null || tab.length == 0) { // DEFAULT_CAPACITY 默认初始容量是 16 int n = (sc > 0) ? sc : DEFAULT_CAPACITY; // 初始化数组，长度为 16 或初始化时提供的长度 Node&lt;K,V>[] nt = (Node&lt;K,V>[])new Node&lt;?,?>[n]; // 将这个数组赋值给 table，table 是 volatile 的 table = tab = nt; // 如果 n 为 16 的话，那么这里 sc = 12 // 其实就是 0.75 * n sc = n - (n >>> 2); } } finally { // 设置 sizeCtl 为 sc，我们就当是 12 吧 sizeCtl = sc; } break; } } return tab; } 链表转红黑树: treeifyBin前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。 private final void treeifyBin(Node&lt;K,V>[] tab, int index) { Node&lt;K,V> b; int n, sc; if (tab != null) { // MIN_TREEIFY_CAPACITY 为 64 // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容 if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // 后面我们再详细分析这个方法 tryPresize(n &lt;&lt; 1); // b 是头结点 else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash >= 0) { // 加锁 synchronized (b) { if (tabAt(tab, index) == b) { // 下面就是遍历链表，建立一颗红黑树 TreeNode&lt;K,V> hd = null, tl = null; for (Node&lt;K,V> e = b; e != null; e = e.next) { TreeNode&lt;K,V> p = new TreeNode&lt;K,V>(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; } // 将红黑树设置到数组相应位置中 setTabAt(tab, index, new TreeBin&lt;K,V>(hd)); } } } } } 扩容：tryPresize如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。 这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。 这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。 // 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了 private final void tryPresize(int size) { // c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。 int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size >>> 1) + 1); int sc; while ((sc = sizeCtl) >= 0) { Node&lt;K,V>[] tab = table; int n; // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码 if (tab == null || (n = tab.length) == 0) { n = (sc > c) ? sc : c; if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { try { if (table == tab) { @SuppressWarnings("unchecked") Node&lt;K,V>[] nt = (Node&lt;K,V>[])new Node&lt;?,?>[n]; table = nt; sc = n - (n >>> 2); // 0.75 * n } } finally { sizeCtl = sc; } } } else if (c &lt;= sc || n >= MAXIMUM_CAPACITY) break; else if (tab == table) { // 我没看懂 rs 的真正含义是什么，不过也关系不大 int rs = resizeStamp(n); if (sc &lt; 0) { Node&lt;K,V>[] nt; if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法 // 此时 nextTab 不为 null if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } // 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2) // 我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数 // 调用 transfer 方法，此时 nextTab 参数为 null else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); } } } 这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。 所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。 数据迁移：transfer下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。 虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。 此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。 阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。 第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。 private final void transfer(Node&lt;K,V>[] tab, Node&lt;K,V>[] nextTab) { int n = tab.length, stride; // stride 在单核下直接等于 n，多核模式下为 (n>>>3)/NCPU，最小值是 16 // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的， // 将这 n 个任务分为多个任务包，每个任务包有 stride 个任务 if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range // 如果 nextTab 为 null，先进行一次初始化 // 前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null // 之后参与迁移的线程调用此方法时，nextTab 不会为 null if (nextTab == null) { try { // 容量翻倍 Node&lt;K,V>[] nt = (Node&lt;K,V>[])new Node&lt;?,?>[n &lt;&lt; 1]; nextTab = nt; } catch (Throwable ex) { // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; } // nextTable 是 ConcurrentHashMap 中的属性 nextTable = nextTab; // transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置 transferIndex = n; } int nextn = nextTab.length; // ForwardingNode 翻译过来就是正在被迁移的 Node // 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后， // 就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了 // 所以它其实相当于是一个标志。 ForwardingNode&lt;K,V> fwd = new ForwardingNode&lt;K,V>(nextTab); // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了 boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab /* * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看 * */ // i 是位置索引，bound 是边界，注意是从后往前 for (int i = 0, bound = 0;;) { Node&lt;K,V> f; int fh; // 下面这个 while 真的是不好理解 // advance 为 true 表示可以进行下一个位置的迁移了 // 简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride while (advance) { int nextIndex, nextBound; if (--i >= bound || finishing) advance = false; // 将 transferIndex 值赋给 nextIndex // 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了 else if ((nextIndex = transferIndex) &lt;= 0) { i = -1; advance = false; } else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex > stride ? nextIndex - stride : 0))) { // 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前 bound = nextBound; i = nextIndex - 1; advance = false; } } if (i &lt; 0 || i >= n || i + n >= nextn) { int sc; if (finishing) { // 所有的迁移操作已经完成 nextTable = null; // 将新的 nextTab 赋值给 table 属性，完成迁移 table = nextTab; // 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍 sizeCtl = (n &lt;&lt; 1) - (n >>> 1); return; } // 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2 // 然后，每有一个线程参与迁移就会将 sizeCtl 加 1， // 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) { // 任务结束，方法退出 if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; // 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT， // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了 finishing = advance = true; i = n; // recheck before commit } } // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“ else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); // 该位置处是一个 ForwardingNode，代表该位置已经迁移过了 else if ((fh = f.hash) == MOVED) advance = true; // already processed else { // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作 synchronized (f) { if (tabAt(tab, i) == f) { Node&lt;K,V> ln, hn; // 头结点的 hash 大于 0，说明是链表的 Node 节点 if (fh >= 0) { // 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的， // 需要将链表一分为二， // 找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的 // lastRun 之前的节点需要进行克隆，然后分到两个链表中 int runBit = fh &amp; n; Node&lt;K,V> lastRun = f; for (Node&lt;K,V> p = f.next; p != null; p = p.next) { int b = p.hash &amp; n; if (b != runBit) { runBit = b; lastRun = p; } } if (runBit == 0) { ln = lastRun; hn = null; } else { hn = lastRun; ln = null; } for (Node&lt;K,V> p = f; p != lastRun; p = p.next) { int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V>(ph, pk, pv, ln); else hn = new Node&lt;K,V>(ph, pk, pv, hn); } // 其中的一个链表放在新数组的位置 i setTabAt(nextTab, i, ln); // 另一个链表放在新数组的位置 i+n setTabAt(nextTab, i + n, hn); // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕， // 其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了 setTabAt(tab, i, fwd); // advance 设置为 true，代表该位置已经迁移完毕 advance = true; } else if (f instanceof TreeBin) { // 红黑树的迁移 TreeBin&lt;K,V> t = (TreeBin&lt;K,V>)f; TreeNode&lt;K,V> lo = null, loTail = null; TreeNode&lt;K,V> hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V> e = t.first; e != null; e = e.next) { int h = e.hash; TreeNode&lt;K,V> p = new TreeNode&lt;K,V> (h, e.key, e.val, null, null); if ((h &amp; n) == 0) { if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; } else { if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; } } // 如果一分为二后，节点数少于 8，那么将红黑树转换回链表 ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V>(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V>(hi) : t; // 将 ln 放置在新数组的位置 i setTabAt(nextTab, i, ln); // 将 hn 放置在新数组的位置 i+n setTabAt(nextTab, i + n, hn); // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕， // 其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了 setTabAt(tab, i, fwd); // advance 设置为 true，代表该位置已经迁移完毕 advance = true; } } } } } } 说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。 这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。 get 过程分析get 方法从来都是最简单的，这里也不例外： 计算 hash 值 根据 hash 值找到数组对应位置: (n - 1) &amp; h 根据该位置处结点性质进行相应查找 如果该位置为 null，那么直接返回 null 就可以了 如果该位置处的节点刚好就是我们需要的，返回该节点的值即可 如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法 如果以上 3 条都不满足，那就是链表，进行遍历比对即可 public V get(Object key) { Node&lt;K,V>[] tab; Node&lt;K,V> e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) > 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) { // 判断头结点是否就是我们需要的节点 if ((eh = e.hash) == h) { if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; } // 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树 else if (eh &lt; 0) // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k) return (p = e.find(h, key)) != null ? p.val : null; // 遍历链表 while ((e = e.next) != null) { if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; } } return null; } 简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。 总结其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。 看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。 我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分。 不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~ （全文完）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程面试]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[1、什么是进程、线程？ 进程：进程是系统分配资源的最小单位，电脑中运行的一个程序就是一个进程，比如QQ打开后，就会有一个进程 线程：线程是比进程更小的单位，是CPU调度的最小的单位，在一个进程中可以划分多个进程，这些进程，共享进程的堆区和方法区的共享资源，但他们都有各自的虚拟机栈，程序计数器，本地方法栈，这些线程之间的切换比进程之间的切换快很多，所以线程也叫轻量级的进程。 2、什么是线程安全和线程不安全？ 当有多个线程同时访问一个共享资源时就会出现线程安全的问题，如果同一时间只有一个线程能得到共享资源就是线程安全的，也就是其他的线程的执行不会让当前线程产生错误，比如有一个共享变量a初始值为0，有1000个线程对a进行加一操作，如果不加保护的话，结果可能会小于1000，这就是线程不安全的。 3、什么是自旋锁？ 当多个线程访问临界区是，线程这有拿到了监视器锁之后才能执行临界区的代码，但同一时间只有一个线程拿到锁，没到到锁的线程只有变为阻塞状态，自旋锁认为线程等待的时间是非常短的，所以没拿到所得时候，就执行一个循环等待，直到拿到锁，这样线程就不会进入阻塞状态，但自旋的缺点就是，在自选的过程中会消耗CPU资源，造成浪费，也有自适应的自旋锁，可以根据不同的情况来调整自旋的时间。 4、什么是Java内存模型？ Java内存模型试图屏蔽不同硬件不同操作系统内存访问的差异，以实现java在不同平台访问内存都达到同样的效果 CPU处理的速度和内存的速度是相差很大的，这样CPU就会受到内存速度的限制导致CPU利用率不高，为了解决这个问题就在CPU中加入了缓存，所以每个线程不仅有共享的主存还有自己的缓存，缓存中存放的是主存的副本，CPU操作的是cache中的副本，在适当的时间把cache中的数据写会主存。 5、什么是CAS？ CAS是指compare and swap，意识是指一个旧的预期值A,主内存的值是B，要修改的值C，当且仅当A==B的时候，A的值才会被修改成C，而且这个操作是原子性的，是一个非阻塞性的 乐观锁，比如在主存中有一个变量a = 1,线程的工作内存中有一个变量a的副本，现在线程要把a变成2，CAS就会用native本地方法比较工作内存中的值和主存中的值是否相等，如果相等则更新，防止了其他线程对数据的修改，当前线程修改了a后，其他线程工作内存中的缓存就会失效，会从新从主存中获取。 6、什么是乐观锁和悲观锁？ 乐观锁：对数据持一种乐观的态度，认为在并发过程中不会有别的线程修改当前线程用的数据，等到了真的用到数据的时候在检查数据有没有被别的线程修改过，比如CAS就是乐观锁 悲观锁：对数据持一种悲观的态度，认为别的线程会修改当前线程用的数据，所以线程会加锁，用完了在解锁，比如容synchronize 7、什么是AQS？ 8、什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？ 原子在化学中是不可再分的，一个原子操作通常包含几个操作，这几个操作都成功了这个原子操作才算成功，如果有一个失败了，其他的操作也会失败。 ❤1.基本类型 AtomicInteger：整形原子类 AtomicLong：长整型原子类 AtomicBoolean：布尔型原子类 ❤2.数组类型 AtomicIntegerArray：整形数组原子类 AtomicLongArray：长整形数组原子类 AtomicReferenceArray：引用类型数组原子类 ❤3.引用类型 AtomicReference：引用类型原子类 AtomicStampedRerence：原子更新引用类型里的字段原子 AtomicMarkableReference ：原子更新带有标记位的引用类型 ❤4.对象的属性修改类型 AtomicIntegerFieldUpdater：原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用CAS 进行原子更新时可能出现的 ABA 问题。 9、什么是Executors框架？ 10、什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？ &nbsp; &nbsp;BlockingQueue有两种实现方式 FIFO队列：LinkBlockingQueue,ArrayBlockingQueue（固定长度） 优先级队列：PriorityBlockingQueue BlockingQueue提供了take()和put()方法，当队列中是空的时候，take会阻塞知道队列中有东西，当队列满了以后，put()方法会阻塞，等到队列有位置后才可以入队 &nbsp; &nbsp;BlockingQueue 实现生产者消费者问题 public class ProducerConsumer { private static BlockingQueue&lt;String> queue = new ArrayBlockingQueue&lt;>(5); private static class Producer extends Thread { @Override public void run() { try { queue.put("product"); } catch (InterruptedException e) { e.printStackTrace(); } System.out.print("produce.."); } } private static class Consumer extends Thread { @Override public void run() { try { String product = queue.take(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.print("consume.."); } } } public static void main(String[] args) { for (int i = 0; i &lt; 2; i++) { Producer producer = new Producer(); producer.start(); } for (int i = 0; i &lt; 5; i++) { Consumer consumer = new Consumer(); consumer.start(); } for (int i = 0; i &lt; 3; i++) { Producer producer = new Producer(); producer.start(); } } produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.. 11、什么是Callable和Future? 在jdk1.5之前，如果需要获取子线程执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦，在1.5之后提供了Callable和Future接口，用他们可以方便的获得线程的返回值，首先创建一个实现了Callable接口的类，然后创建一个FutureTask，把Callable当做参数，然后创建一个Thread来驱动FutureTask，可以用FutureTask的get方法获取返回值 12、什么是FutureTask? FutureTask实现了RunableFuture接口，RunableFuture接口有继承了Future可Runable接口，通过FutureTask可以获得Callable的返回值 13、什么是同步容器和并发容器的实现？ 同步容器：同步容器可以简单的理解为加了synchronize锁的容器，比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。这些容器为了线程安全都加了synchronize锁，但这些容器几乎没有用，因为在并发中效率太低了 并发容器：并发容器采用了一种颗粒更细的加锁方式，可以称为分段加锁，比如ConcurrentHashMap，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。14、什么是多线程？优缺点？ 多线程就是多个线程并发执行，一个进程要完成一个任务，把这个任务划分成更小的任务分给每一个线程，这几个线程并发执行，就是多线程 ❤优点： 从计算机底层来说：线程可以看作是轻量级的进程，是CPU调度的最小的单位，线程之间的切换要比进程之间切换快的多，另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。 从当代的互联网来说：现在的系统动不动就要求千万级的并发，而多线程并发编程是并发系统的基础，利用好多线程可以大大提高系统的并发量 可以提高CPU的利用率：在单核时代，要先进行IO然后再进行计算，这样二者的利用率只有50%，多线程可以在CPU计算的时候进行IO操作这样CPU的利用率就提高了，在多核时代，假如有一个任务，把这个任务分配给不同的线程，这些线程在不同的CPU中跑，可以让每一个CPU充分利用。 ❤缺点： 并发编程的目的是提高程序的执行效率提高程序执行的速度，但也存在很多问题比如上下文之间的切换问题，死锁问题，以及受限于软件和硬件资源的问题。 15、什么是多线程的上下文切换？ 并发执行的每个线程都会分一个时间片，当线程的执行时间到了，就会让出CPU给别的线程执行，线程保存当前执行的状态，到下一个线程执行的过程就是上下文切换。上下文切换是非常频繁的，一秒钟要切换上百次，每一次切换都是纳秒级别的，所以上下文切换是非常消耗CPU的，有可能是操作系统消耗最大的操作，linux比其他系统有很多优点，其中一个就是上下文切换的速度很快。 16、ThreadLocal的设计理念与作用？ 在并发编程中每一个线程都可以使用共享资源，所以我们要对这些共享资源做同步，但做同步会涉及到很多问题，所以为什么不让每个线程都拥有这个共享资源的副本呢，那每个线程对副本进行修改，就互不干扰了，所以ThreadLocal就是解决这个问题的，ThreadLocal可以绑定每个线程的数据，当线程访问该变量的时候就会拿到当前线程的变量。 ❤原理：在ThreadLocal类中有一个Map，Map以线程为Key值，所以线程可以拿到当前线程绑定的数据。 ❤存在的问题：Map中的key值是threadlocald的弱引用，当没有被外部强引用的时候会被清理，但value是强引用不会被清理，所以就存在Key为null的值，这样就会造成内存泄漏，但ThreadLocalMap已经解决了这个问题，在每次get()和set()的时候都会清理key为null的值 ❤应用举例：在数据库额连接池中要保证每个线程都拥有自己的connection，不然事务就会出现混乱，所以就可以把每个线程的connection绑定到当前前程中去，就可以保证同一个线程用同一个连接 17、ThreadPool（线程池）用法与优势？ 降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 18、Concurrent包里的其他东西 ArrayBlockingQueue、CountDownLatch等等。 19、synchronized和ReentrantLock的区别？ 都是可重入锁 synchronized是基于jvm层面的ReentrantLock是基于jdk层面的 ReentrantLock比synchronized的功能更多：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件） 20、Semaphore有什么作用？ Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。 public class SemaphoreExample { public static void main(String[] args) { final int clientCount = 3; final int totalRequestCount = 10; Semaphore semaphore = new Semaphore(clientCount); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalRequestCount; i++) { executorService.execute(()->{ try { semaphore.acquire(); System.out.print(semaphore.availablePermits() + " "); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } }); } executorService.shutdown(); } } before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after.. 21、Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有 可以使锁更公平 可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁 整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。 22、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？ 23、ConcurrentHashMap的并发度是什么？ 24、ReentrantReadWriteLock读写锁的使用？ 25、CyclicBarrier和CountDownLatch的用法及区别？ 26、LockSupport工具？ 27、Condition接口及其实现原理？ 28、Fork/Join框架的理解? 29、wait()和sleep()的区别? wait()和sleep()都可以暂定现在的进程，但是wait()会释放当前的锁，但sleep不会释放锁，sleep在时间到了以后会自己苏醒，继续执行，而wait需要别的线程调用他的notify()或者notifyAll()方法。 30、线程的五个状态（五种状态，创建、就绪、运行、阻塞和死亡）? 当线程创建完成以后就是New（新建）状态，当调用star()之后就成为Runnable可运行状态，可运行状态其实包含就绪状态和运行状态，当线程得到时间片后就成为运状态，当线程没有获得排它锁的时候就会变成阻塞状态，调用了wait()，方法后就会成为waiting状态。 31、start()方法和run()方法的区别？ 当创建了一个线程后，线程就会进入新建状态，当调用star()后就会进入就绪状态，一旦获得时间片后就会进入运行状态，会自动的执行线程中的run()方法，调用start（）方法会启动一个线程，和当前线程是异步的，而调用run()方法只是调用了线程中的一个普通方法，和调用普通类的方法没什么区别，没有启动线程，和当前的线程是同步执行的。 32、Runnable接口和Callable接口的区别？ 实现了Runnable和Callable接口的类只是一个任务，并不能算是一个线程，需要通过Thread来调用，可以说任务是通过线程驱动而执行的。二者的区别就是Callable接口可以有返回值，返回值通过 FutureTask 进行封装。 public class MyCallable implements Callable&lt;Integer> { public Integer call() { return 123; } } public static void main(String[] args) throws ExecutionException, InterruptedException { MyCallable mc = new MyCallable(); FutureTask&lt;Integer> ft = new FutureTask&lt;>(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get()); } 33、volatile关键字的作用？ volatile关键字可以实现多线程之间数据的可见性，但并不能保证在多线程下是线程安全的，而且可以防止指令重排 ❤原理： 由于CPU和内存之间速度相差很大，这样会导致CPU的利用率不高，所以在CPU中加了缓存，这样就可以解决这个问题，java内存模型中每次不是从主存中取数据，而是从每个线程自己的工作内存中取数据，但是这样就会造成一个问题就是在多线程中会出现缓存不一致的问题，比如有一个变量a在主存中的初始值是1，每个线程的工作内存中都有一个a的副本，当一个线程修改了a的值，这时候a变成了0，但是其他线程并不知道，其他线程自己的工作内存中还是原来的旧值，当加了volatile关键字后，就要遵循操作系统的缓存一致协议，当前线程修改了之后，会被强制刷回主存，每一个线程就会在总线上嗅探是否有值改变了，如果发现主存中的值变了，那工作内存中的值就会失效，也就是，当前线程对值的修改对其他线程是可见的。 虽然可以实现数据的可见性，但并不能保证原子性，所以在多线程下并不能保证是线程安全的 34、Java中如何获取到线程dump文件？ 35、线程和进程有什么区别？ 线程是资源分配的最小单位，进程是CPU调度的最小单位 线程之间的切换比进程之间的切换快很多，线程可以看成是轻量级的进程 进程之间是独立的，线程之间是相互联系的，线程之间共享进程的共享资源 36、线程实现的方式有几种（四种）？ 继承Thread类 实现Runnable接口 实现Callable接口 4.使用线程池（有返回值 37、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？ 38、如果你提交任务时，线程池队列已满，这时会发生什么？ 39、锁的等级：方法锁、对象锁、类锁? 40、如果同步块内的线程抛出异常会发生什么？ 41、并发编程（concurrency）并行编程（parallellism）有什么区别？ 42、如何保证多线程下 i++ 结果正确？ ❤1. 可以用synchronize关键字 ❤ 2. 用CAS+volatile 43、一个线程如果出现了运行时异常会怎么样? 44、如何在两个线程之间共享数据? 45、生产者消费者模型的作用是什么? 46、怎么唤醒一个阻塞的线程? 47、Java中用到的线程调度算法是什么 48、单例模式的线程安全性?public class Singleton { private volatile static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) { //类对象加锁 synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } 49、线程类的构造方法、静态块是被哪个线程调用的? 50、同步方法和同步块，哪个是更好的选择? 应该尽量使用同步块而不是同步方法，这样可以缩小同步范围，从而减少锁争用 51、如何检测死锁？怎么预防死锁？&nbsp;&nbsp;死锁满足的条件 互斥资源 不可剥夺 请求保持 环路等待]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器常用的操作]]></title>
    <url>%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[Linux的命令行界面下面有非常多的文本编辑器。比如经常听说的就有Emacs、pico、nano、joe与vim等。vim也是许多linux自带的编辑器，想要玩好linux，vim一定是要熟练使用的，利用好vim会让我们事半功倍 vi的基本使用方法及其相关命令vim编辑器的三种模式：一般模式、编辑模式和命令行模式。 在一般模式中可以进行删除、复制和粘贴的功能，但是无法编辑文件内容。从一般模式切换到编辑模式可以按下i、I、o、O、a、A、r、R键。按下Esc键可以回到一般模式。在一般模式中输入：、/、？三个中的任意一个可以将光标移到最下面的一行。在这个模式中可以提供查找数据的操作，而读取、保存、大量替换字符、离开vii、显示行号等操作则是在此模式中完成的。需要注意的是，编辑模式与命令行模式之间是不能互相切换的。 下面列出平时用的最多的vi命令： 移动光标的方法 [Ctrl]+[f]：屏幕向下移动一页，相当于[PageDown]按键。 [Ctrl]+[b]：屏幕向上移动一页，相当于[PageUp]按键。 0或功能键[Home]：移动到这一行的最前面字符处。 $或功能键[End]：移动到这一行的最后面字符处。 G：移动到这个文件的最后一行。 gg：移动到这个文件的第一行，相当于1G. N[Enter]：N为数字，光标向下移动N行。 查找和替换 /word：向下寻找一个名称为word的字符串。 ?word：向上寻找一个名称为word的字符串。 :n1,n2s/word1/word2/g：在第n1行和n2行之间寻找word1这个字符串，并且将其替换为word2. :1,$s/word1/word2/g：从第一行到最后一行寻找word1这个字符串，并且将其替换为word2. :1,$s/word1/word2/gc：从第一行到最后一行寻找word1这个字符串，并且将其替换为word2.且在替换前显示提示字符给用户确认是否需要替换。 删除、复制和粘贴 x,X：在一行字中，x为向后删除一个字符（相当于[Del]键），X为向前删除一个字符（相当于[Backspace]）。 dd：删除光标所在的一整行。 ndd：删除光标所在的向下n行。 yy：复制光标所在的一行。 nyy：复制光标所在的向下n行。 p,P：p为将已复制的内容在光标的下一行粘贴，P则为粘贴在光标的上一行。 u：复原前一个操作。 [Ctrl]+r：重做上一个操作。 块选择这个功能可以让我们复制一个矩形区域的内容，十分方便 v:字符选择，会将光标经过的地方反白选择；V:行选择；Ctrl+v：块选择；y：复制反白的地方；d：删除反白的地方。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统高频面试总结]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[操作系统是编程最重要的基础之一，操作系统相关知识广泛应用在程序设计、系统调优、问题追查、性能优化等重要场景中，一个不懂操作系统的程序员不可能写出优秀的代码，更不可能设计出优秀的系统架构，所以操作系统知识也是面试中不可或缺的一部分，尤其对于基础组件开发、系统调优等相关职位。 1.进程和线程的区别&nbsp; &nbsp; &nbsp;1.进程是资源分配的最小单位，线程是程序执行的最小单位。&nbsp; &nbsp; &nbsp;2.进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。&nbsp; &nbsp; &nbsp;3.线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。&nbsp; &nbsp; &nbsp;4.多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。2.进程通信&nbsp; &nbsp; &nbsp;1.管道：速度慢，容量有限，只有父子进程能通讯 。&nbsp; &nbsp; &nbsp;2.FIFO：任何进程间都能通讯，但速度慢 。&nbsp; &nbsp; &nbsp;3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。&nbsp; &nbsp; &nbsp;4.信号量：不能传递复杂消息，只能用来同步。&nbsp; &nbsp; &nbsp;5.共享内存区：能够很容易控制容量，速度快，但要保持同步。&nbsp; &nbsp; &nbsp;6.SOCKET3.进程同步&nbsp; &nbsp; &nbsp;多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性。&nbsp; &nbsp;同步机制需要遵循的原则：&nbsp; &nbsp; &nbsp;空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请&nbsp; &nbsp; &nbsp;忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问&nbsp; &nbsp; &nbsp;有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等&nbsp; &nbsp; &nbsp;让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等4.操作系统的四个特性&nbsp; &nbsp; &nbsp;1.并发：同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件)。&nbsp; &nbsp; &nbsp;2.共享：系统中的资源可以被内存中多个并发执行的进线程共同使用。&nbsp; &nbsp; &nbsp;3.虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个。&nbsp; &nbsp; &nbsp;4.异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进。5.死锁&nbsp; &nbsp; &nbsp;死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。&nbsp; &nbsp;死锁原因：&nbsp; &nbsp; &nbsp;1.竞争资源：请求同一有限资源的进程数多于可用资源数&nbsp; &nbsp; &nbsp;2.进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链&nbsp; &nbsp;死锁产生的必要条件：&nbsp; &nbsp; &nbsp;1.互斥条件:进程对所分配的资源进行排他性的使用&nbsp; &nbsp; &nbsp;2.请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源&nbsp; &nbsp; &nbsp;3.不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺&nbsp; &nbsp; &nbsp;4.循环等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链6.死锁和活锁的区别&nbsp; &nbsp; &nbsp;活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。&nbsp; &nbsp; &nbsp;一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。&nbsp; &nbsp; &nbsp;简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。7.进程调度算法&nbsp; &nbsp; &nbsp;1.FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU。&nbsp; &nbsp; &nbsp;2.SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度。&nbsp; &nbsp; &nbsp;3.优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化。&nbsp; &nbsp; &nbsp;4.时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。&nbsp; &nbsp; &nbsp;5.多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。&nbsp; &nbsp; &nbsp;6.多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。8.页面置换算法&nbsp; &nbsp; &nbsp;FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）。&nbsp; &nbsp; &nbsp;LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断。&nbsp; &nbsp; &nbsp;LFU（Least frequently use）最少使用次数算法：根据使用次数来判断。&nbsp; &nbsp; &nbsp;OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。9.虚拟内存&nbsp; &nbsp; &nbsp;如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以从逻辑的角度扩充内存容量，即可解决上述两种问题。&nbsp; &nbsp; &nbsp;基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。10.什么是临界区？如何解决冲突？&nbsp; &nbsp; &nbsp;每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。&nbsp; &nbsp; &nbsp;1.如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；&nbsp; &nbsp; &nbsp;2.任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；&nbsp; &nbsp; &nbsp;3.进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；&nbsp; &nbsp; &nbsp;4.如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。11.分段和分页的区别&nbsp; &nbsp; &nbsp;页是信息的物理单位；分页仅仅是由于系统管理的需要，而不是用户的需要。&nbsp; &nbsp; &nbsp;段是信息的逻辑单位；分段的目的是为了能更好地满足用户的需要。&nbsp; &nbsp; &nbsp;页的大小固定且由系统确定；段的长度却不固定，决定于用户所编写的程序。12.对称加密与非对称加密&nbsp; &nbsp; &nbsp;对称加密：加密和解密用的是同一个密钥, 加密方法有AES,DES,RC4,BlowFish等。&nbsp; &nbsp; &nbsp;非对称加密：在加密和解密时, 用的是不同的密钥, 分别称为公钥或私钥. 非对称加密的加密方法有RSA, DSA等。&nbsp; &nbsp; &nbsp;证书：证书则用来证明自己的身份. 一般来说,证书中包含自己的公钥以及额外的信息,如签发机构(CA)和有效时间等。13.计算机为什么用补码&nbsp; &nbsp; &nbsp;1. 使符号位能与有效值部分一起参加运算,从而简化运算规则。&nbsp; &nbsp; &nbsp;2. 使减法运算转换为加法运算。14.计算机的存储结构&nbsp; &nbsp; &nbsp;1. 寄存器：用来暂存指令、数据和地址。加快直接同内存读取指令和读写数据的速度。&nbsp; &nbsp; &nbsp;2. 高速缓冲存储器：CPU向内存读取数据时，首先查询缓存区是否有对应数据，如果有则直接读取，没有再从内存中读取。高速缓存中存储的都是内存中的数据。&nbsp; &nbsp; &nbsp;3. 内存：用于存储指令，运行中的各个静态，动态，临时变量，外部文件的指针。&nbsp; &nbsp; &nbsp;4. 硬盘：存储需要永久存储的文件。&nbsp; &nbsp; &nbsp;5. 其他存储器(光盘，U盘)。15.虚拟内存和物理内存的区别&nbsp; &nbsp; &nbsp;虚拟内存(硬盘)是进程运行时所有内存空间的总和，并且可能有一部分不在物理内存中。&nbsp; &nbsp; &nbsp;物理内存(内存条)就是我们平时所了解的内存条。&nbsp; &nbsp; &nbsp;当运行程序过多，物理内存不够用时，系统会将一部分硬盘空间当内存使用，这部分空间就是虚拟内存。16.物理地址和虚拟地址&nbsp; &nbsp; &nbsp;物理地址：CPU地址总线传来的地址。&nbsp; &nbsp; &nbsp;虚拟地址：从CPU到MMU（Memory Management Unit）的地址称为虚拟地址。17.孤儿进程和僵尸进程&nbsp; &nbsp; &nbsp;孤儿进程：父进程先退出,子进程还没退出，那么子进程将被托孤给init进程,这里子进程的父进程就是init进程(1号进程)。&nbsp; &nbsp; &nbsp;僵尸进程：一个进程已经终止了,但是其父进程还没有获取其状态,那么这个进程就称之为僵尸进程。18.进程地址空间&nbsp; &nbsp; &nbsp;text数据段（代码段）、data数据段(初始化数据)、BSS数据段(未初始化数据)、堆、栈和内存映射。19.mmap内存映射原理&nbsp; &nbsp; &nbsp;1. 进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域（调用用户空间库函数mmap）。&nbsp; &nbsp; &nbsp;2. 调用内核空间的系统调用函数mmap，实现文件物理地址和进程虚拟地址的——映射关系。&nbsp; &nbsp; &nbsp;3. 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。&nbsp; &nbsp;注意：&nbsp; &nbsp; &nbsp;1. 前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。&nbsp; &nbsp; &nbsp;2. 修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。20.mmap和普通文件操作的区别&nbsp; &nbsp; &nbsp;常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。21.操作系统创建一个新进程的主要步骤&nbsp; &nbsp; &nbsp;1. 申请空白PCB（进程控制块）。&nbsp; &nbsp; &nbsp;2. 为新进程分派资源。&nbsp; &nbsp; &nbsp;3. 初始化PCB。&nbsp; &nbsp; &nbsp;4. 将新进程插入就绪队列。22.加粗样式多线程上下文切换&nbsp; &nbsp; &nbsp;CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，从任务保存到再加载的过程就是一次上下文切换。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jvm 知识点总览]]></title>
    <url>%2FJvm%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E8%A7%88.html</url>
    <content type="text"><![CDATA[本文主要对Jvm的知识的做一个简单的梳理0.jvm 总体梳理jvm体系总体分四大块： 类的加载机制 jvm内存结构 GC算法 垃圾回收 GC分析 命令调优1.类的加载机制主要关注点： 什么是类的加载 类的生命周期 类加载器 双亲委派模型什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。类的生命周期类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图； 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用 初始化，为类的静态变量赋予正确的初始值 使用，new出对象程序中使用 卸载，执行垃圾回收 几个小问题？ 1、JVM初始化步骤 ？ 2、类初始化时机 ？3、哪几种情况下，Java虚拟机将结束生命周期？ 答案参考这篇文章Jvm 系列(一):Java 类的加载机制类加载器 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器类加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效2.jvm内存结构主要关注点： jvm内存结构都是什么 对象分配规则jvm内存结构 方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。 Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。 JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。对象分配规则 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor&nbsp;GC。 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor&nbsp;GC那么对象会进入Survivor区，之后每经过一次Minor&nbsp;GC那么对象的年龄加1，知道达到阀值对象进入老年区。 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。 空间分配担保。每次进行Minor&nbsp;GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full&nbsp;GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor&nbsp;GC,如果false则进行Full&nbsp;GC。&nbsp; 如何通过参数来控制个各个内存区域参考此文章：Jvm 系列(二):Jvm 内存结构3.GC算法 垃圾回收主要关注点： 对象存活判断 GC算法 垃圾回收器对象存活判断判断对象是否存活一般有两种方式： 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。GC算法GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。垃圾回收器 Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。 ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。 Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。 Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法 CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。 G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征 GC算法和垃圾回收器算法图解以及更详细内容参考 Jvm 系列(三):GC 算法 垃圾收集器4.GC分析 命令调优主要关注点： GC日志分析 调优命令 调优工具GC日志分析摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs] 通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数 Young GC日志: Full GC日志: 调优命令 Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jmap，JVM Memory Map命令用于生成heap dump文件 jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 jstack，用于生成java虚拟机当前时刻的线程快照。 jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。 详细的命令使用参考这里Jvm 系列(四):Jvm 调优-命令篇 调优工具 常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。 jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 GChisto，一款专业分析gc日志的工具 工具使用参考 Jvm 系列(七):Jvm 调优-工具篇]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat安装SSL安全证书]]></title>
    <url>%2Ftomcat%E5%AE%89%E8%A3%85SSL%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6.html</url>
    <content type="text"><![CDATA[首先，不知道你有没有发现，有时你在浏览器访问一个网址时，例如（www.hzelin.top）,你会发现网址左边是个 X不安全（表示该链接不安全，使用的是http未加密协议），而有时你访问一个网址的时候发现地址左边是https://（表示该链接是安全的，使用https加密协议，特别是做小程序的，一定需要https访问的），那这个是怎么实现的呢？ SSL证书安装 —-各版本tomcat安装安全证书]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的InnoDB索引原理详解]]></title>
    <url>%2FMySQL%E7%9A%84InnoDB%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[摘要： 本篇介绍下Mysql的InnoDB索引相关知识，从各种树到索引原理到存储的细节。 InnoDB是Mysql的默认存储引擎(Mysql5.5.5之前是MyISAM，文档)。本着高效学习的目的，本篇以介绍InnoDB为主，少量涉及MyISAM作为对比。 这篇文章是我在学习过程中总结完成的，内容主要来自书本和博客(参考文献会给出)，过程中加入了一些自己的理解，描述不准确的地方烦请指出。 1 各种树形结构 本来不打算从二叉搜索树开始，因为网上已经有太多相关文章，但是考虑到清晰的图示对理解问题有很大帮助，也为了保证文章完整性，最后还是加上了这部分。 先看看几种树形结构： 1 搜索二叉树：每个节点有两个子节点，数据量的增大必然导致高度的快速增加，显然这个不适合作为大量数据存储的基础结构。 2 B树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；一个节点的子节点数量会比关键字个数多1，这样关键字就变成了子节点的分割标志。一般会在图示中把关键字画到子节点中间，非常形象，也容易和后面的B+树区分。由于数据同时存在于叶子节点和非叶子结点中，无法简单完成按顺序遍历B树中的关键字，必须用中序遍历的方法。 3 B+树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m；子树的个数最多可以与关键字一样多。非叶节点存储的是子树里最小的关键字。同时数据节点只存在于叶子节点中，且叶子节点间增加了横向的指针，这样顺序遍历所有数据将变得非常容易。 4 B树：一棵m阶B树是一棵平衡的m路搜索树。最重要的两个性质是1每个非根节点所包含的关键字个数 j 满足：┌m2/3┐ - 1 &lt;= j &lt;= m；2非叶节点间添加了横向指针。 B/B+/B三种树有相似的操作，比如检索/插入/删除节点。这里只重点关注插入节点的情况，且只分析他们在当前节点已满情况下的插入操作，因为这个动作稍微复杂且能充分体现几种树的差异。与之对比的是检索节点比较容易实现，而删除节点只要完成与插入相反的过程即可（在实际应用中删除并不是插入的完全逆操作，往往只删除数据而保留下空间为后续使用）。 先看B树的分裂，下图的红色值即为每次新插入的节点。每当一个节点满后，就需要发生分裂（分裂是一个递归过程，参考下面7的插入导致了两层分裂），由于B树的非叶子节点同样保存了键值，所以已满节点分裂后的值将分布在三个地方：1原节点，2原节点的父节点，3原节点的新建兄弟节点（参考5，7的插入过程）。分裂有可能导致树的高度增加（参考3，7的插入过程），也可能不影响树的高度（参考5，6的插入过程）。 B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟节点的指针。 B树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）。如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。可以看到B树的分裂非常巧妙，因为B树要保证分裂后的节点还要2/3满，如果采用B+树的方法，只是简单的将已满的节点一分为二，会导致每个节点只有1/2满，这不满足B树的要求了。所以B树采取的策略是在本节点满后，继续插入兄弟节点（这也是为什么B树需要在非叶子节点加一个兄弟间的链表），直到把兄弟节点也塞满，然后拉上兄弟节点一起凑份子，自己和兄弟节点各出资1/3成立新节点，这样的结果是3个节点刚好是2/3满，达到B树的要求，皆大欢喜。 B+树适合作为数据库的基础结构，完全是因为计算机的内存-机械硬盘两层存储结构。内存可以完成快速的随机访问（随机访问即给出任意一个地址，要求返回这个地址存储的数据）但是容量较小。而硬盘的随机访问要经过机械动作（1磁头移动 2盘片转动），访问效率比内存低几个数量级，但是硬盘容量较大。典型的数据库容量大大超过可用内存大小，这就决定了在B+树中检索一条数据很可能要借助几次磁盘IO操作来完成。如下图所示：通常向下读取一个节点的动作可能会是一次磁盘IO操作，不过非叶节点通常会在初始阶段载入内存以加快访问速度。同时为提高在节点间横向遍历速度，真实数据库中可能会将图中蓝色的CPU计算/内存读取优化成二叉搜索树（InnoDB中的page directory机制）。 真实数据库中的B+树应该是非常扁平的，可以通过向表中顺序插入足够数据的方式来验证InnoDB中的B+树到底有多扁平。我们通过如下图的CREATE语句建立一个只有简单字段的测试表，然后不断添加数据来填充这个表。通过下图的统计数据（来源见参考文献1）可以分析出几个直观的结论，这几个结论宏观的展现了数据库里B+树的尺度。 1 每个叶子节点存储了468行数据，每个非叶子节点存储了大约1200个键值，这是一棵平衡的1200路搜索树！ 2 对于一个22.1G容量的表，也只需要高度为3的B+树就能存储了，这个容量大概能满足很多应用的需要了。如果把高度增大到4，则B+树的存储容量立刻增大到25.9T之巨！ 3 对于一个22.1G容量的表，B+树的高度是3，如果要把非叶节点全部加载到内存也只需要少于18.8M的内存（如何得出的这个结论？因为对于高度为2的树，1203个叶子节点也只需要18.8M空间，而22.1G从良表的高度是3，非叶节点1204个。同时我们假设叶子节点的尺寸是大于非叶节点的，因为叶子节点存储了行数据而非叶节点只有键和少量数据。），只使用如此少的内存就可以保证只需要一次磁盘IO操作就检索出所需的数据，效率是非常之高的。 2 Mysql的存储引擎和索引 可以说数据库必须有索引，没有索引则检索过程变成了顺序查找，O(n)的时间复杂度几乎是不能忍受的。我们非常容易想象出一个只有单关键字组成的表如何使用B+树进行索引，只要将关键字存储到树的节点即可。当数据库一条记录里包含多个字段时，一棵B+树就只能存储主键，如果检索的是非主键字段，则主键索引失去作用，又变成顺序查找了。这时应该在第二个要检索的列上建立第二套索引。 &nbsp;这个索引由独立的B+树来组织。有两种常见的方法可以解决多个B+树访问同一套表数据的问题，一种叫做聚簇索引（clustered index&nbsp;），一种叫做非聚簇索引（secondary index）。这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种数据存储方式。对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。对于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。 InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。 MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。 为了更形象说明这两种索引的区别，我们假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。 我们重点关注聚簇索引，看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？ 1 由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。 2 辅助索引使用主键作为”指针” 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”。也就是说行的位置（实现中通过16K的Page来定位，后面会涉及）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。 3 Page结构 如果说前面的内容偏向于解释原理，那后面就开始涉及具体实现了。 理解InnoDB的实现不得不提Page结构，Page是整个InnoDB存储的最基本构件，也是InnoDB磁盘管理的最小单位，与数据库相关的所有内容都存储在这种Page结构里。Page分为几种类型，常见的页类型有数据页（B-tree Node）Undo页（Undo Log Page）系统页（System Page） 事务数据页（Transaction System Page）等。单个Page的大小是16K（编译宏UNIV_PAGE_SIZE控制），每个Page使用一个32位的int值来唯一标识，这也正好对应InnoDB最大64TB的存储容量（16Kib 2^32 = 64Tib）。一个Page的基本结构如下图所示： 每个Page都有通用的头和尾，但是中部的内容根据Page的类型不同而发生变化。Page的头部里有我们关心的一些数据，下图把Page的头部详细信息显示出来：&nbsp; 我们重点关注和数据组织结构相关的字段：Page的头部保存了两个指针，分别指向前一个Page和后一个Page，头部还有Page的类型信息和用来唯一标识Page的编号。根据这两个指针我们很容易想象出Page链接起来就是一个双向链表的结构。 再看看Page的主体内容，我们主要关注行数据和索引的存储，他们都位于Page的User Records部分，User Records占据Page的大部分空间，User Records由一条一条的Record组成，每条记录代表索引树上的一个节点（非叶子节点和叶子节点）。在一个Page内部，单链表的头尾由固定内容的两条记录来表示，字符串形式的”Infimum”代表开头，”Supremum”代表结尾。这两个用来代表开头结尾的Record存储在System Records的段里，这个System Records和User Records是两个平行的段。InnoDB存在4种不同的Record，它们分别是1主键索引树非叶节点 2主键索引树叶子节点 3辅助键索引树非叶节点 4辅助键索引树叶子节点。这4种节点的Record格式有一些差异，但是它们都存储着Next指针指向下一个Record。后续我们会详细介绍这4种节点，现在只需要把Record当成一个存储了数据同时含有Next指针的单链表节点即可。 User Record在Page内以单链表的形式存在，最初数据是按照插入的先后顺序排列的，但是随着新数据的插入和旧数据的删除，数据物理顺序会变得混乱，但他们依然保持着逻辑上的先后顺序。 把User Record的组织形式和若干Page组合起来，就看到了稍微完整的形式。 现在看下如何定位一个Record： 1 通过根节点开始遍历一个索引的B+树，通过各层非叶子节点最终到达一个Page，这个Page里存放的都是叶子节点。 2 在Page内从”Infimum”节点开始遍历单链表（这种遍历往往会被优化），如果找到该键则成功返回。如果记录到达了”supremum”，说明当前Page里没有合适的键，这时要借助Page的Next Page指针，跳转到下一个Page继续从”Infimum”开始逐个查找。 详细看下不同类型的Record里到底存储了什么数据，根据B+树节点的不同，User Record可以被分成四种格式，下图种按照颜色予以区分。 1 主索引树非叶节点（绿色） 1 子节点存储的主键里最小的值（Min Cluster Key on Child），这是B+树必须的，作用是在一个Page里定位到具体的记录的位置。 2 最小的值所在的Page的编号（Child Page Number），作用是定位Record。 2 主索引树叶子节点（黄色） 1 主键（Cluster Key Fields），B+树必须的，也是数据行的一部分 2 除去主键以外的所有列（Non-Key Fields），这是数据行的除去主键的其他所有列的集合。 这里的1和2两部分加起来就是一个完整的数据行。 3 辅助索引树非叶节点非（蓝色） 1 子节点里存储的辅助键值里的最小的值（Min Secondary-Key on Child），这是B+树必须的，作用是在一个Page里定位到具体的记录的位置。 2 主键值（Cluster Key Fields），非叶子节点为什么要存储主键呢？因为辅助索引是可以不唯一的，但是B+树要求键的值必须唯一，所以这里把辅助键的值和主键的值合并起来作为在B+树中的真正键值，保证了唯一性。但是这也导致在辅助索引B+树中非叶节点反而比叶子节点多了4个字节。（即下图中蓝色节点反而比红色多了4字节） 3 最小的值所在的Page的编号（Child Page Number），作用是定位Record。 4 辅助索引树叶子节点（红色） 1 辅助索引键值（Secondary Key Fields），这是B+树必须的。 2 主键值（Cluster Key Fields），用来在主索引树里再做一次B+树检索来找到整条记录。 下面是本篇最重要的部分了，结合B+树的结构和前面介绍的4种Record的内容，我们终于可以画出一幅全景图。由于辅助索引的B+树与主键索引有相似的结构，这里只画出了主键索引树的结构图，只包含了”主键非叶节点”和”主键叶子节点”两种节点，也就是上图的的绿色和黄色的部分。 把上图还原成下面这个更简洁的树形示意图，这就是B+树的一部分。注意Page和B+树节点之间并没有一一对应的关系，Page只是作为一个Record的保存容器，它存在的目的是便于对磁盘空间进行批量管理，上图中的编号为47的Page在树形结构上就被拆分成了两个独立节点。 至此本篇就算结束了，本篇只是对InnoDB索引相关的数据结构和实现进行了一些梳理总结，并未涉及到Mysql的实战经验。这主要是基于几点原因： 1 原理是基石，只有充分了解InnoDB索引的工作方式，我们才有能力高效的使用好它。 2 原理性知识特别适合使用图示，我个人非常喜欢这种表达方式。 3 关于InnoDB优化，在《高性能Mysql》里有更加全面的介绍，对优化Mysql感兴趣的同学完全可以自己获取相关知识，我自己的积累还未达到能分享这些内容的地步。 另：对InnoDB实现有更多兴趣的同学可以看看Jeremy Cole的博客（参考文献三篇文章的来源），这位老兄曾先后在Mysql，Yahoo，Twitter，Google从事数据库相关工作，他的文章非常棒！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql数据库知识点总结02-索引]]></title>
    <url>%2FMySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9302-%E7%B4%A2%E5%BC%95.html</url>
    <content type="text"><![CDATA[数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。 索引是什么？&nbsp; &nbsp; &nbsp;数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。 索引原理&nbsp; &nbsp; &nbsp;索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等。磁盘IO与预读&nbsp; &nbsp; &nbsp;考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。索引的两大类型Hash索引和B树索引&nbsp; &nbsp; &nbsp;Hash类型的索引：查询单条快，范围查询慢。&nbsp; &nbsp; &nbsp;B树类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）。&nbsp; 不同的存储引擎支持的索引类型也不一样&nbsp; &nbsp; &nbsp;InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引。&nbsp; &nbsp; &nbsp;MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引。&nbsp; &nbsp; &nbsp;Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引。Hash索引的限制&nbsp; &nbsp; &nbsp;1.由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。&nbsp; &nbsp; &nbsp;2.不能使用hash索引排序。&nbsp; &nbsp; &nbsp;3.Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。&nbsp; &nbsp; &nbsp;4.Hash索引只支持等值比较，例如使用=，IN( )和&lt;=&gt;。对于WHERE price&gt;100并不能加速查询。索引数据结构为什么采用B+树&nbsp; &nbsp; &nbsp;为了尽量减少I/O操作，磁盘读取每次都会预读，大小通常为页的整数倍。即使只需要读取一个字节，磁盘也会读取一页的数据(通常为4K)放入内存，内存与磁盘以页为单位交换数据。因为局部性原理认为，通常一个数据被用到，其附近的数据也会立马被用到。&nbsp; &nbsp; &nbsp;B树：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。&nbsp; &nbsp; &nbsp;B+树：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。&nbsp; &nbsp; &nbsp;由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。&nbsp; &nbsp; &nbsp;B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。索引的优缺点&nbsp; &nbsp;优点：&nbsp; &nbsp; &nbsp;1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。&nbsp; &nbsp; &nbsp;2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。&nbsp; &nbsp; &nbsp;3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。&nbsp; &nbsp; &nbsp;4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。&nbsp; &nbsp; &nbsp;5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。&nbsp; &nbsp;缺点：&nbsp; &nbsp; &nbsp;1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。&nbsp; &nbsp; &nbsp;2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。&nbsp; &nbsp; &nbsp;3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。哪些字段适合建索引&nbsp; &nbsp; &nbsp;1.在经常需要搜索的列上，可以加快搜索的速度；&nbsp; &nbsp; &nbsp;2.在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；&nbsp; &nbsp; &nbsp;3.在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；&nbsp; &nbsp; &nbsp;4.在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；&nbsp; &nbsp; &nbsp;5.在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；&nbsp; &nbsp; &nbsp;6.在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。哪些字段不适合建索引&nbsp; &nbsp; &nbsp;1.对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。&nbsp; &nbsp; &nbsp;2.对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。&nbsp; &nbsp; &nbsp;3.对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。&nbsp; &nbsp; &nbsp;4.当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚集索引与非聚集索引]]></title>
    <url>%2F%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.html</url>
    <content type="text"><![CDATA[聚集索引就是存放的物理顺序和列中的顺序一样。一般设置主键索引就为聚集索引。 聚集索引&nbsp; &nbsp; &nbsp;聚集索引就是存放的物理顺序和列中的顺序一样。一般设置主键索引就为聚集索引。&nbsp; &nbsp; &nbsp;一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是平衡树结构，换句话说，就是整个表就变成了一个索引，也就是所谓的聚集索引。 这就是为什么一个表只能有一个主键， 一个表只能有一个聚集索引，因为主键的作用就是把表的数据格式转换成索引（平衡树）的格式放置。&nbsp; &nbsp; &nbsp;上图就是带有主键的表（聚集索引）的结构图。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 假如我们执行一个SQL语句：select * from table where id = 1256&nbsp; &nbsp; &nbsp;首先根据索引定位到1256这个值所在的叶结点，然后再通过叶结点取到id等于1256的数据行。 这里不讲解平衡树的运行细节， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图&nbsp; &nbsp; &nbsp;然而， 事物都是有两面的， 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。非聚集索引&nbsp; &nbsp; 讲完聚集索引 ， 接下来聊一下非聚集索引， 也就是我们平时经常提起和使用的常规索引。&nbsp; &nbsp; 非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。&nbsp;如下图&nbsp; &nbsp; &nbsp;每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。&nbsp; 非聚集索引和聚集索引的区别在于：&nbsp; &nbsp; &nbsp;通过聚集索引可以一次查到需要查找的数据， 而通过非聚集索引第一次只能查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。&nbsp; &nbsp; &nbsp;聚集索引一张表只能有一个，而非聚集索引一张表可以有多个。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql数据库知识点总结01]]></title>
    <url>%2FMySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9301.html</url>
    <content type="text"><![CDATA[数据库架构 MySql数据库从大的方面可以分为两大部分，分别为底层的存储系统也就是文件系统，和上层的程序实例组成，程序实例有存储管理、缓存管理、日志管理、权限管理、容灾管理、SQL解析、索引、锁等 程序实：存储管理、缓存管理、日志管理、权限管理、容灾管理、SQL解析、索引、锁等 存储：文件系统 乐观锁和悲观锁 悲观锁：对数据持一种悲观的态度，认为在事务执行期间总是有别的事务修改数据，所以每一次操作都加锁乐观锁：对数据持一种乐观的态度，所以不加锁，乐观锁中每一项数据都有一个版本号，在事务提交的时候，通过版本号来看是否是否在事务A期间，事务B修改了数据，比如有两个事务，事务A先查询数据，此时数据的版本号为0，事务B查询版本也为0，当A修改了数据并且版本变为1，在提交是版本号1&gt;0提交成功，此时事务也修改了数据把版本加一变为1，在提交时版本号1不大于1，所以提交被驳回，数据过期 三范式 第一范式：字段不可分，只要是数据库中存在的表都符合1NF第二范式：消除了非主属性对码的部分依赖第三范式：消除了非主属性对码的传递依赖 数据库ACID的特性 A:原子性—-一次事务是数据库的最小执行单位，要么事务内的所有操作做完，要么全不做，事务期间只要有一个操作不成功，就回滚，回到事务开始之前C:一致性—-事务从一个一致性状态转移到另一个一致性转态，比如：账户A有100，账户B也有100，加起来是200，当A给B转了50后，A为50，B为150，加起来还是200，感觉有一点能量守恒的意思I:隔离线—-一个事务的操作在提交之前是对其他不可见的D:持久性—-一旦事务提交数据会被保存到磁盘永久有效 leftjoin和rightjoin、innerjoin的区别 leftjoin(左联接) ：包含左表的全部数据和右表中联结字段相等的记录rightjoin(右联接)： 返回包括右表中的所有记录和左表中联结字段相等的记录innerjoin(等值连接)： 只返回两个表中联结字段相等的行 DROP，DELETE与TRUNCATE的区别 DROP会把一个表删掉DELETE删除一个表的数据，一般配合where使用TRUNCATE清空表中的数据，下一次在插入数据时自增长Id从1开始 UNION/ALL、EXCEPT/ALL和INTERSECT/ALL union 合并两个查询结果，把两个结果做并集并且删除重复的行，union all不会删除重复的行expect 把两个结果做查，包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行，expect all不消除重复的行insert 把两个结果集做交集 只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表 expect all不消除重复的行 InnoDB和MyISAM InnoDB MyISAM MySQL默认的引擎，支持行级锁和表级锁 ，支持事务 只支持表级锁，不支持事务 适用大量的INSERT或UPDATE操作 适用大量的SELECT查询 为什么MyISAM会比InnoDB的查询速度快？ InnoDB要缓存数据块，而MyISAM只需要缓存索引快 InnoDB寻址要先映射到数据块在到数据行，而MyISAM记录的直接是数据的OFESET，定位比InooDB块 InnoDB还需要维护MVCC一致 隔离级别 脏读 读取了一个事务还未提交的数据 不可重复读 在同一个事务中两次读取的结果不一样，和幻读相比更侧重数据的修改 幻读 在同一个事务中两次读取的记录数量不一样，更偏向于插入操作带来的不一样 事务隔离级别 更新丢失 脏读 不可重复读 幻读 读未提交 （Read uncommitted） × √ √ √ 读已提交 （Read committed） × × √ √ 可重复读（Repeatable read） × × × √ 序列化（Serializable） × × × × MySql在RR隔离级别下是如何避免幻读的 表象：快照读也叫非阻塞读 –伪MVVC 内在： next-key锁（行锁+gap锁） 快照读和当前读？当前读：加了锁的增删改查语句 快照读：不加锁的非阻塞读,快照读顾名思义会生成快照，在RC（Read Committed）隔离级别下每一次的select语句都会产生一个快照，所以会产生幻读，在RR级别下，select语句执行的时间不同，生成的快照也会不同，如果有个事务的select语句执行的时候另一个事务还没提交那么这个事务就看不到另一个事务的修改，反之如果一个事务在另一个事务提交后执行了select语句那这个事务就可以看到另一个事务的修改也就是查询可以看到自己之前已提的所有事务所做的更改，看不到在查询开始之后的事务提交的更改 next-key锁？ MySql在RR隔离级别下实际上是通过next-key锁避免幻读的，next-key锁就是行锁+gap锁，gap会把一个范围锁起来，比如一个表的索引是1,3,5,当执行select * from table where id &gt; 3;就会把&gt;3的范围锁起来，当在另一个事务中插入一条id为4的数据时，就会被阻塞，只有当事务提交以后，另一个事务才能继续执行插入语句]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后台开发面试考点汇总]]></title>
    <url>%2FJava%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[一、JavaSE部分❤1、Java基础1、为什么重写equals还要重写hashcode2、说一下map的分类和常见的情况 3、Object若不重写hashCode()的话，hashCode()如何计算出来的？4、==比较的是什么？ 5、若对一个类不重写，它的equals()方法是如何比较的？6、java8新特性 7、说说Lamda表达式的优缺点。 8、一个十进制的数在内存中是怎么存的？ 9、为啥有时会出现4.0-3.6=0.40000001这种现象？ 10、Java支持的数据类型有哪些？什么是自动拆装箱？ 11、什么是值传递和引用传递？ 12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？ 13、你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？ 14、String是最基本的数据类型吗? 15、int 和 Integer 有什么区别 16、String 和StringBuffer的区别 17、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？ 18、int和Integer有什么区别？ 19、&amp;和&amp;&amp;的区别？ 20、在Java中，如何跳出当前的多重嵌套循环？ 21、你能比较一下Java和JavaSciprt吗？ 22、简述正则表达式及其用途。 23、Java中是如何支持正则表达式操作的？ 24、请你说说Java和PHP的区别？ ❤2、关键字 1、介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？2、介绍一下volatile？ 3、锁有了解嘛，说一下Synchronized和lock 4、讲一讲Java里面的final关键字怎么用的？ ❤3、面向对象1、wait方法底层原理 2、Java有哪些特性，举个多态的例子。 3、String为啥不可变？ 4、类和对象的区别 5、请列举你所知道的Object类的方法。 6、重载和重写的区别？相同参数不同返回值能重载吗？ 7、”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ 8、String能继承吗？ 9、StringBuffer和StringBuilder有什么区别，底层实现上呢？ 10、类加载机制，双亲委派模型，好处是什么？ 11、静态变量存在哪? 12、讲讲什么是泛型？ 13、解释extends 和super 泛型限定符-上界不存下界不取 14、是否可以在static环境中访问非static变量？ 15、谈谈如何通过反射创建对象？ 16、Java支持多继承么？ 17、接口和抽象类的区别是什么？ 18、Comparable和Comparator接口是干什么的？列出它们的区别。 19、面向对象的特征有哪些方面 20、final, finally, finalize的区别。 21、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? 22、abstract class和interface有什么区别? 23、Static Nested Class 和 Inner Class的不同 24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 25、Java的接口和C++的虚类的相同和不同处。 26、JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ 27、内部类可以引用他包含类的成员吗？有没有什么限制？ 28、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code说法是否正确？ 29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 30、如何通过反射获取和设置对象私有字段的值？ 31、谈一下面向对象的”六原则一法则”。 32、请问Query接口的list方法和iterate方法有什么区别？ 33、Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？ 34、Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？ 35、hashCode()和equals()方法有什么联系？ ❤4、集合1、Map和ConcurrentHashMap的区别？ 2、hashMap内部具体如何实现的？ 3、如果hashMap的key是一个自定义的类，怎么办？ 4、ArrayList和LinkedList的区别，如果一直在list的尾部添加元素，用哪个效率高？ 5、HashMap底层，负载因子，为啥是2^n？ 6、ConcurrentHashMap锁加在了哪些地方？ 7、TreeMap底层，红黑树原理？ 8、concurrenthashmap有啥优势，1.7，1.8区别？ 9、ArrayList是否会越界？ 10、什么是TreeMap? 11、ConcurrentHashMap的原理是什么？ 12、Java集合类框架的基本接口有哪些？ 13、为什么集合类没有实现Cloneable和Serializable接口？ 14、什么是迭代器？ 15、Iterator和ListIterator的区别是什么？ 16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ 17、HashMap和Hashtable有什么区别？ 18、ArrayList和LinkedList有什么区别？ 19、ArrayList,Vector,LinkedList的存储性能和特性是什么？ 20、Collection 和 Collections的区别。 21、你所知道的集合类都有哪些？主要方法？ 22、List、Set、Map是否继承自Collection接口？ 23、阐述ArrayList、Vector、LinkedList的存储性能和特性 24、List、Map、Set三个接口存取元素时，各有什么特点？ ❤5、线程1、多线程中的i++线程安全吗？为什么？2、如何线程安全的实现一个计数器？ 3、多线程同步的方法 4、介绍一下生产者消费者模式？ 5、线程，进程，然后线程创建有很大开销，怎么优化？ 6、线程池运行流程，参数，策略 7、讲一下AQS吧。 8、创建线程的方法，哪个更好，为什么？ 9、Java中有几种方式启动一个线程？ 10、Java中有几种线程池？ 11、线程池有什么好处？ 12、cyclicbarrier和countdownlatch的区别 13、如何理解Java多线程回调方法？ 14、创建线程有几种不同的方式？你喜欢哪一种？为什么？ 15、概括的解释下线程的几种可用状态。 16、同步方法和同步代码块的区别是什么？ 17、启动线程有哪几种方式，线程池有哪几种？ 18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 19、sleep() 和 wait() 有什么区别？ 20、同步和异步有何异同，在什么情况下分别使用他们？举例说明。 21、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。使用内部类实现线程，对j增减的时候没有考虑顺序问题。 22、启动一个线程是用run()还是start()? 23、请说出你所知道的线程同步的方法 24、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 25、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？ 26、线程的sleep()方法和yield()方法有什么区别？ 27、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 28、请说出与线程同步以及线程调度相关的方法。 29、举例说明同步和异步 30、什么是线程池（thread pool）？ 31、说说线程的基本状态以及状态之间的关系？ 32、如何保证线程安全？ ❤6、锁 1、讲一下非公平锁和公平锁在reetrantlock里的实现。2、讲一下synchronized，可重入怎么实现。 3、锁和同步的区别。 4、什么是死锁(deadlock)？ 5、如何确保N个线程可以访问N个资源同时又不导致死锁？ 6、请你简述synchronized和java.util.concurrent.locks.Lock的异同？ ❤7、JDK 1、Java中的LongAdder和AtomicLong的区别2、JDK和JRE的区别是什么？ ❤8、反射1、反射的实现与作用 ❤9、JVM1、JVM回收算法和回收器，CMS采用哪种回收算法，怎么解决内存碎片问题？ 2、类加载过程 3、JVM分区 4、eden区，survial区? 5、JAVA虚拟机的作用? 6、GC中如何判断对象需要被回收？ 7、JAVA虚拟机中，哪些可作为ROOT对象？8、JVM内存模型是什么？ 9、jvm是如何实现线程？ 10、jvm最大内存限制多少 11、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ 12、描述一下JVM加载class文件的原理机制? ❤10、GC 1、java中内存泄露是啥，什么时候出现内存泄露？2、minor gc如果运行的很频繁，可能是什么原因引起的，minor gc如果运行的很慢，可能是什么原因引起的? 3、阐述GC算法 4、GC是什么? 为什么要有GC? 5、垃圾回收的优点和原理。并考虑2种回收机制 6、java中会存在内存泄漏吗，请简单描述。 7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（垃圾回收） ❤11、IO和NIO、AIO1、怎么打印日志？ 2、运行时异常与一般异常有何异同？ 3、error和exception有什么区别? 4、给我一个你最常见到的runtime exception 5、Java中的异常处理机制的简单原理和应用。 6、java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？ 7、什么是java序列化，如何实现java序列化？ 8、运行时异常与受检异常有什么区别？ 二、JavaEE部分❤1、Spring1、说一下IOC和AOP? 2、介绍一下bean的生命周期 3、Spring里面注解用过没有？autowired 和resource区别？ 4、@Controller和@RestController的区别？ 5、依赖注入的方式有几种，哪几种？ 6、springIOC原理？自己实现IOC要怎么做，哪些步骤？ 7、Spring中BeanFactory和ApplicationContext的区别？、 8、什么是IoC和DI？DI是如何实现的？ 9、请问Spring中Bean的作用域有哪些？ 10、谈谈Spring中自动装配的方式有哪些？ 11、aop的应用场景？ 12、AOP的原理是什么？ 13、你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？ 14、Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？ 15、介绍一下spring？ 16、Struts拦截器和Spring AOP区别？ 17、spring框架的优点？ 18、选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？ 19、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？ ❤2、Hibernate1、阐述实体对象的三种状态以及转换关系。 2、Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？ 3、Hibernate中Session的load和get方法的区别是什么？ 4、如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？ 4、简述Hibernate常见优化策略。 5、锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。 6、Hibernate如何实现分页查询？ 7、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。 ❤3、Struts1、说说STRUTS的应用 ❤4、Mybatis1、解释一下MyBatis中命名空间（namespace）的作用。 2、MyBatis中的动态SQL是什么意思？ ❤5、MVC1、Spring MVC注解的优点 2、springmvc和spring-boot区别？ 3、SpringMVC的运行机制，运行机制的每一部分的相关知识？ 4、谈谈Spring MVC的工作原理是怎样的？ ❤6、各框架对比与项目优化1、Mybatis和Hibernate区别？ 2、介绍一下你了解的Java领域的Web Service框架。 ❤7、JPA1、EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。 2、EJB与JAVA BEAN的区别？ 3、EJB包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？ 4、EJB的角色和三个对象是什么？ 5、说说EJB规范规定EJB中禁止的操作有哪些？ 6、EJB的激活机制是什么？ 7、EJB的几种类型分别是什么 8、EJB需直接实现它的业务接口或Home接口吗，请简述理由。 三、Java web编程❤1、web编程基础1、启动项目时如何实现不在链接里输入项目名就能启动? 2、1分钟之内只能处理1000个请求，你怎么实现，手撕代码? 3、什么时候用assert 4、JAVA应用服务器有那些？ 5、JSP的内置对象及方法。 6、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？（JSP） 7、说一说四种会话跟踪技术 8、讲讲Request对象的主要方法 9、说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然后在浏览器上就可打入主机？ 10、jsp有哪些动作?作用分别是什么? 11、请谈谈JSP有哪些内置对象？作用分别是什么？ 12、说一下表达式语言（EL）的隐式对象及其作用 13、JSP中的静态包含和动态包含有什么区别？ 14、过滤器有哪些作用和用法？ 15、请谈谈你对Javaweb开发中的监听器的理解？ 16、说说web.xml文件中可以配置哪些内容？ ❤2、web编程进阶1、forward与redirect区别，说一下你知道的状态码，redirect的状态码是多少？ 2、servlet生命周期，是否单例，为什么是单例。 3、说出Servlet的生命周期，并说出Servlet和CGI的区别。 4、Servlet执行时一般实现哪几个方法？ 5、阐述一下阐述Servlet和CGI的区别? 6、说说Servlet接口中有哪些方法？ 7、Servlet 3中的异步处理指的是什么？ 8、如何在基于Java的Web项目中实现文件上传和下载？ 9、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()方法？ 10、Servlet中如何获取用户提交的查询参数或表单数据？ 11、Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？ 12、讲一下redis的主从复制怎么做的？ 13、redis为什么读写速率快性能好？ 14、redis为什么是单线程？ 15、缓存的优点？ 16、aof，rdb，优点，区别？ 17、redis的List能用做什么场景？ 18、说说MVC的各个部分都有那些技术来实现?如何实现? 19、什么是DAO模式？ 20、请问Java Web开发的Model 1和Model 2分别指的是什么？ 21、你的项目中使用过哪些JSTL标签？ 22、使用标签库有什么好处？如何自定义JSP标签？（JSP标签） ❤3、web编程原理1、get和post区别？ 2、请谈谈转发和重定向的区别？ 3、说说你对get和post请求，并且说说它们之间的区别？ 4、cookie 和session 的区别？ 5、forward 和redirect的区别 6、BS与CS的联系与区别。 7、如何设置请求的编码以及响应内容的类型？ 8、什么是Web Service（Web服务）？ 9、谈谈Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？ 10、大型网站在架构上应当考虑哪些问题？ 11、请对J2EE中常用的名词进行解释(或简单描述) 四、JDBC编程 ❤1、SQL基础1、写SQL：找出每个城市的最新一条记录。2、一个学生表，一个课程成绩表，怎么找出学生课程的最高分数 3、有一组合索引（A,B,C），会出现哪几种查询方式？tag:sql语句 ❤2、JDBC基础1、数据库水平切分，垂直切分2、数据库索引介绍一下。介绍一下什么时候用Innodb什么时候用MyISAM。 3、数据库两种引擎 4、索引了解嘛，底层怎么实现的，什么时候会失效 5、问了数据库的隔离级别 6、数据库乐观锁和悲观锁 7、数据库的三范式？ 8、讲一下数据库ACID的特性？ 9、mysql主从复制？ 10、leftjoin和rightjoin的区别？ 11、数据库优化方法 12、谈一下你对继承映射的理解。 13、说出数据连接池的工作机制是什么? 14、事务的ACID是指什么？ 15、JDBC中如何进行事务处理？ ❤3、JDBC进阶1、JDBC的反射，反射都是什么？2、Jdo是什么? 3、Statement和PreparedStatement有什么区别？哪个性能更好？ 4、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？ 五、XML❤1、XML基础1、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ ❤2、Web Service1、WEB SERVICE名词解释，JSWDL开发包的介绍，JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。 2、请你谈谈对SOAP、WSDL、UDDI的了解？ 3、谈谈Java规范中和Web Service相关的规范有哪些？ 六、计算机网络 ❤1、网络概述1、TCP协议在哪一层？IP协议在那一层？HTTP在哪一层？ ❤2、运输层1、讲一下TCP的连接和释放连接。2、TCP有哪些应用场景 3、tcp为什么可靠 4、tcp为什么要建立连接 5、阐述TCP的4次挥手 6、讲一下浏览器从接收到一个URL到最后展示出页面，经历了哪些过程。tag 7、http和https的区别 8、http的请求有哪些，应答码502和504有什么区别 9、http1.1和1.0的区别 10、说说ssl四次握手的过程 11、304状态码有什么含义？ ❤3、网络层1、arp协议，arp攻击2、icmp协议 3、讲一下路由器和交换机的区别？ ❤4、应用层1、DNS寻址过程2、负载均衡反向代理模式优点及缺点 七、操作系统❤1、操作系统概论1、CentOS 和 Linux的关系？2、64位和32位的区别？ ❤2、进程的描述与控制1、怎么杀死进程？ 2、线程，进程区别 3、系统线程数量上限是多少？ 4、进程和线程的区别是什么？ 5、解释一下LINUX下线程，GDI类。 ❤3、输入输出系统1、socket编程，BIO，NIO，epoll？ ❤4、存储器管理1、什么是页式存储？ 2、操作系统里的内存碎片你怎么理解，有什么解决办法？ ❤5、处理机调度与死锁1、什么情况下会发生死锁，解决策略有哪些？ 2、系统CPU比较高是什么原因？ 3、系统如何提高并发性？ 八、算法与数据结构 ❤1、哈希1、hashset存的数是有序的吗？2、Object作为HashMap的key的话，对Object有什么要求吗？ 3、一致性哈希算法 4、什么是hashmap? 5、Java中的HashMap的工作原理是什么？ 6、hashCode()和equals()方法的重要性体现在什么地方？ ❤2、树1、说一下B+树和B-树？2、怎么求一个二叉树的深度?手撕代码? 3、算法题：二叉树层序遍历，进一步提问：要求每层打印出一个换行符 4、二叉树任意两个节点之间路径的最大长度 5、如何实现二叉树的深度？ 6、如何打印二叉树每层的节点？ 7、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？ ❤3、遍历1、编程题：写一个函数，找到一个文件夹下所有文件，包括子文件夹2、二叉树 Z 字型遍历 ❤4、链表1、反转单链表2、随机链表的复制 3、链表-奇数位升序偶数位降序-让链表变成升序 4、bucket如果用链表存储，它的缺点是什么？ 5、如何判断链表检测环 ❤5、数组1、寻找一数组中前K个最大的数2、求一个数组中连续子向量的最大和 3、找出数组中和为S的一对组合，找出一组就行 4、一个数组，除一个元素外其它都是两两相等，求那个元素? 5、算法题：将一个二维数组顺时针旋转90度，说一下思路。 ❤6、排序1、排序算法知道哪些，时间复杂度是多少，解释一下快排？2、如何得到一个数据流中的中位数？ 3、堆排序的原理是什么？ 4、归并排序的原理是什么？ 5、排序都有哪几种方法？请列举出来。 6、如何用java写一个冒泡排序？ ❤7、堆与栈1、堆与栈的不同是什么？2、heap和stack有什么区别。 3、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。 ❤8、队列1、什么是Java优先级队列(Priority Queue)？ ❤9、高级算法1、题目：Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted. Could you do both operations in O(1) time complexity? 2、id全局唯一且自增，如何实现？ 3、如何设计算法压缩一段URL？ 4、为什么要设计后缀表达式，有什么好处？ 5、LRU算法的实现原理？ 九、设计模式❤1、结构型模式1、java中有哪些代理模式？2、如何实现动态代理 3、IO流熟悉吗，用的什么设计模式？ ❤2、创建型模式1、介绍一下单例模式？懒汉式的单例模式如何实现单例？ ❤3、行为型模式1、介绍一下策略模式？2、设计模式了解哪些，手写一下观察者模式？ ❤4、模式汇总1、说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法2、j2ee常用的设计模式？说明工厂模式。 3、开发中都用到了那些设计模式?用在什么场合? 4、简述一下你了解的Java设计模式 十、场景题❤1、场景题汇总1、情景题：如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？2、场景题：美团首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？可以借鉴下stackoverflow，视频网站等等的推荐算法。3、场景题：微信抢红包问题悲观锁，乐观锁，存储过程放在mysql数据库中。4、场景题：1000个任务，分给10个人做，你怎么分配，先在纸上写个最简单的版本，然后优化。全局队列，把1000任务放在一个队列里面，然后每个人都是取，完成任务。分为10个队列，每个人分别到自己对应的队列中去取务。5、场景题：保证发送消息的有序性，消息处理的有序性。6、如何把一个文件快速下发到100w个服务器7、给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的?8、10亿个数，找出最大的10个。建议一个大小为10的小根堆。9、有几台机器存储着几亿淘宝搜索日志，你只有一台2g的电脑，怎么选出搜索热度最高的十个搜索关键词？10、分布式集群中如何保证线程安全？11、给个淘宝场景，怎么设计一消息队列？12、10万个数，输出从小到大？先划分成多个小文件，送进内存排序，然后再采用多路归并排序。13、有十万个单词，找出重复次数最高十个？十一、UML ❤1、UML1、请你谈一下UML中有哪些常用的图？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三次握手和四次挥手]]></title>
    <url>%2F%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</url>
    <content type="text"><![CDATA[在建立TCP连接时需要三次握手，在断开连接时需要四次挥手 三次握手第一次握手： 客户端向服务端发送SYN包{SYN=1，seq=x}，客户端进入SYN_SENT状态第二次握手： 服务端向客户端发送应答的ASK包和SYN包{ASK=1,SYN=1,ask=x+1,seq=y},服务端进入SYN_RCVD状态第三次握手： 客户端向服务端发送应答的ASK包{ASK=1，ask=y+1,seq=x+1}，客户端进入ESTABLISHED状态，服务端收到ASK包后也进入ESTABLISHED状态 建立连接为什么是三次握手，而不是两次呢？加入是两次的话对客户端 是没有影响的，客户端开始在收到服务端的ASK-SYN包后进入ESTABLISHED状态，客户端向服务端发送数据是没问题的，但对于服务端来说，在接收到客户端的ASk连接请求后就进入了ESTABLISHED状态，并发送向客户端发送ASK-SYN包，如果这时客户端没有收到ASK-SYN包，没有进入ESTABLISHED状态，但服务端就给客户端发送数据，肯定是失败的，服务端将会一直等待下去，这样浪费服务端连接资源。 四次挥手由于TCP传输是全双工的，客户端向服务器发送数据的同时服务端也可以向客户端发送数据，所以断开连接需要四次挥手，前两次断开一个方向的连接，后两次断开另一个方向的连接第一次挥手： 当客户端的数据发送完后，向服务端发送一个FIN包请求断开连接{FIN=1,seq=u},客户端进入FIN-WAIT1状态第二次挥手： 服务端收到客户端发来的FIN断开请求后，通知应用程序客户端发送数据完成，不会再发数据了，同时做出应答给客户端发送一个ASK包，{ASK=1,ask=u+1,seq=v},服务端进入CLOSE-WAIT状态，客户端在收到应答后进入FIN-WAIT2状态，此时从客户端到服务端的连接断开，客户端不会发送数据，服务端也不会在接收数据，但这时候服务端还可以向客户端发送数据，还需要接下来的两次挥手第三次挥手： 当服务端的数据发送完以后，也会向客户端发送一个FIN包请求断开连接{FIN=1，ASK=1,seq=w,ask=u+1}，服务端进入LAST-ASK状态第四次挥手： 客户端在接收到断开请求后，进入TIME-WAIT状态，并向服务端发送应答{ASK=1,seq=u+1,ask=w+1},服务端在接收到应答后，进入CLOSED转态，等客户端的TIME-WAIT结束后，客户端也进入CLOSED状态，此时服务端到客户端的连接断开 客户端在收到第三次挥手后为什么没有立即进入关闭状态呢？因为客户端要等服务端收到客户端的应答，如果服务端没有收到应答，服务端会从新发送断开连接的请求，而这时客户端已经关闭了，那么服务端到客户端的连接将永远不能关闭]]></content>
      <categories>
        <category>计算机网络基础</category>
      </categories>
      <tags>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础之OSI参考模型]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[1. OSI参考模型 OSI参考模型的七层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层! 1.1 为什么要分层 分层可以让网络通信系统更加的灵活，每层之间用接口连接，每一层互补干扰，即使有一层发生了改变，但整个系统不受影响 比如上图的通话系统分为语言层和通信设备层，如果把通信设备层的电话机换成无线电照样可以实现通话，同样的把语言层的汉语变成英语，也可以实现通话 1.2 各层的作用 物理层：完成数模和模数转换，完成模拟信号和0和1的比特流之间的转化 数据链路层：互联的设备之间互传数据帧，数据帧和比特流之间的转换 网络层：路由的选择，完成到目的IP地址的路由 传输层：实现可靠的端对端的传输 会话层：何时建立连接何时断开连接，以及收发的顺序 表示层：统一数据的格式，将不同的数据格式转换为网络统一的数据格式 应用层： 针对特定应用的协议1.3 OSI参考模型通信处理举例 当A用户用主机A给使用B主机的B用户发送邮件时在OSI七层参考模型中是怎样处理的呢？假定用户A给用户B发送邮件的内容是“早上好”，接下来我们逐层分析 应用层： 当用户A在软件中输入收件人为B，内容是“早上好”，点击发送后，应用层的协议就开始处理了，应用层的协议会在发送的数据的加上一个头部信息，头部信息包括收件人是用户B内容是“早上好”，然后把数据交给表示层 表示层： 由于不同的机器用的数据格式不一样，如果不统一数据格式的话，到达接收方数据就会乱套，所以表示层协议要做的就是在头部加上数据格式的信息 会话层： 会话层协议处理的就是何时建立连接，何时断开连接，假如用户A要给用户B发送5个邮件，会话层要处理的就是这些邮件的发送顺序，把这些信息加到数据的头部 传输层： 在传输层主机A和主机B之间通信，并建立连接，然后开始发送数据，数据发送完成以后，就断开连接，如果发送的数据有丢失的A会从新发送丢失的数据，所以也会在头部加上相应的信息 网络层： 在主机A和主机B之间的联通是有很多网络组成的，网络层就是地址管理，路由管理，找到目标IP地址，网络层并不能确保数据到达了目标，所以要配合传输层，实现可靠的传输 数据链路层和物理层： 总结：其实整个过程就是一层层的加头部信息，然后B收到数据后一层一层的根据头部信息把头部信息去掉，最后拿到数据]]></content>
      <categories>
        <category>计算机网络基础</category>
      </categories>
      <tags>
        <tag>OSI参考模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+Quartz最简单的HelloWorld入门示例]]></title>
    <url>%2FSpring%2BQuartz%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84HelloWorld%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B.html</url>
    <content type="text"><![CDATA[实现的效果，定时执行有关Quartz不做介绍，可自行学习首先添加依赖 spring相关的依赖根据自己的版本添加，注意要加spring-context-support的依赖，版本和spring的版本保持一致就可以了 &lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --> &lt;dependency> &lt;groupId>org.quartz-scheduler&lt;/groupId> &lt;artifactId>quartz&lt;/artifactId> &lt;version>2.3.0&lt;/version> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context-support&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> 写一个要定时执行的类 public class HelloWordJob { public void sayHi(){ try { SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date = simpleDateFormat.format(new Date()); System.out.println("hi "+date); } catch (Exception e){ e.printStackTrace(); } } } XML的配置 在spring的配置文件中加入以下代码，其中id=helloWordJob的bean就是你要定时实行的类，其他的不用改 &lt;!-- job --> &lt;bean id="helloWordJob" class="com.imooc.myo2o.service.impl.HelloWordJob"/> &lt;!-- 使用MethodInvokingJobDetailFactoryBean，任务类可以不实现Job接口，通过targetMethod指定调用方法--> &lt;!-- jobDetail --> &lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"> &lt;property name="targetObject" ref="helloWordJob"/> &lt;property name="targetMethod" value="sayHi"/> &lt;!--false表示等上一个任务执行完后再开启新的任务,这里和上一遍博客中的注解@DisallowConcurrentExecution一个道理--> &lt;property name="concurrent" value="false"/> &lt;/bean> &lt;!-- Trigger--> &lt;bean id="helloWordJobCronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"> &lt;property name="jobDetail" ref="jobDetail"/> &lt;property name="cronExpression" value="0/3 * * * * ?"/> &lt;/bean> &lt;!--Scheduler --> &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"> &lt;property name="triggers"> &lt;list> &lt;ref bean="helloWordJobCronTrigger"/> &lt;/list> &lt;/property> &lt;/bean> 这样启动你的Tomcat就可以看到效果了让目标方法按照自己指定的时间执行，可修改 Trigger的cronExpression，可参考在线Cron表达式生成器：https://www.pppet.net/]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java如何利用google的zxing生成二维码，只要两步，超级简单]]></title>
    <url>%2Fjava%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8google%E7%9A%84zxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html</url>
    <content type="text"><![CDATA[实现的效果,在页面中直接引入 &lt;html> &lt;body> &lt;img alt="二维码" src="/myo2o/qrcode/generateqrcode"> &lt;/body> &lt;/html> 打开页面，静态页面src地址要写全，前面要加http://localhost:8080首先添加依赖 &lt;dependency> &lt;groupId>com.google.zxing&lt;/groupId> &lt;artifactId>javase&lt;/artifactId> &lt;version>3.3.0&lt;/version> &lt;/dependency> 写一个二维码生成工具类 public static BitMatrix generateQRCodeStream(String content,HttpServletResponse response) { //给相应添加头部信息，主要告诉浏览器返回的是图片流 response.setHeader("Cache-Control", "no-store"); // 不设置缓存 response.setHeader("Pragma", "no-cache"); response.setDateHeader("Expires", 0); response.setContentType("image/png"); //设置图片的文字编码以及内边框 Map&lt;EncodeHintType, Object> hints = new HashMap&lt;>(); //编码 hints.put(EncodeHintType.CHARACTER_SET, "UTF-8"); //边框距 hints.put(EncodeHintType.MARGIN, 0); BitMatrix bitMatrix; try { //参数分别为：编码内容、编码类型、图片宽度、图片高度，设置参数 bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, 300, 300,hints); }catch(WriterException e) { e.printStackTrace(); return null; } return bitMatrix; } 写一个响应的Controller，在页面的img标签中src写的就是这个地址 @Controller @RequestMapping("/qrcode") public class QRCodeTestController { @RequestMapping(value = "/generateqrcode", method = RequestMethod.GET) @ResponseBody public void generateQRCode4Product(HttpServletRequest request, HttpServletResponse response) { String longUrl; try { longUrl = "https://blog.csdn.net/victoyr"; // 转换成短url String shortUrl = BaiduDwz.createShortUrl(longUrl); // 生成二维码 BitMatrix qRcodeImg = CodeUtil.generateQRCodeStream(shortUrl, response); // 将二维码输出到页面中 MatrixToImageWriter.writeToStream(qRcodeImg, "png", response.getOutputStream()); } catch (Exception e) { e.printStackTrace(); } } } 二维码生成的链接不能太长，所以把长链接转换成了短链接，转换方法：https://blog.csdn.net/victoyr/article/details/89679363 ，如果链接不是很长可以不用 Ok啦，是不是很简单呢。]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>zxing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用百度短链接接口将一个长链接变成短链接]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%8E%A5%E5%8F%A3%E5%B0%86%E4%B8%80%E4%B8%AA%E9%95%BF%E9%93%BE%E6%8E%A5%E5%8F%98%E6%88%90%E7%9F%AD%E9%93%BE%E6%8E%A5.html</url>
    <content type="text"><![CDATA[短网址服务可以帮助你把一个长网址缩短，方便你在社交网络和第三方平台上分享链接，投放广告等等。 我们提供超简单的方式使用短网址服务：访问百度短网址首页https://dwz.cn，输入你要缩短的原网址，生成对应的短网址。你还可以调用百度短网址服务API服务，查看数据统计与分析……更多功能，等你来探索！ 官方文档：https://dwz.cn/console/apidoc首先添加依赖 &lt;dependency> &lt;groupId>com.google.code.gson&lt;/groupId> &lt;artifactId>gson&lt;/artifactId> &lt;version>2.8.5&lt;/version> &lt;/dependency> 然后去百度官方文档https://dwz.cn/console/apidoc复制示例 package com.imooc.myo2o.util.baidu; import java.io.IOException; import java.io.OutputStreamWriter; import java.net.HttpURLConnection; import java.net.URL; import java.io.BufferedReader; import java.io.InputStreamReader; import com.google.gson.Gson; import com.google.gson.annotations.SerializedName; public class BaiduDwz { final static String CREATE_API = "https://dwz.cn/admin/v2/create"; final static String TOKEN = "你的token"; // TODO:设置Token class UrlResponse { @SerializedName("Code") private int code; @SerializedName("ErrMsg") private String errMsg; @SerializedName("LongUrl") private String longUrl; @SerializedName("ShortUrl") private String shortUrl; public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getErrMsg() { return errMsg; } public void setErrMsg(String errMsg) { this.errMsg = errMsg; } public String getLongUrl() { return longUrl; } public void setLongUrl(String longUrl) { this.longUrl = longUrl; } public String getShortUrl() { return shortUrl; } public void setShortUrl(String shortUrl) { this.shortUrl = shortUrl; } } /** * 创建短网址 * * @param longUrl * 长网址：即原网址 * @return 成功：短网址 * 失败：返回空字符串 */ public static String createShortUrl(String longUrl) { String params = "{\"url\":\""+ longUrl + "\"}"; BufferedReader reader = null; try { // 创建连接 URL url = new URL(CREATE_API); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); connection.setRequestMethod("POST"); // 设置请求方式 connection.setRequestProperty("Content-Type", "application/json"); // 设置发送数据的格式 connection.setRequestProperty("Token", TOKEN); // 设置发送数据的格式"); // 发起请求 connection.connect(); OutputStreamWriter out = new OutputStreamWriter(connection.getOutputStream(), "UTF-8"); // utf-8编码 out.append(params); out.flush(); out.close(); // 读取响应 reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8")); String line; String res = ""; while ((line = reader.readLine()) != null) { res += line; } reader.close(); // 抽取生成短网址 UrlResponse urlResponse = new Gson().fromJson(res, UrlResponse.class); if (urlResponse.getCode() == 0) { return urlResponse.getShortUrl(); } else { System.out.println(urlResponse.getErrMsg()); } return ""; // TODO：自定义错误信息 } catch (IOException e) { // TODO e.printStackTrace(); } return ""; // TODO：自定义错误信息 } public static void main(String[] args) { String res = createShortUrl("你的长网址"); System.out.println(res); } } 把代码中的token换成你的token在官方文档https://dwz.cn/console/apidoc中获取token到此就ok了，可以在main方法中试一下效果]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>百度短链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号如何授权登录、获取用户信息(openid)]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%A6%82%E4%BD%95%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E3%80%81%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF(openid).html</url>
    <content type="text"><![CDATA[首先看一下实现的效果，在公众号中，用户进入你的应用之前，会弹出一个授权页面，当用户点击确认后，你就可以获取用户的信息 首先访问微信测试号登录页面，通过打开自己手机的微信，扫一扫登录https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login进入到测试号页面后，分别看到如下信息【测试号信息】appID:开发者ID，是公众号开发识别码，配合开发者密码可以调用微信公众号接口，如获取微信昵称等appsecret:开发者密码，是检验公众号开发者身份的密码，具有极高的安全性。切记不要把密码交给第三方开发者或者编写到代码里【接口配置信息】URL: 是开发者用来接收微信消息和事件的接口URL，要用域名不能用ipToken:由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性） 当你填完URL和Token点击提交后，微信会访问你填写的URL，所以要在后台写一个servlet来处理这个请求 处理请求的Controller @Controller @RequestMapping("wechat") public class WeiXinController { @RequestMapping(method = { RequestMethod.GET }) public void doGet(HttpServletRequest request, HttpServletResponse response) { // 微信加密签名 String signature = request.getParameter("signature"); // 时间戳 String timestamp = request.getParameter("timestamp"); // 随机数 String nonce = request.getParameter("nonce"); // 随机字符串 String echostr = request.getParameter("echostr"); // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败 PrintWriter out = null; try { out = response.getWriter(); if (SignUtil.checkSignature(signature, timestamp, nonce)) { log.debug("weixin get success...."); out.print(echostr); } } catch (IOException e) { e.printStackTrace(); } finally { if (out != null) out.close(); } } } 微信请求校验工具类 /** * 微信请求校验工具类 */ public class SignUtil { // 与接口配置信息中的Token要一致 private static String token = "mytoken"; /** * 验证签名 * @param signature * @param timestamp * @param nonce * @return */ public static boolean checkSignature(String signature, String timestamp, String nonce) { String[] arr = new String[] { token, timestamp, nonce }; // 将token、timestamp、nonce三个参数进行字典序排序 Arrays.sort(arr); StringBuilder content = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) { content.append(arr[i]); } MessageDigest md = null; String tmpStr = null; try { md = MessageDigest.getInstance("SHA-1"); // 将三个参数字符串拼接成一个字符串进行sha1加密 byte[] digest = md.digest(content.toString().getBytes()); tmpStr = byteToStr(digest); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } content = null; // 将sha1加密后的字符串可与signature对比，标识该请求来源于微信 return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false; } /** * 将字节数组转换为十六进制字符串 * @param byteArray * @return */ private static String byteToStr(byte[] byteArray) { String strDigest = ""; for (int i = 0; i &lt; byteArray.length; i++) { strDigest += byteToHexStr(byteArray[i]); } return strDigest; } /** * 将字节转换为十六进制字符串 * @param mByte * @return */ private static String byteToHexStr(byte mByte) { char[] Digit = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' }; char[] tempArr = new char[2]; tempArr[0] = Digit[(mByte >>> 4) &amp; 0X0F]; tempArr[1] = Digit[mByte &amp; 0X0F]; String s = new String(tempArr); return s; } } 请求的处理程序写完后把项目重新打包发布到服务器上去，再提交你填写的URL和Token，接口配置信息就Ok啦 【JS接口安全域名】域名：想调用jssdk(如想要通过微信公众号js接口获取地图等工具)必须得填写此域名，在此域名的范围内才能调用jssdk工具，注意这里必须是域名，不是带有http之类的URL【测试号二维码】里面包含了测试号二维码以及已经关注了的用户信息【体验接口权限表】这里主要介绍【网页服务】里面的【网页帐号】网页帐号主要用来设置OAuth2.0里面的网页授权域名，用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。沙盒号回调地址支持域名和ip，正式公众号回调地址只支持域名。接下来需要编写自己的程序以获取关注此公众号的用户信息需要编写5个类 WechatLoginController.java，UserAccessToken.java，WechatUser.java，WechatUtil.java以及MyX509TrustManager.java【WechatLoginController】主要用来获取已关注此微信号的用户信息并做相应处理 @Controller @RequestMapping("wechatlogin") /** * 获取关注公众号之后的微信用户信息的接口，如果在微信浏览器里访问 * https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appId&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect * 则这里将会获取到code,之后再可以通过code获取到access_token 进而获取到用户信息 */ public class WechatLoginController { private static Logger log = LoggerFactory.getLogger(WechatLoginController.class); @RequestMapping(value = "/logincheck", method = { RequestMethod.GET }) public String doGet(HttpServletRequest request, HttpServletResponse response) { log.debug("weixin login get..."); // 获取微信公众号传输过来的code,通过code可获取access_token,进而获取用户信息 String code = request.getParameter("code"); // 这个state可以用来传我们自定义的信息，方便程序调用，这里也可以不用 // String roleType = request.getParameter("state"); log.debug("weixin login code:" + code); WechatUser user = null; String openId = null; if (null != code) { UserAccessToken token; try { // 通过code获取access_token token = WechatUtil.getUserAccessToken(code); log.debug("weixin login token:" + token.toString()); // 通过token获取accessToken String accessToken = token.getAccessToken(); // 通过token获取openId openId = token.getOpenId(); // 通过access_token和openId获取用户昵称等信息 user = WechatUtil.getUserInfo(accessToken, openId); log.debug("weixin login user:" + user.toString()); request.getSession().setAttribute("openId", openId); } catch (IOException e) { log.error("error in getUserAccessToken or getUserInfo or findByOpenId: " + e.toString()); e.printStackTrace(); } } // ======todo begin====== // 前面咱们获取到openId后，可以通过它去数据库判断该微信帐号是否在我们网站里有对应的帐号了， // 没有的话这里可以自动创建上，直接实现微信与咱们网站的无缝对接。 // ======todo end====== if (user != null) { // 获取到微信验证的信息后返回到指定的路由（需要自己设定） return "frontend/index"; } else { return null; } } } 【UserAccessToken】用户AccessToken实体类，用来接收accesstoken以及openid等信息 /** * 用户授权token * */ public class UserAccessToken { // 获取到的凭证 @JsonProperty("access_token") private String accessToken; // 凭证有效时间，单位：秒 @JsonProperty("expires_in") private String expiresIn; // 表示更新令牌，用来获取下一次的访问令牌，这里没太大用处 @JsonProperty("refresh_token") private String refreshToken; // 该用户在此公众号下的身份标识，对于此微信号具有唯一性 @JsonProperty("openid") private String openId; // 表示权限范围，这里可省略 @JsonProperty("scope") private String scope; public String getAccessToken() { return accessToken; } public void setAccessToken(String accessToken) { this.accessToken = accessToken; } public String getExpiresIn() { return expiresIn; } public void setExpiresIn(String expiresIn) { this.expiresIn = expiresIn; } public String getRefreshToken() { return refreshToken; } public void setRefreshToken(String refreshToken) { this.refreshToken = refreshToken; } public String getOpenId() { return openId; } public void setOpenId(String openId) { this.openId = openId; } public String getScope() { return scope; } public void setScope(String scope) { this.scope = scope; } @Override public String toString() { return "accessToken:" + this.getAccessToken() + ",openId:" + this.getOpenId(); } } 【WechatUser】微信用户实体类，用来接收昵称 openid等用户信息 /** * 微信用户实体类 */ public class WechatUser implements Serializable { private static final long serialVersionUID = -4684067645282292327L; // openId,标识该公众号下面的该用户的唯一Id @JsonProperty("openid") private String openId; // 用户昵称 @JsonProperty("nickname") private String nickName; // 性别 @JsonProperty("sex") private int sex; // 省份 @JsonProperty("province") private String province; // 城市 @JsonProperty("city") private String city; // 区 @JsonProperty("country") private String country; // 头像图片地址 @JsonProperty("headimgurl") private String headimgurl; // 语言 @JsonProperty("language") private String language; // 用户权限，这里没什么作用 @JsonProperty("privilege") private String[] privilege; public String getOpenId() { return openId; } public void setOpenId(String openId) { this.openId = openId; } public String getNickName() { return nickName; } public void setNickName(String nickName) { this.nickName = nickName; } public int getSex() { return sex; } public void setSex(int sex) { this.sex = sex; } public String getProvince() { return province; } public void setProvince(String province) { this.province = province; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public String getCountry() { return country; } public void setCountry(String country) { this.country = country; } public String getHeadimgurl() { return headimgurl; } public void setHeadimgurl(String headimgurl) { this.headimgurl = headimgurl; } public String getLanguage() { return language; } public void setLanguage(String language) { this.language = language; } public String[] getPrivilege() { return privilege; } public void setPrivilege(String[] privilege) { this.privilege = privilege; } @Override public String toString() { return "openId:" + this.getOpenId() + ",nikename:" + this.getNickName(); } } 【WechatUtil】主要用来提交https请求给微信获取用户信息 /** * 微信工具类 */ public class WechatUtil { private static Logger log = LoggerFactory.getLogger(WechatUtil.class); /** * 获取UserAccessToken实体类 * @param code * @return * @throws IOException */ public static UserAccessToken getUserAccessToken(String code) throws IOException { // 测试号信息里的appId String appId = "您的appId"; log.debug("appId:" + appId); // 测试号信息里的appsecret String appsecret = "您的appsecret"; log.debug("secret:" + appsecret); // 根据传入的code,拼接出访问微信定义好的接口的URL String url = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=" + appId + "&amp;secret=" + appsecret + "&amp;code=" + code + "&amp;grant_type=authorization_code"; // 向相应URL发送请求获取token json字符串 String tokenStr = httpsRequest(url, "GET", null); log.debug("userAccessToken:" + tokenStr); UserAccessToken token = new UserAccessToken(); ObjectMapper objectMapper = new ObjectMapper(); try { // 将json字符串转换成相应对象 token = objectMapper.readValue(tokenStr, UserAccessToken.class); } catch (JsonParseException e) { log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); } catch (JsonMappingException e) { log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); } catch (IOException e) { log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); } if (token == null) { log.error("获取用户accessToken失败。"); return null; } return token; } /** * 获取WechatUser实体类 * @param accessToken * @param openId * @return */ public static WechatUser getUserInfo(String accessToken, String openId) { // 根据传入的accessToken以及openId拼接出访问微信定义的端口并获取用户信息的URL String url = "https://api.weixin.qq.com/sns/userinfo?access_token=" + accessToken + "&amp;openid=" + openId + "&amp;lang=zh_CN"; // 访问该URL获取用户信息json 字符串 String userStr = httpsRequest(url, "GET", null); log.debug("user info :" + userStr); WechatUser user = new WechatUser(); ObjectMapper objectMapper = new ObjectMapper(); try { // 将json字符串转换成相应对象 user = objectMapper.readValue(userStr, WechatUser.class); } catch (JsonParseException e) { log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); } catch (JsonMappingException e) { log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); } catch (IOException e) { log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); } if (user == null) { log.error("获取用户信息失败。"); return null; } return user; } /** * 发起https请求并获取结果 * @param requestUrl * 请求地址 * @param requestMethod * 请求方式（GET、POST） * @param outputStr * 提交的数据 * @return json字符串 */ public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) { StringBuffer buffer = new StringBuffer(); try { // 创建SSLContext对象，并使用我们指定的信任管理器初始化 TrustManager[] tm = { new MyX509TrustManager() }; SSLContext sslContext = SSLContext.getInstance("SSL", "SunJSSE"); sslContext.init(null, tm, new java.security.SecureRandom()); // 从上述SSLContext对象中得到SSLSocketFactory对象 SSLSocketFactory ssf = sslContext.getSocketFactory(); URL url = new URL(requestUrl); HttpsURLConnection httpUrlConn = (HttpsURLConnection) url.openConnection(); httpUrlConn.setSSLSocketFactory(ssf); httpUrlConn.setDoOutput(true); httpUrlConn.setDoInput(true); httpUrlConn.setUseCaches(false); // 设置请求方式（GET/POST） httpUrlConn.setRequestMethod(requestMethod); if ("GET".equalsIgnoreCase(requestMethod)) httpUrlConn.connect(); // 当有数据需要提交时 if (null != outputStr) { OutputStream outputStream = httpUrlConn.getOutputStream(); // 注意编码格式，防止中文乱码 outputStream.write(outputStr.getBytes("UTF-8")); outputStream.close(); } // 将返回的输入流转换成字符串 InputStream inputStream = httpUrlConn.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream, "utf-8"); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String str = null; while ((str = bufferedReader.readLine()) != null) { buffer.append(str); } bufferedReader.close(); inputStreamReader.close(); // 释放资源 inputStream.close(); inputStream = null; httpUrlConn.disconnect(); log.debug("https buffer:" + buffer.toString()); } catch (ConnectException ce) { log.error("Weixin server connection timed out."); } catch (Exception e) { log.error("https request error:{}", e); } return buffer.toString(); } } 【MyX509TrustManager】主要继承X509TrustManager做https证书信任管理器 /** * 证书信任管理器（用于https请求） * */ public class MyX509TrustManager implements X509TrustManager { public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { } public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { } public X509Certificate[] getAcceptedIssuers() { return null; } } 之后重新打包一个新的war包并发布到服务器tomcat webapps目录下发布成功后，关注你自己的测试号(即扫描测试号的那个二维码)，然后在手机微信里面或者微信开发者工具里访问相应链接：https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appId&amp;redirect_uri=WechatLoginController对应的地址&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>微信公众号开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下使用crontab如何实现mysql数据库每天自动备份定时备份]]></title>
    <url>%2Flinux%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%8F%E5%A4%A9%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%EF%BC%8C%E5%B9%B6%E5%8F%AA%E4%BF%9D%E7%95%99%E8%BF%917%E5%A4%A9%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[1. 编辑shell脚本 (备份&amp;清理)#!/bin/bash #在此设置要备份的数据库名,以TEST为例 DBNAME="TEST" #备份数据临时存放位置,备份完成之后自动删除. BACKDIR="/home/root/backup/" #获取系统时间 DATE=`date +%Y%m%d` #备份文件名以时间命名 FILENAME=dump_${DATE}.sql #进入备份目录 cd ${BACKDIR} #备份数据库并追加日志 mysqldump -uroot -proot --databases TEST > ${BACKDIR}${FILENAME} >> db_backup.log #删除近7天文件 find ${BACKDIR} -mtime +7 -name "*.sql" -exec rm -rf {} \; 2. 将脚本加入crontab自动执行计划添加计划 crontab -e 加入一行: #每天晚上11点半, 执行对应路径下的脚本. 30 23 * * * /home/root/backup.sh 保存退出(vim命令) 3. Cron 各项的描述以下是 crontab 文件的格式： {minute} {hour} {day-of-month} {month} {day-of-week} {full-path-to-shell-script}minute: 区间为 0 – 59hour: 区间为0 – 23day-of-month: 区间为0 – 31month: 区间为1 – 12. 1 是1月. 12是12月.Day-of-week: 区间为0 – 7. 周日可以是0或7. 4.Crontab 示例 在 12:01 a.m 运行，即每天凌晨过一分钟。这是一个恰当的进行备份的时间，因为此时系统负载不大。 1 0 * * * /root/bin/backup.sh 每个工作日(Mon – Fri) 11:59 p.m 都进行备份作业。 59 11 * * 1,2,3,4,5 /root/bin/backup.sh #或者59 11 * * 1-5 /root/bin/backup.sh效果一样 每5分钟运行一次命令 */5 * * * * /root/bin/check-status.sh 每个月的第一天 1:10 p.m 运行 10 13 1 * * /root/bin/full-backup.sh 每个工作日 11 p.m 运行。 0 23 * * 1-5 /root/bin/incremental-backup.sh 5. crontab常用的命令service crond start //启动服务 service crond stop //关闭服务 service crond restart //重启服务 service crond reload //重新载入配置 service crond status //查看服务状态 crontab –e //往 cron 中添加一个作业 crontab –e //修改 crontab 文件. 如果文件不存在会自动创建。 crontab –l //显示 crontab 文件。 crontab -r //删除 crontab 文件。 crontab -ir //删除 crontab 文件前提醒用户]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对项目中关键的配置信息进行加密]]></title>
    <url>%2F%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B3%E9%94%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86.html</url>
    <content type="text"><![CDATA[我们在搭键一个项目的时候，有一些信息，比如数据库的连接信息通常会放在一个配置文件中，存放的是明码，我们可以对关键信息比如用户名和密码进行加密，就算别人获取了也没有用 加密后的效果 db.username = WnplV/ietfQ= db.password = j9ZTgFZm4H7r0AteGA6A7A== db.driver = com.mysql.jdbc.Driver db.url = jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf8 一、首先创建一个加密的工具类，对信息进行加密我用的是DES对称加密 package com.edward.o2o.util; import java.security.Key; import java.security.SecureRandom; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; public class DESUtils { private static Key key; private static String KEY_STR = "myKey"; private static String CHARSETNAME = "UTF-8"; private static String ALGORITHM = "DES"; static { try { KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM); SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG"); secureRandom.setSeed(KEY_STR.getBytes()); generator.init(secureRandom); key = generator.generateKey(); generator = null; } catch (Exception e) { throw new RuntimeException(e); } } public static String getEncryptString(String str) { BASE64Encoder base64encoder = new BASE64Encoder(); try { byte[] bytes = str.getBytes(CHARSETNAME); Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] doFinal = cipher.doFinal(bytes); return base64encoder.encode(doFinal); } catch (Exception e) { // TODO: handle exception throw new RuntimeException(e); } } public static String getDecryptString(String str) { BASE64Decoder base64decoder = new BASE64Decoder(); try { byte[] bytes = base64decoder.decodeBuffer(str); Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, key); byte[] doFinal = cipher.doFinal(bytes); return new String(doFinal, CHARSETNAME); } catch (Exception e) { // TODO: handle exception throw new RuntimeException(e); } } public static void main(String[] args) { System.out.println(getEncryptString("root")); System.out.println(getEncryptString("123456abCD.")); System.out.println(getEncryptString("wxd7f6c5b8899fba83")); System.out.println(getEncryptString("665ae80dba31fc91ab6191e7da4d676d")); } } 通过main方法，把要加密的信息输出到控制台得到密文,再把对应的明文换成加密后的密文 二、创建一个PropertyPlaceholderConfigurer的后置处理器，在spring中解析配置文件package com.edward.o2o.util; import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer; public class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer { private String[] encryptPropNames = { "db.username", "db.password" }; @Override protected String convertProperty(String propertyName, String propertyValue) { if (isEncryptProp(propertyName)) { String decryptValue = DESUtils.getDecryptString(propertyValue); return decryptValue; } else { return propertyValue; } } private boolean isEncryptProp(String propertyName) { for (String encryptpropertyName : encryptPropNames) { if (encryptpropertyName.equals(propertyName)) return true; } return false; } } 三、把配置文件加载到spring的配置文件中 &lt;!-- 1.配置数据库相关参数properties的属性：${url} --> &lt;!--&lt;context:property-placeholder location="classpath:db.properties"/>--> &lt;bean class="com.edward.o2o.util.EncryptPropertyPlaceholderConfigurer"> &lt;property name="locations"> &lt;list> &lt;value>classpath:db.properties&lt;/value> &lt;/list> &lt;/property> &lt;property name="fileEncoding" value="UTF-8" /> &lt;/bean> class就是第二步中用于解析配置文件的类 总结： 整个过程就是利用加密的工具类对关键信息加密把原文替换成密文，然后在spring的配置文件中加载需要的配置文件（比如数据库的配置文件），加载过程中PropertyPlaceholderConfigurer后置处理器会调用加密工具类中的解密文件返回明文 PropertyPlaceholderConfigurer是个bean工厂后置处理器的实现，也就是 BeanFactoryPostProcessor接口的一个实现。PropertyPlaceholderConfigurer可以将上下文（配置文 件）中的属性值放在另一个单独的标准java Properties文件中去。在XML文件中用${key}替换指定的properties文件中的值。这样的话，只需要对properties文件进 行修改，而不用对xml配置文件进行修改。]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合逐层配置]]></title>
    <url>%2FSSM%E6%95%B4%E5%90%88%E9%80%90%E5%B1%82%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[使用SSM（Spring、SpringMVC和Mybatis）已经有三个多月了，项目在技术上已经没有什么难点了，基于现有的技术就可以实现想要的功能，当然肯定有很多可以改进的地方。之前没有记录SSM整合的过程，这次刚刚好基于自己的一个小项目重新搭建了一次，而且比项目搭建的要更好一些。以前解决问题的过程和方法并没有及时记录，以后在自己的小项目中遇到我再整理分享一下。这次，先说说三大框架整合过程。个人认为使用框架并不是很难，关键要理解其思想，这对于我们提高编程水平很有帮助。不过，如果用都不会，谈思想就变成纸上谈兵了！！！先技术，再思想。实践出真知。 一、Dao层配置1.spring-dao.xml&lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> &lt;!-- 1.配置数据库相关参数properties的属性：${url} --> &lt;context:property-placeholder location="classpath:db.properties"/> &lt;!-- 2.数据库连接池 --> &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"> &lt;!-- 配置连接池属性 --> &lt;property name="driverClass" value="${db.driver}" /> &lt;property name="jdbcUrl" value="${db.url}" /> &lt;property name="user" value="${db.username}" /> &lt;property name="password" value="${db.password}" /> &lt;!-- c3p0连接池的私有属性 --> &lt;property name="maxPoolSize" value="30" /> &lt;property name="minPoolSize" value="10" /> &lt;!-- 关闭连接后不自动commit --> &lt;property name="autoCommitOnClose" value="false" /> &lt;!-- 获取连接超时时间 --> &lt;property name="checkoutTimeout" value="10000" /> &lt;!-- 当获取连接失败重试次数 --> &lt;property name="acquireRetryAttempts" value="2" /> &lt;/bean> &lt;!-- 3.配置SqlSessionFactory对象 --> &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"> &lt;!-- 注入数据库连接池 --> &lt;property name="dataSource" ref="dataSource" /> &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --> &lt;property name="configLocation" value="classpath:mybatis-config.xml" /> &lt;!-- 扫描entity包 使用别名 --> &lt;property name="typeAliasesPackage" value="com.edward.o2o.entity" /> &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --> &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /> &lt;/bean> &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --> &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"> &lt;!-- 注入sqlSessionFactory --> &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /> &lt;!-- 给出需要扫描Dao接口包 --> &lt;property name="basePackage" value="com.edward.o2o.dao" /> &lt;/bean> &lt;/beans> 2.db.propertiesdb.username = root db.password = 123456abcd db.driver = com.mysql.jdbc.Driver db.url = jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf8 3.mybatis-config.xml&lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> &lt;configuration> &lt;!-- 配置全局属性 --> &lt;settings> &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --> &lt;setting name="useGeneratedKeys" value="true" /> &lt;!-- 使用列别名替换列名 默认:true --> &lt;setting name="useColumnLabel" value="true" /> &lt;!-- 开启驼峰命名转换:Table{create_time} -> Entity{createTime} --> &lt;setting name="mapUnderscoreToCamelCase" value="true" /> &lt;!-- 打印查询语句 --> &lt;setting name="logImpl" value="STDOUT_LOGGING" /> &lt;/settings> &lt;/configuration> 二、service层配置spring-service.xml&lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"> &lt;!-- 扫描service包下所有使用注解的类型 --> &lt;context:component-scan base-package="com.edward.o2o.service" /> &lt;!-- 配置事务管理器 --> &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> &lt;!-- 注入数据库连接池 --> &lt;property name="dataSource" ref="dataSource" /> &lt;/bean> &lt;!-- 配置基于注解的声明式事务 --> &lt;tx:annotation-driven transaction-manager="transactionManager" /> &lt;/beans> 三、web层配置spring-web.xml&lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> &lt;!-- 配置SpringMVC --> &lt;!-- 1.开启SpringMVC注解模式 --> &lt;!-- 简化配置： (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 --> &lt;mvc:annotation-driven > &lt;!-- 消息转换器 --> &lt;mvc:message-converters register-defaults="true"> &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"> &lt;property name="supportedMediaTypes" value="text/html;charset=UTF-8"/> &lt;/bean> &lt;/mvc:message-converters> &lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用"/"做整体映射 --> &lt;mvc:resources mapping="/resources/**" location="/resources/" /> &lt;mvc:default-servlet-handler /> &lt;!-- 3.定义视图解析器 --> &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"> &lt;property name="prefix" value="/WEB-INF/html/">&lt;/property> &lt;property name="suffix" value=".html">&lt;/property> &lt;/bean> &lt;!-- 4.扫描web相关的bean --> &lt;context:component-scan base-package="com.edward.o2o.web" /> &lt;/beans> 四、最后配置web.xml&lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"> &lt;filter> &lt;filter-name>SpringEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;init-param> &lt;param-name>forceEncoding&lt;/param-name> &lt;param-value>true&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>SpringEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;!-- 配置DispatcherServlet --> &lt;servlet> &lt;servlet-name>seckill-dispatcher&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - > spring -> springmvc --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring/spring-*.xml&lt;/param-value> &lt;/init-param> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>seckill-dispatcher&lt;/servlet-name> &lt;!-- 默认匹配所有的请求 --> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app>]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot 2.1.3配置Druid数据源]]></title>
    <url>%2Fspring-boot%202.1.3%E9%85%8D%E7%BD%AEDruid%E6%95%B0%E6%8D%AE%E6%BA%90.html</url>
    <content type="text"><![CDATA[1.在pom文件添加依赖 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.1.10&lt;/version> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/log4j/log4j yml配置文件中filters: stat,wall,log4j所以要加此依赖，否侧会报错--> &lt;dependency> &lt;groupId>log4j&lt;/groupId> &lt;artifactId>log4j&lt;/artifactId> &lt;version>1.2.17&lt;/version> &lt;/dependency> 2.在配置文件中配置数据库信息 spring: datasource: # 数据源基本配置 username: root password: 123456abcd driver-class-name: com.mysql.cj.jdbc.Driver #注意要配置serverTimezone等信息 url: jdbc:mysql://localhost:3306/books?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 3.添加Druid的配置类 package com.edward.springbootmybaties.config; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.support.http.StatViewServlet; import com.alibaba.druid.support.http.WebStatFilter; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; import java.util.Arrays; import java.util.HashMap; import java.util.Map; @Configuration public class DruidConfig { @Bean //这样yml配置文件才会起作用，和Druid类绑定起来 @ConfigurationProperties(prefix = "spring.datasource") public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String> initParams = new HashMap&lt;>(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String> initParams = new HashMap&lt;>(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; } }]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何上传项目到github]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0github%E4%B8%8A.html</url>
    <content type="text"><![CDATA[在github上创建一个仓库 打开git软件3.进入项目的目录在windows资源管理器中右击Git Bash Here直接进入 第一步： 输入git init，输入后 项目文件夹下多了一个.git文件第二步：输入git add .，add后面的点代表上传所有文件，如果想上传单个文件可以把点换成你想上传的文件第四步输入git commit -m “first commit” 双引号内的内容可以自己写 这里如果出现以下内容，则需要你输入自己的账号或名字第五步输入git remote add origin 自己的地址（上面有说到） 将本地的仓库关联到github上 最后 输入git push -u origin master，这是把代码上传到github仓库的意思。]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从原码的角度分析springsecurity登录过程]]></title>
    <url>%2F%E4%BB%8E%E5%8E%9F%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90springsecurity%E7%99%BB%E5%BD%95%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[当我们要访问我们的一些资源时，要先执行 一些过滤器，spring security就只通过下图所示的过滤器链实现的当在项目中添加了springsecurity的依赖后，springboot就会自动的把这些filter添加进去，上图中绿色的过滤器是可以自己配置的（usernamepasswordfilter就是表单登录的过滤器），蓝色和橙色的过滤器是必须执行的 我们来看一下实现登录验证的usernamepasswordfilte是如何工作的首先会进入usernamepasswordfilte（未认证的authentication）然后进入ProviderManager寻找合适的provider并调用provider.authenticate(authentication);再然后就是UserDetailsService接口的实现类，最后回到UsernamePasswordAuthenticationFilter，最后就得到一个认证的authentication UsernamePasswordAuthenticationFilter.java // 继承了AbstractAuthenticationProcessingFilter public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter { public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { // 认证请求的方式必须为POST if (postOnly &amp;&amp; !request.getMethod().equals("POST")) { throw new AuthenticationServiceException( "Authentication method not supported: " + request.getMethod()); } // 获取用户名 String username = obtainUsername(request); // 获取密码 String password = obtainPassword(request); if (username == null) { username = ""; } if (password == null) { password = ""; } // 用户名去空白 username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); // Allow subclasses to set the "details" property setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); } } AbstractAuthenticationProcessingFilter.java public abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean implements ApplicationEventPublisherAware, MessageSourceAware { // 过滤器doFilter方法 public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; /* * 判断当前filter是否可以处理当前请求，若不行，则交给下一个filter去处理。 */ if (!requiresAuthentication(request, response)) { chain.doFilter(request, response); return; } if (logger.isDebugEnabled()) { logger.debug("Request is to process authentication"); } Authentication authResult; try { // 很关键！！！调用了子类（UsernamePasswordAuthenticationFilter）的方法 authResult = attemptAuthentication(request, response); if (authResult == null) { // return immediately as subclass has indicated that it hasn't completed // authentication return; } // 最终认证成功后，会处理一些与session相关的方法（比如将认证信息存到session等操作）。 sessionStrategy.onAuthentication(authResult, request, response); } catch (InternalAuthenticationServiceException failed) { logger.error( "An internal error occurred while trying to authenticate the user.", failed); // 认证失败后的一些处理。 unsuccessfulAuthentication(request, response, failed); return; } catch (AuthenticationException failed) { // Authentication failed unsuccessfulAuthentication(request, response, failed); return; } // Authentication success if (continueChainBeforeSuccessfulAuthentication) { chain.doFilter(request, response); } /* * 最终认证成功后的相关回调方法，主要将当前的认证信息放到SecurityContextHolder中 * 并调用成功处理器做相应的操作。 */ successfulAuthentication(request, response, chain, authResult); } } UsernamePasswordAuthenticationFilter继承了AbstractAuthenticationProcessingFilter，会先执行父类AbstractAuthenticationProcessingFilter，我们主要看dofilter（）方法处理流程就是1.首先判断当前filter是否可以处理当前请求，若不行，则交给下一个filter去处理。 // 判断当前filter是否可以处理当前请求，若不行，则交给下一个filter去处理 if (!requiresAuthentication(request, response)) { chain.doFilter(request, response); return; } 2.调用了子类UsernamePasswordAuthenticationFilter的attemptAuthentication(request, response)方法 authResult = attemptAuthentication(request, response); 3.对认证的结果进行处理 // 最终认证成功后，会处理一些与session相关的方法（比如将认证信息存到session等操作）。 sessionStrategy.onAuthentication(authResult, request, response); } catch (InternalAuthenticationServiceException failed) { logger.error( "An internal error occurred while trying to authenticate the user.", failed); // 认证失败后的一些处理。 unsuccessfulAuthentication(request, response, failed); return; } catch (AuthenticationException failed) { // Authentication failed unsuccessfulAuthentication(request, response, failed); return; } // Authentication success if (continueChainBeforeSuccessfulAuthentication) { chain.doFilter(request, response); } /* * 最终认证成功后的相关回调方法，主要将当前的认证信息放到SecurityContextHolder中 * 并调用成功处理器做相应的操作。 */ successfulAuthentication(request, response, chain, authResult); } } 子类UsernamePasswordAuthenticationFilter的处理流程是 1.检查请求方式是不是POST方式 // 认证请求的方式必须为POST if (postOnly &amp;&amp; !request.getMethod().equals("POST")) { throw new AuthenticationServiceException( "Authentication method not supported: " + request.getMethod()); } 2.获得用户名和密码，对用户名和密码进行处理 String username = obtainUsername(request); String password = obtainPassword(request); if (username == null) { username = ""; } if (password == null) { password = ""; } username = username.trim(); 3.封装成UsernamePasswordAuthenticationToken,因为此时还没有认证，所以没有权限，false未认证 UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); /*public UsernamePasswordAuthenticationToken(Object principal, Object credentials) { super(null); this.principal = principal; this.credentials = credentials; setAuthenticated(false); }*/ 4.最后重要一步，进行认证 return this.getAuthenticationManager().authenticate(authRequest); 调用的是由ProviderManager的authenticate方法,因为ProviderManager实现了AuthenticationManager public class ProviderManager implements AuthenticationManager, MessageSourceAware, InitializingBean { public Authentication authenticate(Authentication authentication) throws AuthenticationException { Class&lt;? extends Authentication> toTest = authentication.getClass(); AuthenticationException lastException = null; Authentication result = null; boolean debug = logger.isDebugEnabled(); for (AuthenticationProvider provider : getProviders()) { if (!provider.supports(toTest)) { continue; } if (debug) { logger.debug("Authentication attempt using " + provider.getClass().getName()); } try { result = provider.authenticate(authentication); if (result != null) { copyDetails(authentication, result); break; } } catch (AccountStatusException e) { prepareException(e, authentication); // SEC-546: Avoid polling additional providers if auth failure is due to // invalid account status throw e; } catch (InternalAuthenticationServiceException e) { prepareException(e, authentication); throw e; } catch (AuthenticationException e) { lastException = e; } } if (result == null &amp;&amp; parent != null) { // Allow the parent to try. try { result = parent.authenticate(authentication); } catch (ProviderNotFoundException e) { // ignore as we will throw below if no other exception occurred prior to // calling parent and the parent // may throw ProviderNotFound even though a provider in the child already // handled the request } catch (AuthenticationException e) { lastException = e; } } if (result != null) { if (eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) { // Authentication is complete. Remove credentials and other secret data // from authentication ((CredentialsContainer) result).eraseCredentials(); } eventPublisher.publishAuthenticationSuccess(result); return result; } // Parent was null, or didn't authenticate (or throw an exception). if (lastException == null) { lastException = new ProviderNotFoundException(messages.getMessage( "ProviderManager.providerNotFound", new Object[] { toTest.getName() }, "No AuthenticationProvider found for {0}")); } prepareException(lastException, authentication); throw lastException; } ProviderManager的处理流程是1.遍历所有的provider，看是否支持当前的Authentication for (AuthenticationProvider provider : getProviders()) { if (!provider.supports(toTest)) { continue; } } 2.如何找到了合适的provider，就调用provider.authenticate(authentication) try { result = provider.authenticate(authentication); if (result != null) { copyDetails(authentication, result); break; } } result = provider.authenticate(authentication);这一步是调用了DaoAuthenticationProvider的retrieveUser方法 protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { UserDetails loadedUser; try { loadedUser = this.getUserDetailsService().loadUserByUsername(username); } catch (UsernameNotFoundException notFound) { if (authentication.getCredentials() != null) { String presentedPassword = authentication.getCredentials().toString(); passwordEncoder.isPasswordValid(userNotFoundEncodedPassword, presentedPassword, null); } throw notFound; } catch (Exception repositoryProblem) { throw new InternalAuthenticationServiceException( repositoryProblem.getMessage(), repositoryProblem); } if (loadedUser == null) { throw new InternalAuthenticationServiceException( "UserDetailsService returned null, which is an interface contract violation"); } return loadedUser; } retrieveUser中最关键的loadedUser=this.getUserDetailsService().loadUserByUsername(username);这一步就是在调用我们自己的业务代码比如： @Service public class UserServiceImpl implements UserService, UserDetailsService { @Autowired private UserRepository userRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException{ return userRepository.findByUsername(username); } } 类之间的调用顺序 UsernamePasswordAuthenticationFilter Authentication AuthenticationManager AuthenticationProvider UserDetailsService // 回到起点进行后续操作，比如缓存认证信息到session和调用成功后的处理器等等 UsernamePasswordAuthenticationFilter 疑问： 1、接口login在哪定义的？ SpringSecurity内置的，并且只能为POST public UsernamePasswordAuthenticationFilter() { super(new AntPathRequestMatcher("/login", "POST")); } 2、用户名username和密码password在哪接收的？ 名称不能变，必须是username和password public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter { // ~ Static fields/initializers // ===================================================================================== public static final String SPRING_SECURITY_FORM_USERNAME_KEY = "username"; public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = "password"; } 参考文章https://www.jianshu.com/p/a65f883de0c1]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 学习笔记]]></title>
    <url>%2FSpring%20Boot%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 &lt;profile> &lt;id>jdk-1.8&lt;/id> &lt;activation> &lt;activeByDefault>true&lt;/activeByDefault> &lt;jdk>1.8&lt;/jdk> &lt;/activation> &lt;properties> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;maven.compiler.compilerVersion>1.8&lt;/maven.compiler.compilerVersion> &lt;/properties> &lt;/profile> 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖 &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>1.5.9.RELEASE&lt;/version> &lt;/parent> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;/dependencies> 3、编写一个主程序；启动Spring Boot应用 /** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */ @SpringBootApplication public class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); } } 4、编写相关的Controller、Service@Controller public class HelloController { @ResponseBody @RequestMapping("/hello") public String hello(){ return "Hello World!"; } } 5、运行主程序测试6、简化部署 &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目&lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>1.5.9.RELEASE&lt;/version> &lt;/parent> 他的父项目是 &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-dependencies&lt;/artifactId> &lt;version>1.5.9.RELEASE&lt;/version> &lt;relativePath>../../spring-boot-dependencies&lt;/relativePath> &lt;/parent> 他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */ @SpringBootApplication public class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); } } @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； @AutoConfigurationPackage @Import(EnableAutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 server: port: 8081 ​ XML： &lt;server> &lt;port>8081&lt;/port> &lt;/server> 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 friends: lastName: zhangsan age: 20 行内写法： friends: {lastName: zhangsan,age: 18} 数组（List、Set）：用- 值表示数组中的一个元素 pets: - cat - dog - pig 行内写法 pets: [cat,dog,pig] 3、配置文件值注入配置文件 person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: {k1: v1,k2: 12} lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： /** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */ @Component @ConfigurationProperties(prefix = "person") public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object> maps; private List&lt;Object> lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 &lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-configuration-processor&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验@Component @ConfigurationProperties(prefix = "person") @Validated public class Person { /** * &lt;bean class="Person"> * &lt;property name="lastName" value="字面量/${key}从环境变量、配置文件中获取值/#{SpEL}">&lt;/property> * &lt;bean/> */ //lastName必须是邮箱格式 @Email //@Value("${person.last-name}") private String lastName; //@Value("#{11*2}") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object> maps; private List&lt;Object> lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； /** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */ @PropertySource(value = {"classpath:person.properties"}) @Component @ConfigurationProperties(prefix = "person") //@Validated public class Person { /** * &lt;bean class="Person"> * &lt;property name="lastName" value="字面量/${key}从环境变量、配置文件中获取值/#{SpEL}">&lt;/property> * &lt;bean/> */ //lastName必须是邮箱格式 // @Email //@Value("${person.last-name}") private String lastName; //@Value("#{11*2}") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 @ImportResource(locations = {"classpath:beans.xml"}) 导入Spring的配置文件让其生效 不来编写Spring的配置文件 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService">&lt;/bean> &lt;/beans> SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 /** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean>&lt;bean/>标签添加组件 * */ @Configuration public class MyAppConfig { //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02(){ System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); } } ##4、配置文件占位符 1、随机数${random.value}、${random.int}、${random.long} ${random.int(10)}、${random.int[1024,65536]} 2、占位符获取之前配置的值，如果没有可以是用:指定默认值person.last-name=张三${random.uuid} person.age=${random.int} person.birth=2017/12/15 person.boss=false person.maps.k1=v1 person.maps.k2=14 person.lists=a,b,c person.dog.name=${person.hello:hello}_dog person.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式 server: port: 8081 spring: profiles: active: prod --- server: port: 8083 spring: profiles: dev --- server: port: 8084 spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 SpringFactoriesLoader.loadFactoryNames() 扫描所有jar包类路径下 META-INF/spring.factories 把扫描到的这些文件的内容包装成properties对象 从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\ org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\ org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\ org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\ org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\ org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\ org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\ org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\ org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\ org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\ org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\ org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\ org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\ org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\ org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\ org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\ org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\ org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\ org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\ org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\ org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\ org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\ org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\ org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\ org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\ org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\ org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\ org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\ org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\ org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\ org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\ org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\ org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\ org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\ org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\ org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\ org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\ org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\ org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\ org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\ org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\ org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\ org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\ org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\ org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\ org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\ org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\ org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\ org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\ org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\ org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\ org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\ org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\ org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\ org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\ org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\ org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\ org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\ org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\ org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\ org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\ org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\ org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\ org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； @Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件 @EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中 @ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效 @ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器； @ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的； public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) { this.properties = properties; } @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; } 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 @ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定 public class HttpEncodingProperties { public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； ========================= AUTO-CONFIGURATION REPORT ========================= Positive matches:（自动配置类启用的） ----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类） ----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); } } 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;/dependency> SpringBoot使用它来做日志功能； &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-logging&lt;/artifactId> &lt;/dependency> 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ @SuppressWarnings("rawtypes") public abstract class LogFactory { static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-core&lt;/artifactId> &lt;exclusions> &lt;exclusion> &lt;groupId>commons-logging&lt;/groupId> &lt;artifactId>commons-logging&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； //记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() { //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志..."); } 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 logging.level.com.atguigu=trace #logging.path= # 不指定路径在当前项目下生成springboot.log日志 # 可以指定完整的路径； #logging.file=G:/springboot.log # 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件 logging.path=/spring/log # 在控制台输出的日志的格式 logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n # 指定文件中日志输出的格式 logging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 &lt;springProfile name="staging"> &lt;!-- configuration to be enabled when the "staging" profile is active --> 可以指定某段配置只在某个环境下生效 &lt;/springProfile> 如： &lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"> &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --> &lt;layout class="ch.qos.logback.classic.PatternLayout"> &lt;springProfile name="dev"> &lt;pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ----> [%thread] ---> %-5level %logger{50} - %msg%n&lt;/pattern> &lt;/springProfile> &lt;springProfile name="!dev"> &lt;pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n&lt;/pattern> &lt;/springProfile> &lt;/layout> &lt;/appender> 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;exclusions> &lt;exclusion> &lt;artifactId>logback-classic&lt;/artifactId> &lt;groupId>ch.qos.logback&lt;/groupId> &lt;/exclusion> &lt;exclusion> &lt;artifactId>log4j-over-slf4j&lt;/artifactId> &lt;groupId>org.slf4j&lt;/groupId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.slf4j&lt;/groupId> &lt;artifactId>slf4j-log4j12&lt;/artifactId> &lt;/dependency> 切换为log4j2 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;exclusions> &lt;exclusion> &lt;artifactId>spring-boot-starter-logging&lt;/artifactId> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-log4j2&lt;/artifactId> &lt;/dependency> 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx xxxxAutoConfiguration：帮我们给容器中自动配置组件； xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false) public class ResourceProperties implements ResourceLoaderAware { //可以设置和静态资源有关的参数，缓存时间等 WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug("Default resource handling disabled"); return; } Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) { customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); } } //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) { return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); } //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration { private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) { this.resourceProperties = resourceProperties; } @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() { SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; } @Bean public ResourceHttpRequestHandler faviconRequestHandler() { ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; } } ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js &lt;!--引入jquery-webjar-->在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency> &lt;groupId>org.webjars&lt;/groupId> &lt;artifactId>jquery&lt;/artifactId> &lt;version>3.3.1&lt;/version> &lt;/dependency> ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf； &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> 2.1.6 &lt;/dependency> 切换thymeleaf版本 &lt;properties> &lt;thymeleaf.version>3.0.9.RELEASE&lt;/thymeleaf.version> &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --> &lt;!-- thymeleaf2 layout1--> &lt;thymeleaf-layout-dialect.version>2.2.2&lt;/thymeleaf-layout-dialect.version> &lt;/properties> 2、Thymeleaf使用@ConfigurationProperties(prefix = "spring.thymeleaf") public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 &lt;html lang="en" xmlns:th="http://www.thymeleaf.org"> 2、使用thymeleaf语法； &lt;!DOCTYPE html> &lt;html lang="en" xmlns:th="http://www.thymeleaf.org"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Title&lt;/title> &lt;/head> &lt;body> &lt;h1>成功！&lt;/h1> &lt;!--th:text 将div里面的文本内容设置为 --> &lt;div th:text="${hello}">这是显示欢迎信息&lt;/div> &lt;/body> &lt;/html> 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ Simple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. ${session.foo} 3）、内置的一些工具对象： #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； 补充：配合 th:object="${session.user}： &lt;div th:object="${session.user}"> &lt;p>Name: &lt;span th:text="*{firstName}">Sebastian&lt;/span>.&lt;/p> &lt;p>Surname: &lt;span th:text="*{lastName}">Pepper&lt;/span>.&lt;/p> &lt;p>Nationality: &lt;span th:text="*{nationality}">Saturn&lt;/span>.&lt;/p> &lt;/div> Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； @{/order/process(execId=${execId},execType='FAST')} Fragment Expressions: ~{...}：片段引用表达式 &lt;div th:insert="~{commons :: main}">...&lt;/div> Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: > , &lt; , >= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； @Bean @ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则 public Formatter&lt;Date> dateFormatter() { return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件 } ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 初始化WebDataBinder； 请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC &lt;mvc:view-controller path="/hello" view-name="success"/> &lt;mvc:interceptors> &lt;mvc:interceptor> &lt;mvc:mapping path="/hello"/> &lt;bean>&lt;/bean> &lt;/mvc:interceptor> &lt;/mvc:interceptors> ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； //使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能 @Configuration public class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); } } 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) @Configuration public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer> configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) { // for (WebMvcConfigurer delegate : this.delegates) { // delegate.addViewControllers(registry); // } } } } ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； //使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能 @EnableWebMvc @Configuration public class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); } } 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 @Import(DelegatingWebMvcConfiguration.class) public @interface EnableWebMvc { 2）、 @Configuration public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { 3）、 @Configuration @ConditionalOnWebApplication @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class }) //容器中没有这个组件的时候，这个自动配置类才生效 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10) @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class }) public class WebMvcAutoConfiguration { 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页 //使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能 //@EnableWebMvc 不要接管SpringMVC @Configuration public class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); } //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); } }; return adapter; } } 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； @ConfigurationProperties(prefix = "spring.messages") public class MessageSourceAutoConfiguration { /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) { //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); } if (this.encoding != null) { messageSource.setDefaultEncoding(this.encoding.name()); } messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; } 3）、去页面获取国际化的值； &lt;!DOCTYPE html> &lt;html lang="en" xmlns:th="http://www.thymeleaf.org"> &lt;head> &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> &lt;meta name="description" content=""> &lt;meta name="author" content=""> &lt;title>Signin Template for Bootstrap&lt;/title> &lt;!-- Bootstrap core CSS --> &lt;link href="asserts/css/bootstrap.min.css" th:href="@{/webjars/bootstrap/4.0.0/css/bootstrap.css}" rel="stylesheet"> &lt;!-- Custom styles for this template --> &lt;link href="asserts/css/signin.css" th:href="@{/asserts/css/signin.css}" rel="stylesheet"> &lt;/head> &lt;body class="text-center"> &lt;form class="form-signin" action="dashboard.html"> &lt;img class="mb-4" th:src="@{/asserts/img/bootstrap-solid.svg}" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"> &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">Please sign in&lt;/h1> &lt;label class="sr-only" th:text="#{login.username}">Username&lt;/label> &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#{login.username}" required="" autofocus=""> &lt;label class="sr-only" th:text="#{login.password}">Password&lt;/label> &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#{login.password}" required=""> &lt;div class="checkbox mb-3"> &lt;label> &lt;input type="checkbox" value="remember-me"/> [[#{login.remember}]] &lt;/label> &lt;/div> &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#{login.btn}">Sign in&lt;/button> &lt;p class="mt-5 mb-3 text-muted">© 2017-2018&lt;/p> &lt;a class="btn btn-sm">中文&lt;/a> &lt;a class="btn btn-sm">English&lt;/a> &lt;/form> &lt;/body> &lt;/html> 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() { if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; } 默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 /** * 可以在连接上携带区域信息 */ public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest request) { String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l)){ String[] split = l.split("_"); locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { } } @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } } 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 # 禁用缓存 spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 &lt;p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}">&lt;/p> 4）、拦截器进行登陆检查拦截器 /** * 登陆检查， */ public class LoginHandlerInterceptor implements HandlerInterceptor { //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object user = request.getSession().getAttribute("loginUser"); if(user == null){ //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; }else{ //已登陆，放行请求 return true; } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 注册拦截器 //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); } //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); } }; return adapter; } 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取1、抽取公共片段 &lt;div th:fragment="copy"> &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/div> 2、引入公共片段 &lt;div th:insert="~{footer :: copy}">&lt;/div> ~{templatename::selector}：模板名::选择器 ~{templatename::fragmentname}:模板名::片段名 3、默认效果： insert的公共片段在div标签中 如果使用th:insert等属性进行引入，可以不用写~{}： 行内写法可以加上：[[~{}]];[(~{})]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 &lt;footer th:fragment="copy"> &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer> 引入方式 &lt;div th:insert="footer :: copy">&lt;/div> &lt;div th:replace="footer :: copy">&lt;/div> &lt;div th:include="footer :: copy">&lt;/div> 效果 &lt;div> &lt;footer> &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer> &lt;/div> &lt;footer> &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer> &lt;div> &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/div> 引入片段的时候传入参数： &lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"> &lt;div class="sidebar-sticky"> &lt;ul class="nav flex-column"> &lt;li class="nav-item"> &lt;a class="nav-link active" th:class="${activeUri=='main.html'?'nav-link active':'nav-link'}" href="#" th:href="@{/main.html}"> &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"> &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z">&lt;/path> &lt;polyline points="9 22 9 12 15 12 15 22">&lt;/polyline> &lt;/svg> Dashboard &lt;span class="sr-only">(current)&lt;/span> &lt;/a> &lt;/li> &lt;!--引入侧边栏;传入参数--> &lt;div th:replace="commons/bar::#sidebar(activeUri='emps')">&lt;/div> 6）、CRUD-员工添加添加页面 &lt;form> &lt;div class="form-group"> &lt;label>LastName&lt;/label> &lt;input type="text" class="form-control" placeholder="zhangsan"> &lt;/div> &lt;div class="form-group"> &lt;label>Email&lt;/label> &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"> &lt;/div> &lt;div class="form-group"> &lt;label>Gender&lt;/label>&lt;br/> &lt;div class="form-check form-check-inline"> &lt;input class="form-check-input" type="radio" name="gender" value="1"> &lt;label class="form-check-label">男&lt;/label> &lt;/div> &lt;div class="form-check form-check-inline"> &lt;input class="form-check-input" type="radio" name="gender" value="0"> &lt;label class="form-check-label">女&lt;/label> &lt;/div> &lt;/div> &lt;div class="form-group"> &lt;label>department&lt;/label> &lt;select class="form-control"> &lt;option>1&lt;/option> &lt;option>2&lt;/option> &lt;option>3&lt;/option> &lt;option>4&lt;/option> &lt;option>5&lt;/option> &lt;/select> &lt;/div> &lt;div class="form-group"> &lt;label>Birth&lt;/label> &lt;input type="text" class="form-control" placeholder="zhangsan"> &lt;/div> &lt;button type="submit" class="btn btn-primary">添加&lt;/button> &lt;/form> 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 &lt;!--需要区分是员工修改还是添加；--> &lt;form th:action="@{/emp}" method="post"> &lt;!--发送put请求修改员工数据--> &lt;!-- 1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的） 2、页面创建一个post表单 3、创建一个input项，name="_method";值就是我们指定的请求方式 --> &lt;input type="hidden" name="_method" value="put" th:if="${emp!=null}"/> &lt;input type="hidden" name="id" th:if="${emp!=null}" th:value="${emp.id}"> &lt;div class="form-group"> &lt;label>LastName&lt;/label> &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${emp.lastName}"> &lt;/div> &lt;div class="form-group"> &lt;label>Email&lt;/label> &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="${emp!=null}?${emp.email}"> &lt;/div> &lt;div class="form-group"> &lt;label>Gender&lt;/label>&lt;br/> &lt;div class="form-check form-check-inline"> &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="${emp!=null}?${emp.gender==1}"> &lt;label class="form-check-label">男&lt;/label> &lt;/div> &lt;div class="form-check form-check-inline"> &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="${emp!=null}?${emp.gender==0}"> &lt;label class="form-check-label">女&lt;/label> &lt;/div> &lt;/div> &lt;div class="form-group"> &lt;label>department&lt;/label> &lt;!--提交的是部门的id--> &lt;select class="form-control" name="department.id"> &lt;option th:selected="${emp!=null}?${dept.id == emp.department.id}" th:value="${dept.id}" th:each="dept:${depts}" th:text="${dept.departmentName}">1&lt;/option> &lt;/select> &lt;/div> &lt;div class="form-group"> &lt;label>Birth&lt;/label> &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="${emp!=null}?${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}"> &lt;/div> &lt;button type="submit" class="btn btn-primary" th:text="${emp!=null}?'修改':'添加'">添加&lt;/button> &lt;/form> 8）、CRUD-员工删除&lt;tr th:each="emp:${emps}"> &lt;td th:text="${emp.id}">&lt;/td> &lt;td>[[${emp.lastName}]]&lt;/td> &lt;td th:text="${emp.email}">&lt;/td> &lt;td th:text="${emp.gender}==0?'女':'男'">&lt;/td> &lt;td th:text="${emp.department.departmentName}">&lt;/td> &lt;td th:text="${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}">&lt;/td> &lt;td> &lt;a class="btn btn-sm btn-primary" th:href="@{/emp/}+${emp.id}">编辑&lt;/a> &lt;button th:attr="del_uri=@{/emp/}+${emp.id}" class="btn btn-sm btn-danger deleteBtn">删除&lt;/button> &lt;/td> &lt;/tr> &lt;script> $(".deleteBtn").click(function(){ //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; }); &lt;/script> 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 帮我们在页面共享信息； @Override public Map&lt;String, Object> getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object> errorAttributes = new LinkedHashMap&lt;String, Object>(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; } ​ 2、BasicErrorController：处理默认/error请求 @Controller @RequestMapping("${server.error.path:${error.path:/error}}") public class BasicErrorController extends AbstractErrorController { @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map&lt;String, Object> model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); } @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object>> error(HttpServletRequest request) { Map&lt;String, Object> body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object>>(body, status); } ​ 3、ErrorPageCustomizer： @Value("${error.path:/error}") private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object> model) { ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView; } private ModelAndView resolve(String viewName, Map&lt;String, Object> model) { //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) { //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); } //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); } ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object> model) { //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) { ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) { return modelAndView; } } return null; } 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； @ControllerAdvice public class MyExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object> handleException(Exception e){ Map&lt;String,Object> map = new HashMap&lt;>(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; } } //没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 @ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request){ Map&lt;String,Object> map = new HashMap&lt;>(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; } 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes //给容器中加入我们自己定义的ErrorAttributes @Component public class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object> getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object> map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; } } 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； server.port=8081 server.context-path=/crud server.tomcat.uri-encoding=UTF-8 //通用的Servlet容器设置 server.xxx //Tomcat的设置 server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 @Bean //一定要将这个定制器加入到容器中 public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){ return new EmbeddedServletContainerCustomizer() { //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8083); } }; } 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean //注册三大组件 @Bean public ServletRegistrationBean myServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean; } FilterRegistrationBean @Bean public FilterRegistrationBean myFilter(){ FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean; } ServletListenerRegistrationBean @Bean public ServletListenerRegistrationBean myListener(){ ServletListenerRegistrationBean&lt;MyListener> registrationBean = new ServletListenerRegistrationBean&lt;>(new MyListener()); return registrationBean; } SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME) @ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) { registration.setMultipartConfig(this.multipartConfig); } return registration; } 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器； &lt;/dependency> Jetty &lt;!-- 引入web模块 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;exclusions> &lt;exclusion> &lt;artifactId>spring-boot-starter-tomcat&lt;/artifactId> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;!--引入其他的Servlet容器--> &lt;dependency> &lt;artifactId>spring-boot-starter-jetty&lt;/artifactId> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;/dependency> Undertow &lt;!-- 引入web模块 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;exclusions> &lt;exclusion> &lt;artifactId>spring-boot-starter-tomcat&lt;/artifactId> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;!--引入其他的Servlet容器--> &lt;dependency> &lt;artifactId>spring-boot-starter-undertow&lt;/artifactId> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;/dependency> 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Configuration @ConditionalOnWebApplication @Import(BeanPostProcessorsRegistrar.class) //导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件 //导入了EmbeddedServletContainerCustomizerBeanPostProcessor： //后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作 public class EmbeddedServletContainerAutoConfiguration { @Configuration @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat { @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() { return new TomcatEmbeddedServletContainerFactory(); } } /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty { @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() { return new JettyEmbeddedServletContainerFactory(); } } /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow { @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() { return new UndertowEmbeddedServletContainerFactory(); } } 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） public interface EmbeddedServletContainerFactory { //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers); } 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 @Override public EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) { //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) { tomcat.getService().addConnector(additionalConnector); } prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat); } 4）、我们对嵌入式容器的配置修改是怎么生效？ ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor //初始化之前 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) { // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); } return bean; } private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) { //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) { customizer.customize(bean); } } private Collection&lt;EmbeddedServletContainerCustomizer> getCustomizers() { if (this.customizers == null) { // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer>( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); } return this.customizers; } ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-tomcat&lt;/artifactId> &lt;scope>provided&lt;/scope> &lt;/dependency> 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); } } 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) { //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) { this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); } builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) { application.getSources().add(getClass()); } Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) { application.getSources().add(ErrorPageFilterConfiguration.class); } //启动Spring应用 return run(application); } 7）、Spring的应用就启动并且创建IOC容器 public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); } } ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 service network restart ​ 7）、查看linux的ip地址 ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 1、检查内核版本，必须是3.10及以上 uname -r 2、安装docker yum install docker 3、输入y确认安装 4、启动docker [root@localhost ~]# systemctl start docker [root@localhost ~]# docker -v Docker version 1.12.6, build 3e8e77d/1.12.6 5、开机启动docker [root@localhost ~]# systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 6、停止docker systemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1、搜索镜像 [root@localhost ~]# docker search tomcat 2、拉取镜像 [root@localhost ~]# docker pull tomcat 3、根据镜像启动容器 docker run --name mytomcat -d tomcat:latest 4、docker ps 查看运行中的容器 5、 停止运行中的容器 docker stop 容器的id 6、查看所有的容器 docker ps -a 7、启动容器 docker start 容器id 8、删除一个容器 docker rm 容器id 9、启动一个做了端口映射的tomcat [root@localhost ~]# docker run -d -p 8888:8080 tomcat -d：后台运行 -p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 10、为了演示简单关闭了linux的防火墙 service firewalld status ；查看防火墙状态 service firewalld stop：关闭防火墙 11、查看容器的日志 docker logs container-name/container-id 更多命令参看 https://docs.docker.com/engine/reference/commandline/docker/ 可以参考每一个镜像的文档 3）、安装MySQL示例docker pull mysql 错误的启动 [root@localhost ~]# docker run --name mysql01 -d mysql 42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846 mysql退出了 [root@localhost ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 42f09819908b mysql "docker-entrypoint.sh" 34 seconds ago Exited (1) 33 seconds ago mysql01 538bde63e500 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago compassionate_ goldstine c4f1ac60b3fc tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago lonely_fermi 81ec743a5271 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago sick_ramanujan //错误日志 [root@localhost ~]# docker logs 42f09819908b error: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 [root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b874c56bec49 mysql "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 [root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434 [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ad10e4bc5c6a mysql "docker-entrypoint.sh" 4 seconds ago Up 2 seconds 0.0.0.0:3306->3306/tcp mysql02 几个其他的高级操作 docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面 改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql） docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-jdbc&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 /** * Generic DataSource configuration. */ @ConditionalOnMissingBean(DataSource.class) @ConditionalOnProperty(name = "spring.datasource.type") static class Generic { @Bean public DataSource dataSource(DataSourceProperties properties) { //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); } } 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： schema-*.sql、data-*.sql 默认规则：schema.sql，schema-all.sql； 可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源导入druid数据源 @Configuration public class DruidConfig { @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String> initParams = new HashMap&lt;>(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String> initParams = new HashMap&lt;>(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; } } 3、整合MyBatis &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>1.3.1&lt;/version> &lt;/dependency> 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版//指定这是一个操作数据库的mapper @Mapper public interface DepartmentMapper { @Select("select * from department where id=#{id}") public Department getDeptById(Integer id); @Delete("delete from department where id=#{id}") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into department(departmentName) values(#{departmentName})") public int insertDept(Department department); @Update("update department set departmentName=#{departmentName} where id=#{id}") public int updateDept(Department department); } 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； @org.springframework.context.annotation.Configuration public class MyBatisConfig { @Bean public ConfigurationCustomizer configurationCustomizer(){ return new ConfigurationCustomizer(){ @Override public void customize(Configuration configuration) { configuration.setMapUnderscoreToCamelCase(true); } }; } } 使用MapperScan批量扫描所有的Mapper接口； @MapperScan(value = "com.atguigu.springboot.mapper") @SpringBootApplication public class SpringBoot06DataMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); } } 5）、配置文件版mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； //使用JPA注解配置映射关系 @Entity //告诉JPA这是一个实体类（和数据表映射的类） @Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user； public class User { @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） //继承JpaRepository来完成对数据库的操作 public interface UserRepository extends JpaRepository&lt;User,Integer> { } 3）、基本的配置JpaProperties spring: jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象initialize(sources); private void initialize(Object[] sources) { //保存主配置类 if (sources != null &amp;&amp; sources.length > 0) { this.sources.addAll(Arrays.asList(sources)); } //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass(); } 2、运行run方法public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try { //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); } } 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext> { @Override public void initialize(ConfigurableApplicationContext applicationContext) { System.out.println("ApplicationContextInitializer...initialize..."+applicationContext); } } SpringApplicationRunListener public class HelloSpringApplicationRunListener implements SpringApplicationRunListener { //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args){ } @Override public void starting() { System.out.println("SpringApplicationRunListener...starting..."); } @Override public void environmentPrepared(ConfigurableEnvironment environment) { Object o = environment.getSystemProperties().get("os.name"); System.out.println("SpringApplicationRunListener...environmentPrepared.."+o); } @Override public void contextPrepared(ConfigurableApplicationContext context) { System.out.println("SpringApplicationRunListener...contextPrepared..."); } @Override public void contextLoaded(ConfigurableApplicationContext context) { System.out.println("SpringApplicationRunListener...contextLoaded..."); } @Override public void finished(ConfigurableApplicationContext context, Throwable exception) { System.out.println("SpringApplicationRunListener...finished..."); } } 配置（META-INF/spring.factories） org.springframework.context.ApplicationContextInitializer=\ com.atguigu.springboot.listener.HelloApplicationContextInitializer org.springframework.boot.SpringApplicationRunListener=\ com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner @Component public class HelloApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println("ApplicationRunner...run...."); } } CommandLineRunner @Component public class HelloCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println("CommandLineRunner...run..."+ Arrays.asList(args)); } } 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 @Configuration //指定这个类是一个配置类 @ConditionalOnXXX //在指定条件成立的情况下自动配置类生效 @AutoConfigureAfter //指定自动配置类的顺序 @Bean //给容器中添加组件 @ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置 @EnableConfigurationProperties //让xxxProperties生效加入到容器中 自动配置类要能加载 将需要启动就加载的自动配置类，配置在META-INF/spring.factories org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.atguigu.starter&lt;/groupId> &lt;artifactId>atguigu-spring-boot-starter&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;!--启动器--> &lt;dependencies> &lt;!--引入自动配置模块--> &lt;dependency> &lt;groupId>com.atguigu.starter&lt;/groupId> &lt;artifactId>atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/project> 2）、自动配置模块 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.atguigu.starter&lt;/groupId> &lt;artifactId>atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;packaging>jar&lt;/packaging> &lt;name>atguigu-spring-boot-starter-autoconfigurer&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>1.5.10.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;project.reporting.outputEncoding>UTF-8&lt;/project.reporting.outputEncoding> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;!--引入spring-boot-starter；所有starter的基本配置--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;/project> package com.atguigu.starter; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = "atguigu.hello") public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } } package com.atguigu.starter; public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHellAtguigu(String name){ return helloProperties.getPrefix()+"-" +name + helloProperties.getSuffix(); } } package com.atguigu.starter; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @ConditionalOnWebApplication //web应用才生效 @EnableConfigurationProperties(HelloProperties.class) public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; } } 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity的配置类]]></title>
    <url>%2FSpringSecurity%E7%9A%84%E9%85%8D%E7%BD%AE%E7%B1%BB.html</url>
    <content type="text"><![CDATA[@EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) // 启用方法安全设置 public class SecurityConfig extends WebSecurityConfigurerAdapter { private static final String KEY = "edward"; @Autowired private UserDetailsService userDetailsService; @Autowired private PasswordEncoder passwordEncoder; @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); // 使用 BCrypt 加密 } @Bean public AuthenticationProvider authenticationProvider() { DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider(); authenticationProvider.setUserDetailsService(userDetailsService); authenticationProvider.setPasswordEncoder(passwordEncoder); // 设置密码加密方式 return authenticationProvider; } /** * 自定义配置 */ @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().antMatchers("/css/**", "/js/**", "/fonts/**", "/index").permitAll() // 都可以访问 .antMatchers("/h2-console/**").permitAll() // 都可以访问 .antMatchers("/admins/**").hasRole("ADMIN") // 需要相应的角色才能访问 .and() .formLogin() //基于 Form 表单登录验证 .loginPage("/login").failureUrl("/login-error") // 自定义登录界面 .and().rememberMe().key(KEY) // 启用 remember me .and().exceptionHandling().accessDeniedPage("/403"); // 处理异常，拒绝访问就重定向到 403 页面 http.csrf().ignoringAntMatchers("/h2-console/**"); // 禁用 H2 控制台的 CSRF 防护 http.headers().frameOptions().sameOrigin(); // 允许来自同一来源的H2 控制台的请求 } /** * 认证信息管理 * @param auth * @throws Exception */ @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService); auth.authenticationProvider(authenticationProvider()); } }]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB文件服务器搭建]]></title>
    <url>%2FMongoDB%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[一、环境准备&lt;?xml version="1.0" encoding="UTF-8"?> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.1.3.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.edward&lt;/groupId> &lt;artifactId>myfileserver&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>myfileserver&lt;/name> &lt;description>mongodbfileserver project for Spring Boot&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-mongodb&lt;/artifactId> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/de.flapdoodle.embed/de.flapdoodle.embed.mongo 这个是采用内嵌MongoDB服务器需要的依赖 --> &lt;!--&lt;dependency>--> &lt;!--&lt;groupId>de.flapdoodle.embed&lt;/groupId>--> &lt;!--&lt;artifactId>de.flapdoodle.embed.mongo&lt;/artifactId>--> &lt;!--&lt;/dependency>--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 二、项目结构本项目采用springboot构件的 三、配置application.properties配置文件 server.address=localhost server.port=8081 # Thymeleaf spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.cache=false spring.thymeleaf.mode=HTML5 # limit upload file size spring.servlet.multipart.max-file-size=1024KB spring.servlet.multipart.max-request-size=1024KB # independent MongoDB server 如果采用内嵌MongoDB服务器把这个注释掉 spring.data.mongodb.uri=mongodb://localhost:27017/test 安全配置类 SecurityConfig.java文件 /** 1. Spring Security 配置类. */ @Configuration @EnableWebMvc public class SecurityConfig extends WebMvcConfigurerAdapter { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/**").allowedOrigins("*") ; // 允许跨域请求 } } 三、后台编码 1.domain层 File.java /** 1. File 文档类. */ @Document public class File { @Id // 主键 private String id; private String name; // 文件名称 private String contentType; // 文件类型 private long size; private Date uploadDate; private String md5; private Binary content; // 文件内容 private String path; // 文件路径 //get set 方法 protected File() { } public File(String name, String contentType, long size,Binary content) { this.name = name; this.contentType = contentType; this.size = size; this.uploadDate = new Date(); this.content = content; } @Override public boolean equals(Object object) { if (this == object) { return true; } if (object == null || getClass() != object.getClass()) { return false; } File fileInfo = (File) object; return java.util.Objects.equals(size, fileInfo.size) &amp;&amp; java.util.Objects.equals(name, fileInfo.name) &amp;&amp; java.util.Objects.equals(contentType, fileInfo.contentType) &amp;&amp; java.util.Objects.equals(uploadDate, fileInfo.uploadDate) &amp;&amp; java.util.Objects.equals(md5, fileInfo.md5) &amp;&amp; java.util.Objects.equals(id, fileInfo.id); } @Override public int hashCode() { return java.util.Objects.hash(name, contentType, size, uploadDate, md5, id); } } 存储库FileRepository.java /** * File 存储库. */ public interface FileRepository extends MongoRepository&lt;File, String> { } 3.服务接口及实现类FileService.java /** * File 服务接口. */ public interface FileService { /** * 保存文件 */ File saveFile(File file); /** * 删除文件 */ void removeFile(String id); /** * 根据id获取文件 */ Optional&lt;File> getFileById(String id); /** * 分页查询，按上传时间降序 * @return */ List&lt;File> listFilesByPage(int pageIndex, int pageSize); } FileServiceImpl.java /** * File 服务. */ @Service public class FileServiceImpl implements FileService { @Autowired public FileRepository fileRepository; @Override public File saveFile(File file) { return fileRepository.save(file); } @Override public void removeFile(String id) { fileRepository.deleteById(id); } @Override public Optional&lt;File> getFileById(String id) { return fileRepository.findById(id); } @Override public List&lt;File> listFilesByPage(int pageIndex, int pageSize) { Page&lt;File> page = null; List&lt;File> list = null; Sort sort = new Sort(Direction.DESC,"uploadDate"); Pageable pageable = PageRequest.of(pageIndex, pageSize, sort); page = fileRepository.findAll(pageable); list = page.getContent(); return list; } } 4.控制层、API资源层FileController.java @CrossOrigin(origins = "*", maxAge = 3600) // 允许所有域名访问 @Controller public class FileController { @Autowired private FileService fileService; @Value("${server.address}") private String serverAddress; @Value("${server.port}") private String serverPort; @RequestMapping(value = "/") public String index(Model model) { // 展示最新二十条数据 model.addAttribute("files", fileService.listFilesByPage(0, 20)); return "index"; } /** * 分页查询文件 */ @GetMapping("files/{pageIndex}/{pageSize}") @ResponseBody public List&lt;File> listFilesByPage(@PathVariable int pageIndex, @PathVariable int pageSize) { return fileService.listFilesByPage(pageIndex, pageSize); } /** * 获取文件片信息 */ @GetMapping("files/{id}") @ResponseBody public ResponseEntity&lt;Object> serveFile(@PathVariable String id) throws UnsupportedEncodingException { Optional&lt;File> file = fileService.getFileById(id); if (file.isPresent()) { return ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; fileName=" + new String(file.get().getName().getBytes("utf-8"),"ISO-8859-1")) .header(HttpHeaders.CONTENT_TYPE, "application/octet-stream") .header(HttpHeaders.CONTENT_LENGTH, file.get().getSize() + "").header("Connection", "close") .body(file.get().getContent().getData()); } else { return ResponseEntity.status(HttpStatus.NOT_FOUND).body("File was not fount"); } } /** * 在线显示文件 */ @GetMapping("/view/{id}") @ResponseBody public ResponseEntity&lt;Object> serveFileOnline(@PathVariable String id) { Optional&lt;File> file = fileService.getFileById(id); if (file.isPresent()) { return ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, "fileName=\"" + file.get().getName() + "\"") .header(HttpHeaders.CONTENT_TYPE, file.get().getContentType()) .header(HttpHeaders.CONTENT_LENGTH, file.get().getSize() + "").header("Connection", "close") .body(file.get().getContent().getData()); } else { return ResponseEntity.status(HttpStatus.NOT_FOUND).body("File was not fount"); } } /** * 上传 */ @PostMapping("/") public String handleFileUpload(@RequestParam("file") MultipartFile file, RedirectAttributes redirectAttributes) { try { File f = new File(file.getOriginalFilename(), file.getContentType(), file.getSize(), new Binary(file.getBytes())); f.setMd5(MD5Util.getMD5(file.getInputStream())); fileService.saveFile(f); System.out.println(f); } catch (IOException | NoSuchAlgorithmException ex) { ex.printStackTrace(); redirectAttributes.addFlashAttribute("message", "Your " + file.getOriginalFilename() + " is wrong!"); return "redirect:/"; } redirectAttributes.addFlashAttribute("message", "You successfully uploaded " + file.getOriginalFilename() + "!"); return "redirect:/"; } /** * 上传接口 */ @PostMapping("/upload") @ResponseBody public ResponseEntity&lt;String> handleFileUpload(@RequestParam("file") MultipartFile file) { File returnFile = null; try { File f = new File(file.getOriginalFilename(), file.getContentType(), file.getSize(), new Binary(file.getBytes())); f.setMd5(MD5Util.getMD5(file.getInputStream())); returnFile = fileService.saveFile(f); String path = "//" + serverAddress + ":" + serverPort + "/view/" + returnFile.getId(); return ResponseEntity.status(HttpStatus.OK).body(path); } catch (IOException | NoSuchAlgorithmException ex) { ex.printStackTrace(); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ex.getMessage()); } } /** * 删除文件 */ @DeleteMapping("/{id}") @ResponseBody public ResponseEntity&lt;String> deleteFile(@PathVariable String id) { try { fileService.removeFile(id); return ResponseEntity.status(HttpStatus.OK).body("DELETE Success!"); } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(e.getMessage()); } } } 5.工具类 MD5Util.java /** * MD5 工具类. */ public class MD5Util { /** * 获取该输入流的MD5值 */ public static String getMD5(InputStream is) throws NoSuchAlgorithmException, IOException { StringBuffer md5 = new StringBuffer(); MessageDigest md = MessageDigest.getInstance("MD5"); byte[] dataBytes = new byte[1024]; int nread = 0; while ((nread = is.read(dataBytes)) != -1) { md.update(dataBytes, 0, nread); }; byte[] mdbytes = md.digest(); // convert the byte to hex format for (int i = 0; i &lt; mdbytes.length; i++) { md5.append(Integer.toString((mdbytes[i] &amp; 0xff) + 0x100, 16).substring(1)); } return md5.toString(); } } 四、前台页面&lt;!DOCTYPE html> &lt;html xmlns:th="http://www.thymeleaf.org"> &lt;head> &lt;/head> &lt;body> &lt;h1>File server&lt;/h1> &lt;a href="/">首页&lt;/a> &lt;div th:if="${message}"> &lt;h2 th:text="${message}"/> &lt;/div> &lt;div> &lt;form method="POST" enctype="multipart/form-data" action="/"> &lt;table> &lt;tr>&lt;td>File to upload:&lt;/td>&lt;td>&lt;input type="file" name="file" />&lt;/td>&lt;/tr> &lt;tr>&lt;td>&lt;/td>&lt;td>&lt;input type="submit" value="Upload" />&lt;/td>&lt;/tr> &lt;/table> &lt;/form> &lt;/div> &lt;div> &lt;table border="1"> &lt;thead> &lt;tr> &lt;td>Name&lt;/td> &lt;td>ID&lt;/td> &lt;td>contentType&lt;/td> &lt;td>size&lt;/td> &lt;td>uploadDate&lt;/td> &lt;td>md5&lt;/td> &lt;/tr> &lt;/thead> &lt;tbody> &lt;tr th:if="${files.size()} eq 0"> &lt;td colspan="3">没有文件信息！！&lt;/td> &lt;/tr> &lt;tr th:each="file : ${files}"> &lt;td>&lt;a th:href="'files/'+${file.id}" th:text="${file.name}" />&lt;/td> &lt;td th:text="${file.id}" >&lt;/td> &lt;td th:text="${file.contentType}" >&lt;/td> &lt;td th:text="${file.size}" >&lt;/td> &lt;td th:text="${file.uploadDate}" >&lt;/td> &lt;td th:text="${file.md5}" >&lt;/td> &lt;/tr> &lt;/tbody> &lt;/table> &lt;/div> &lt;/body> &lt;/html>]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sprig data jpa关系映射]]></title>
    <url>%2FSprig%20data%20jpa%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84.html</url>
    <content type="text"><![CDATA[一、 单向一对一@OneToOneManager.java package com.edward.springdata.bean; import javax.persistence.*; @Entity public class Manager { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String mangerName; @OneToOne(cascade=CascadeType.ALL) @JoinColumn(name = "department_id") private Department department; } Department.java package com.edward.springdata.bean; import javax.persistence.*; @Entity public class Department { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String deptName; } 生成的表department表manager表生成的外键 二、 双向一对一@OneToOne基于外键的 1-1 关联关系：在双向的一对一关联中，需要在关系被维护端(inverse side)中的 @OneToOne 注释中指定 mappedBy，以指定是这一关联中的被维护端。同时需要在关系维护端(owner side)建立外键列指向关系被维护端的主键列。 @OneToOne(cascade=CascadeType.ALL) @JoinColumn(name = "department_id") private Department department; @OneToOne(mappedBy = "department") private Manager manager; 三、@OneToMany 和 @ManyToOne双向一对多关系中，必须存在一个关系维护端，在 JPA 规范中，要求 many 的一方作为关系的维护端(owner side), one 的一方作为被维护端(inverse side)。可以在 one 方指定 @OneToMany 注释并设置 mappedBy 属性，以指定它是这一关联中的被维护端，many 为维护端。在 many 方指定 @ManyToOne 注释，并使用 @JoinColumn 指定外键名称 Customer.java @Entity public class Customer { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String lastName; @Column private String email; @Column private int age; @Column private Date createdTime; @Column private Date birth; @OneToMany(mappedBy="customer") private Set&lt;Order> orders = new HashSet&lt;>(); } 这里特别的坑order是mysql的关键字，所以order不能拿来做表名Order.java @Table(name="ORDERS") @Entity public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String orderName; @JoinColumn(name="customer_id") @ManyToOne(fetch=FetchType.LAZY) private Customer customer; } 生成的表customer表 order表外键 四、多对多关联关系在双向多对多关系中，我们必须指定一个关系维护端(owner side),可以通过 @ManyToMany 注释中指定 mappedBy 属性来标识其为关系维护端。 @Table(name="JPA_ITEMS") @Entity public class Item { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String itemName; //使用 @ManyToMany 注解来映射多对多关联关系 //使用 @JoinTable 来映射中间表 //1. name 指向中间表的名字 //2. joinColumns 映射当前类所在的表在中间表中的外键 //2.1 name 指定外键列的列名 //2.2 referencedColumnName 指定外键列关联当前表的哪一列 也可以不写，默认是当前表的主键 //3. inverseJoinColumns 映射关联的类所在中间表的外键 @JoinTable(name="ITEM_CATEGORY", joinColumns={@JoinColumn(name="item_id", referencedColumnName="ID")}, inverseJoinColumns={@JoinColumn(name="category_id", referencedColumnName="ID")}) @ManyToMany private Set&lt;Category> categories = new HashSet&lt;>(); } @Table(name="JPA_CATEGORIES") @Entity public class Category { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String categoryName; @ManyToMany(mappedBy="categories") private Set&lt;Item> items = new HashSet&lt;>(); } 生成的表item表 category表中间表item_category外键参考文章：https://blog.csdn.net/johnf_nash/article/details/80642581]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot 2.1.3整合Mybatis]]></title>
    <url>%2Fspring-boot%202.1.3%E6%95%B4%E5%90%88Mybatis.html</url>
    <content type="text"><![CDATA[一、注解版1.添加依赖 &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>2.0.0&lt;/version> &lt;/dependency> 2.配置数据源3.写mapper接口 package com.edward.springbootmybaties.mapper; import com.edward.springbootmybaties.bean.User; import org.apache.ibatis.annotations.*; @Mapper public interface UserMapper { @Select("select * from user where id=#{id}") public User getUserById(Integer id); @Delete("delete * from user where id=#{id}") public int deleteUserById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into user(username,password) values(#{username},#{password})") public int insertUser(User user); @Update("update user set username=#{username},password=#{password}") public int updateUser(User user); } 4.使用 //UserMapper使用的是@Mapper注解，IDEA会提示错误UserMapper找不到，但不影响运行 @Autowired UserMapper userMapper; @ResponseBody @GetMapping("/user/{id}") public User getUser(@PathVariable("id") Integer id){ User user = userMapper.getUserById(id); return user; } @ResponseBody @GetMapping("/user") public User insertUser(User user){ int i = userMapper.insertUser(user); return user; } 5.自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer @org.springframework.context.annotation.Configuration public class MyBatisConfig { @Bean public ConfigurationCustomizer configurationCustomizer(){ return new ConfigurationCustomizer(){ @Override public void customize(Configuration configuration) { //开启驼峰命名法 configuration.setMapUnderscoreToCamelCase(true); } }; } } 6.使用MapperScan批量扫描所有的Mapper接口，这样不用在每个Mapper文件上加@Mapper注解 @MapperScan(basePackages = "com.edward.sprignbootmybaties.mapper") @SpringBootApplication public class SpringBootMybatiesApplication { public static void main(String[] args) { SpringApplication.run(SpringBootMybatiesApplication.class, args); } } 二、 配置文件版创建mybatis-config.xml和xxxMapper.xml文件mybatis-config.xml文件 &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> &lt;configuration> //开启驼峰命名 &lt;settings> &lt;setting name="mapUnderscoreToCamelCase" value="true"/> &lt;/settings> &lt;/configuration> xxxMapper.xml文件 &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> &lt;mapper namespace="com.atguigu.springboot.mapper.EmployeeMapper"> &lt;!-- public Employee getEmpById(Integer id); public void insertEmp(Employee employee);--> &lt;select id="getEmpById" resultType="com.atguigu.springboot.bean.Employee"> SELECT * FROM employee WHERE id=#{id} &lt;/select> &lt;insert id="insertEmp"> INSERT INTO employee(lastName,email,gender,d_id) VALUES (#{lastName},#{email},#{gender},#{dId}) &lt;/insert> &lt;/mapper> 在application.yml文件中 mybatis: config‐location: classpath:mybatis/mybatis‐config.xml 指定全局配置文件的位置 mapper‐locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
        <tag>Mybaties</tag>
      </tags>
  </entry>
</search>

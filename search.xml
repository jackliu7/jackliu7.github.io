<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySql数据库知识点总结01]]></title>
    <url>%2FMySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9301.html</url>
    <content type="text"><![CDATA[数据库架构 MySql数据库从大的方面可以分为两大部分，分别为底层的存储系统也就是文件系统，和上层的程序实例组成，程序实例有存储管理、缓存管理、日志管理、权限管理、容灾管理、SQL解析、索引、锁等 程序实：存储管理、缓存管理、日志管理、权限管理、容灾管理、SQL解析、索引、锁等 存储：文件系统 乐观锁和悲观锁 悲观锁：对数据持一种悲观的态度，认为在事务执行期间总是有别的事务修改数据，所以每一次操作都加锁乐观锁：对数据持一种乐观的态度，所以不加锁，乐观锁中每一项数据都有一个版本号，在事务提交的时候，通过版本号来看是否是否在事务A期间，事务B修改了数据，比如有两个事务，事务A先查询数据，此时数据的版本号为0，事务B查询版本也为0，当A修改了数据并且版本变为1，在提交是版本号1&gt;0提交成功，此时事务也修改了数据把版本加一变为1，在提交时版本号1不大于1，所以提交被驳回，数据过期 三范式 第一范式：字段不可分，只要是数据库中存在的表都符合1NF第二范式：消除了非主属性对码的部分依赖第三范式：消除了非主属性对码的传递依赖 数据库ACID的特性 A:原子性—-一次事务是数据库的最小执行单位，要么事务内的所有操作做完，要么全不做，事务期间只要有一个操作不成功，就回滚，回到事务开始之前C:一致性—-事务从一个一致性状态转移到另一个一致性转态，比如：账户A有100，账户B也有100，加起来是200，当A给B转了50后，A为50，B为150，加起来还是200，感觉有一点能量守恒的意思I:隔离线—-一个事务的操作在提交之前是对其他不可见的D:持久性—-一旦事务提交数据会被保存到磁盘永久有效 leftjoin和rightjoin、innerjoin的区别 leftjoin(左联接) ：包含左表的全部数据和右表中联结字段相等的记录rightjoin(右联接)： 返回包括右表中的所有记录和左表中联结字段相等的记录innerjoin(等值连接)： 只返回两个表中联结字段相等的行 DROP，DELETE与TRUNCATE的区别 DROP会把一个表删掉DELETE删除一个表的数据，一般配合where使用TRUNCATE清空表中的数据，下一次在插入数据时自增长Id从1开始 UNION/ALL、EXCEPT/ALL和INTERSECT/ALL union 合并两个查询结果，把两个结果做并集并且删除重复的行，union all不会删除重复的行expect 把两个结果做查，包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行，expect all不消除重复的行insert 把两个结果集做交集 只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表 expect all不消除重复的行 InnoDB和MyISAM InnoDB MyISAM MySQL默认的引擎，支持行级锁和表级锁 ，支持事务 只支持表级锁，不支持事务 适用大量的INSERT或UPDATE操作 适用大量的SELECT查询 为什么MyISAM会比InnoDB的查询速度快？ InnoDB要缓存数据块，而MyISAM只需要缓存索引快 InnoDB寻址要先映射到数据块在到数据行，而MyISAM记录的直接是数据的OFESET，定位比InooDB块 InnoDB还需要维护MVCC一致 隔离级别 脏读 读取了一个事务还未提交的数据 不可重复读 在同一个事务中两次读取的结果不一样，和幻读相比更侧重数据的修改 幻读 在同一个事务中两次读取的记录数量不一样，更偏向于插入操作带来的不一样 事务隔离级别 更新丢失 脏读 不可重复读 幻读 读未提交 （Read uncommitted） × √ √ √ 读已提交 （Read committed） × × √ √ 可重复读（Repeatable read） × × × √ 序列化（Serializable） × × × × MySql在RR隔离级别下是如何避免幻读的 表象：快照读也叫非阻塞读 –伪MVVC 内在： next-key锁（行锁+gap锁） 快照读和当前读？当前读：加了锁的增删改查语句 快照读：不加锁的非阻塞读,快照读顾名思义会生成快照，在RC（Read Committed）隔离级别下每一次的select语句都会产生一个快照，所以会产生幻读，在RR级别下，select语句执行的时间不同，生成的快照也会不同，如果有个事务的select语句执行的时候另一个事务还没提交那么这个事务就看不到另一个事务的修改，反之如果一个事务在另一个事务提交后执行了select语句那这个事务就可以看到另一个事务的修改也就是查询可以看到自己之前已提的所有事务所做的更改，看不到在查询开始之后的事务提交的更改 next-key锁？ MySql在RR隔离级别下实际上是通过next-key锁避免幻读的，next-key锁就是行锁+gap锁，gap会把一个范围锁起来，比如一个表的索引是1,3,5,当执行select * from table where id &gt; 3;就会把&gt;3的范围锁起来，当在另一个事务中插入一条id为4的数据时，就会被阻塞，只有当事务提交以后，另一个事务才能继续执行插入语句]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后台开发面试考点汇总]]></title>
    <url>%2FJava%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[一、JavaSE部分❤1、Java基础1、为什么重写equals还要重写hashcode2、说一下map的分类和常见的情况 3、Object若不重写hashCode()的话，hashCode()如何计算出来的？4、==比较的是什么？ 5、若对一个类不重写，它的equals()方法是如何比较的？6、java8新特性 7、说说Lamda表达式的优缺点。 8、一个十进制的数在内存中是怎么存的？ 9、为啥有时会出现4.0-3.6=0.40000001这种现象？ 10、Java支持的数据类型有哪些？什么是自动拆装箱？ 11、什么是值传递和引用传递？ 12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？ 13、你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？ 14、String是最基本的数据类型吗? 15、int 和 Integer 有什么区别 16、String 和StringBuffer的区别 17、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？ 18、int和Integer有什么区别？ 19、&amp;和&amp;&amp;的区别？ 20、在Java中，如何跳出当前的多重嵌套循环？ 21、你能比较一下Java和JavaSciprt吗？ 22、简述正则表达式及其用途。 23、Java中是如何支持正则表达式操作的？ 24、请你说说Java和PHP的区别？ ❤2、关键字 1、介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？2、介绍一下volatile？ 3、锁有了解嘛，说一下Synchronized和lock 4、讲一讲Java里面的final关键字怎么用的？ ❤3、面向对象1、wait方法底层原理 2、Java有哪些特性，举个多态的例子。 3、String为啥不可变？ 4、类和对象的区别 5、请列举你所知道的Object类的方法。 6、重载和重写的区别？相同参数不同返回值能重载吗？ 7、”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ 8、String能继承吗？ 9、StringBuffer和StringBuilder有什么区别，底层实现上呢？ 10、类加载机制，双亲委派模型，好处是什么？ 11、静态变量存在哪? 12、讲讲什么是泛型？ 13、解释extends 和super 泛型限定符-上界不存下界不取 14、是否可以在static环境中访问非static变量？ 15、谈谈如何通过反射创建对象？ 16、Java支持多继承么？ 17、接口和抽象类的区别是什么？ 18、Comparable和Comparator接口是干什么的？列出它们的区别。 19、面向对象的特征有哪些方面 20、final, finally, finalize的区别。 21、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? 22、abstract class和interface有什么区别? 23、Static Nested Class 和 Inner Class的不同 24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 25、Java的接口和C++的虚类的相同和不同处。 26、JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ 27、内部类可以引用他包含类的成员吗？有没有什么限制？ 28、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code说法是否正确？ 29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 30、如何通过反射获取和设置对象私有字段的值？ 31、谈一下面向对象的”六原则一法则”。 32、请问Query接口的list方法和iterate方法有什么区别？ 33、Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？ 34、Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？ 35、hashCode()和equals()方法有什么联系？ ❤4、集合1、Map和ConcurrentHashMap的区别？ 2、hashMap内部具体如何实现的？ 3、如果hashMap的key是一个自定义的类，怎么办？ 4、ArrayList和LinkedList的区别，如果一直在list的尾部添加元素，用哪个效率高？ 5、HashMap底层，负载因子，为啥是2^n？ 6、ConcurrentHashMap锁加在了哪些地方？ 7、TreeMap底层，红黑树原理？ 8、concurrenthashmap有啥优势，1.7，1.8区别？ 9、ArrayList是否会越界？ 10、什么是TreeMap? 11、ConcurrentHashMap的原理是什么？ 12、Java集合类框架的基本接口有哪些？ 13、为什么集合类没有实现Cloneable和Serializable接口？ 14、什么是迭代器？ 15、Iterator和ListIterator的区别是什么？ 16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ 17、HashMap和Hashtable有什么区别？ 18、ArrayList和LinkedList有什么区别？ 19、ArrayList,Vector,LinkedList的存储性能和特性是什么？ 20、Collection 和 Collections的区别。 21、你所知道的集合类都有哪些？主要方法？ 22、List、Set、Map是否继承自Collection接口？ 23、阐述ArrayList、Vector、LinkedList的存储性能和特性 24、List、Map、Set三个接口存取元素时，各有什么特点？ ❤5、线程1、多线程中的i++线程安全吗？为什么？2、如何线程安全的实现一个计数器？ 3、多线程同步的方法 4、介绍一下生产者消费者模式？ 5、线程，进程，然后线程创建有很大开销，怎么优化？ 6、线程池运行流程，参数，策略 7、讲一下AQS吧。 8、创建线程的方法，哪个更好，为什么？ 9、Java中有几种方式启动一个线程？ 10、Java中有几种线程池？ 11、线程池有什么好处？ 12、cyclicbarrier和countdownlatch的区别 13、如何理解Java多线程回调方法？ 14、创建线程有几种不同的方式？你喜欢哪一种？为什么？ 15、概括的解释下线程的几种可用状态。 16、同步方法和同步代码块的区别是什么？ 17、启动线程有哪几种方式，线程池有哪几种？ 18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 19、sleep() 和 wait() 有什么区别？ 20、同步和异步有何异同，在什么情况下分别使用他们？举例说明。 21、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。使用内部类实现线程，对j增减的时候没有考虑顺序问题。 22、启动一个线程是用run()还是start()? 23、请说出你所知道的线程同步的方法 24、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 25、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？ 26、线程的sleep()方法和yield()方法有什么区别？ 27、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 28、请说出与线程同步以及线程调度相关的方法。 29、举例说明同步和异步 30、什么是线程池（thread pool）？ 31、说说线程的基本状态以及状态之间的关系？ 32、如何保证线程安全？ ❤6、锁 1、讲一下非公平锁和公平锁在reetrantlock里的实现。2、讲一下synchronized，可重入怎么实现。 3、锁和同步的区别。 4、什么是死锁(deadlock)？ 5、如何确保N个线程可以访问N个资源同时又不导致死锁？ 6、请你简述synchronized和java.util.concurrent.locks.Lock的异同？ ❤7、JDK 1、Java中的LongAdder和AtomicLong的区别2、JDK和JRE的区别是什么？ ❤8、反射1、反射的实现与作用 ❤9、JVM1、JVM回收算法和回收器，CMS采用哪种回收算法，怎么解决内存碎片问题？ 2、类加载过程 3、JVM分区 4、eden区，survial区? 5、JAVA虚拟机的作用? 6、GC中如何判断对象需要被回收？ 7、JAVA虚拟机中，哪些可作为ROOT对象？8、JVM内存模型是什么？ 9、jvm是如何实现线程？ 10、jvm最大内存限制多少 11、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ 12、描述一下JVM加载class文件的原理机制? ❤10、GC 1、java中内存泄露是啥，什么时候出现内存泄露？2、minor gc如果运行的很频繁，可能是什么原因引起的，minor gc如果运行的很慢，可能是什么原因引起的? 3、阐述GC算法 4、GC是什么? 为什么要有GC? 5、垃圾回收的优点和原理。并考虑2种回收机制 6、java中会存在内存泄漏吗，请简单描述。 7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（垃圾回收） ❤11、IO和NIO、AIO1、怎么打印日志？ 2、运行时异常与一般异常有何异同？ 3、error和exception有什么区别? 4、给我一个你最常见到的runtime exception 5、Java中的异常处理机制的简单原理和应用。 6、java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？ 7、什么是java序列化，如何实现java序列化？ 8、运行时异常与受检异常有什么区别？ 二、JavaEE部分❤1、Spring1、说一下IOC和AOP? 2、介绍一下bean的生命周期 3、Spring里面注解用过没有？autowired 和resource区别？ 4、@Controller和@RestController的区别？ 5、依赖注入的方式有几种，哪几种？ 6、springIOC原理？自己实现IOC要怎么做，哪些步骤？ 7、Spring中BeanFactory和ApplicationContext的区别？、 8、什么是IoC和DI？DI是如何实现的？ 9、请问Spring中Bean的作用域有哪些？ 10、谈谈Spring中自动装配的方式有哪些？ 11、aop的应用场景？ 12、AOP的原理是什么？ 13、你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？ 14、Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？ 15、介绍一下spring？ 16、Struts拦截器和Spring AOP区别？ 17、spring框架的优点？ 18、选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？ 19、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？ ❤2、Hibernate1、阐述实体对象的三种状态以及转换关系。 2、Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？ 3、Hibernate中Session的load和get方法的区别是什么？ 4、如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？ 4、简述Hibernate常见优化策略。 5、锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。 6、Hibernate如何实现分页查询？ 7、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。 ❤3、Struts1、说说STRUTS的应用 ❤4、Mybatis1、解释一下MyBatis中命名空间（namespace）的作用。 2、MyBatis中的动态SQL是什么意思？ ❤5、MVC1、Spring MVC注解的优点 2、springmvc和spring-boot区别？ 3、SpringMVC的运行机制，运行机制的每一部分的相关知识？ 4、谈谈Spring MVC的工作原理是怎样的？ ❤6、各框架对比与项目优化1、Mybatis和Hibernate区别？ 2、介绍一下你了解的Java领域的Web Service框架。 ❤7、JPA1、EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。 2、EJB与JAVA BEAN的区别？ 3、EJB包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？ 4、EJB的角色和三个对象是什么？ 5、说说EJB规范规定EJB中禁止的操作有哪些？ 6、EJB的激活机制是什么？ 7、EJB的几种类型分别是什么 8、EJB需直接实现它的业务接口或Home接口吗，请简述理由。 三、Java web编程❤1、web编程基础1、启动项目时如何实现不在链接里输入项目名就能启动? 2、1分钟之内只能处理1000个请求，你怎么实现，手撕代码? 3、什么时候用assert 4、JAVA应用服务器有那些？ 5、JSP的内置对象及方法。 6、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？（JSP） 7、说一说四种会话跟踪技术 8、讲讲Request对象的主要方法 9、说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然后在浏览器上就可打入主机？ 10、jsp有哪些动作?作用分别是什么? 11、请谈谈JSP有哪些内置对象？作用分别是什么？ 12、说一下表达式语言（EL）的隐式对象及其作用 13、JSP中的静态包含和动态包含有什么区别？ 14、过滤器有哪些作用和用法？ 15、请谈谈你对Javaweb开发中的监听器的理解？ 16、说说web.xml文件中可以配置哪些内容？ ❤2、web编程进阶1、forward与redirect区别，说一下你知道的状态码，redirect的状态码是多少？ 2、servlet生命周期，是否单例，为什么是单例。 3、说出Servlet的生命周期，并说出Servlet和CGI的区别。 4、Servlet执行时一般实现哪几个方法？ 5、阐述一下阐述Servlet和CGI的区别? 6、说说Servlet接口中有哪些方法？ 7、Servlet 3中的异步处理指的是什么？ 8、如何在基于Java的Web项目中实现文件上传和下载？ 9、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()方法？ 10、Servlet中如何获取用户提交的查询参数或表单数据？ 11、Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？ 12、讲一下redis的主从复制怎么做的？ 13、redis为什么读写速率快性能好？ 14、redis为什么是单线程？ 15、缓存的优点？ 16、aof，rdb，优点，区别？ 17、redis的List能用做什么场景？ 18、说说MVC的各个部分都有那些技术来实现?如何实现? 19、什么是DAO模式？ 20、请问Java Web开发的Model 1和Model 2分别指的是什么？ 21、你的项目中使用过哪些JSTL标签？ 22、使用标签库有什么好处？如何自定义JSP标签？（JSP标签） ❤3、web编程原理1、get和post区别？ 2、请谈谈转发和重定向的区别？ 3、说说你对get和post请求，并且说说它们之间的区别？ 4、cookie 和session 的区别？ 5、forward 和redirect的区别 6、BS与CS的联系与区别。 7、如何设置请求的编码以及响应内容的类型？ 8、什么是Web Service（Web服务）？ 9、谈谈Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？ 10、大型网站在架构上应当考虑哪些问题？ 11、请对J2EE中常用的名词进行解释(或简单描述) 四、JDBC编程 ❤1、SQL基础1、写SQL：找出每个城市的最新一条记录。2、一个学生表，一个课程成绩表，怎么找出学生课程的最高分数 3、有一组合索引（A,B,C），会出现哪几种查询方式？tag:sql语句 ❤2、JDBC基础1、数据库水平切分，垂直切分2、数据库索引介绍一下。介绍一下什么时候用Innodb什么时候用MyISAM。 3、数据库两种引擎 4、索引了解嘛，底层怎么实现的，什么时候会失效 5、问了数据库的隔离级别 6、数据库乐观锁和悲观锁 7、数据库的三范式？ 8、讲一下数据库ACID的特性？ 9、mysql主从复制？ 10、leftjoin和rightjoin的区别？ 11、数据库优化方法 12、谈一下你对继承映射的理解。 13、说出数据连接池的工作机制是什么? 14、事务的ACID是指什么？ 15、JDBC中如何进行事务处理？ ❤3、JDBC进阶1、JDBC的反射，反射都是什么？2、Jdo是什么? 3、Statement和PreparedStatement有什么区别？哪个性能更好？ 4、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？ 五、XML❤1、XML基础1、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ ❤2、Web Service1、WEB SERVICE名词解释，JSWDL开发包的介绍，JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。 2、请你谈谈对SOAP、WSDL、UDDI的了解？ 3、谈谈Java规范中和Web Service相关的规范有哪些？ 六、计算机网络 ❤1、网络概述1、TCP协议在哪一层？IP协议在那一层？HTTP在哪一层？ ❤2、运输层1、讲一下TCP的连接和释放连接。2、TCP有哪些应用场景 3、tcp为什么可靠 4、tcp为什么要建立连接 5、阐述TCP的4次挥手 6、讲一下浏览器从接收到一个URL到最后展示出页面，经历了哪些过程。tag 7、http和https的区别 8、http的请求有哪些，应答码502和504有什么区别 9、http1.1和1.0的区别 10、说说ssl四次握手的过程 11、304状态码有什么含义？ ❤3、网络层1、arp协议，arp攻击2、icmp协议 3、讲一下路由器和交换机的区别？ ❤4、应用层1、DNS寻址过程2、负载均衡反向代理模式优点及缺点 七、操作系统❤1、操作系统概论1、CentOS 和 Linux的关系？2、64位和32位的区别？ ❤2、进程的描述与控制1、怎么杀死进程？ 2、线程，进程区别 3、系统线程数量上限是多少？ 4、进程和线程的区别是什么？ 5、解释一下LINUX下线程，GDI类。 ❤3、输入输出系统1、socket编程，BIO，NIO，epoll？ ❤4、存储器管理1、什么是页式存储？ 2、操作系统里的内存碎片你怎么理解，有什么解决办法？ ❤5、处理机调度与死锁1、什么情况下会发生死锁，解决策略有哪些？ 2、系统CPU比较高是什么原因？ 3、系统如何提高并发性？ 八、算法与数据结构 ❤1、哈希1、hashset存的数是有序的吗？2、Object作为HashMap的key的话，对Object有什么要求吗？ 3、一致性哈希算法 4、什么是hashmap? 5、Java中的HashMap的工作原理是什么？ 6、hashCode()和equals()方法的重要性体现在什么地方？ ❤2、树1、说一下B+树和B-树？2、怎么求一个二叉树的深度?手撕代码? 3、算法题：二叉树层序遍历，进一步提问：要求每层打印出一个换行符 4、二叉树任意两个节点之间路径的最大长度 5、如何实现二叉树的深度？ 6、如何打印二叉树每层的节点？ 7、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？ ❤3、遍历1、编程题：写一个函数，找到一个文件夹下所有文件，包括子文件夹2、二叉树 Z 字型遍历 ❤4、链表1、反转单链表2、随机链表的复制 3、链表-奇数位升序偶数位降序-让链表变成升序 4、bucket如果用链表存储，它的缺点是什么？ 5、如何判断链表检测环 ❤5、数组1、寻找一数组中前K个最大的数2、求一个数组中连续子向量的最大和 3、找出数组中和为S的一对组合，找出一组就行 4、一个数组，除一个元素外其它都是两两相等，求那个元素? 5、算法题：将一个二维数组顺时针旋转90度，说一下思路。 ❤6、排序1、排序算法知道哪些，时间复杂度是多少，解释一下快排？2、如何得到一个数据流中的中位数？ 3、堆排序的原理是什么？ 4、归并排序的原理是什么？ 5、排序都有哪几种方法？请列举出来。 6、如何用java写一个冒泡排序？ ❤7、堆与栈1、堆与栈的不同是什么？2、heap和stack有什么区别。 3、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。 ❤8、队列1、什么是Java优先级队列(Priority Queue)？ ❤9、高级算法1、题目：Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted. Could you do both operations in O(1) time complexity? 2、id全局唯一且自增，如何实现？ 3、如何设计算法压缩一段URL？ 4、为什么要设计后缀表达式，有什么好处？ 5、LRU算法的实现原理？ 九、设计模式❤1、结构型模式1、java中有哪些代理模式？2、如何实现动态代理 3、IO流熟悉吗，用的什么设计模式？ ❤2、创建型模式1、介绍一下单例模式？懒汉式的单例模式如何实现单例？ ❤3、行为型模式1、介绍一下策略模式？2、设计模式了解哪些，手写一下观察者模式？ ❤4、模式汇总1、说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法2、j2ee常用的设计模式？说明工厂模式。 3、开发中都用到了那些设计模式?用在什么场合? 4、简述一下你了解的Java设计模式 十、场景题❤1、场景题汇总1、情景题：如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？2、场景题：美团首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？可以借鉴下stackoverflow，视频网站等等的推荐算法。3、场景题：微信抢红包问题悲观锁，乐观锁，存储过程放在mysql数据库中。4、场景题：1000个任务，分给10个人做，你怎么分配，先在纸上写个最简单的版本，然后优化。全局队列，把1000任务放在一个队列里面，然后每个人都是取，完成任务。分为10个队列，每个人分别到自己对应的队列中去取务。5、场景题：保证发送消息的有序性，消息处理的有序性。6、如何把一个文件快速下发到100w个服务器7、给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的?8、10亿个数，找出最大的10个。建议一个大小为10的小根堆。9、有几台机器存储着几亿淘宝搜索日志，你只有一台2g的电脑，怎么选出搜索热度最高的十个搜索关键词？10、分布式集群中如何保证线程安全？11、给个淘宝场景，怎么设计一消息队列？12、10万个数，输出从小到大？先划分成多个小文件，送进内存排序，然后再采用多路归并排序。13、有十万个单词，找出重复次数最高十个？十一、UML ❤1、UML1、请你谈一下UML中有哪些常用的图？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三次握手和四次挥手]]></title>
    <url>%2F%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</url>
    <content type="text"><![CDATA[在建立TCP连接时需要三次握手，在断开连接时需要四次挥手 三次握手第一次握手： 客户端向服务端发送SYN包{SYN=1，seq=x}，客户端进入SYN_SENT状态第二次握手： 服务端向客户端发送应答的ASK包和SYN包{ASK=1,SYN=1,ask=x+1,seq=y},服务端进入SYN_RCVD状态第三次握手： 客户端向服务端发送应答的ASK包{ASK=1，ask=y+1,seq=x+1}，客户端进入ESTABLISHED状态，服务端收到ASK包后也进入ESTABLISHED状态 建立连接为什么是三次握手，而不是两次呢？加入是两次的话对客户端 是没有影响的，客户端开始在收到服务端的ASK-SYN包后进入ESTABLISHED状态，客户端向服务端发送数据是没问题的，但对于服务端来说，在接收到客户端的ASk连接请求后就进入了ESTABLISHED状态，并发送向客户端发送ASK-SYN包，如果这时客户端没有收到ASK-SYN包，没有进入ESTABLISHED状态，但服务端就给客户端发送数据，肯定是失败的，服务端将会一直等待下去，这样浪费服务端连接资源。 四次挥手由于TCP传输是全双工的，客户端向服务器发送数据的同时服务端也可以向客户端发送数据，所以断开连接需要四次挥手，前两次断开一个方向的连接，后两次断开另一个方向的连接第一次挥手： 当客户端的数据发送完后，向服务端发送一个FIN包请求断开连接{FIN=1,seq=u},客户端进入FIN-WAIT1状态第二次挥手： 服务端收到客户端发来的FIN断开请求后，通知应用程序客户端发送数据完成，不会再发数据了，同时做出应答给客户端发送一个ASK包，{ASK=1,ask=u+1,seq=v},服务端进入CLOSE-WAIT状态，客户端在收到应答后进入FIN-WAIT2状态，此时从客户端到服务端的连接断开，客户端不会发送数据，服务端也不会在接收数据，但这时候服务端还可以向客户端发送数据，还需要接下来的两次挥手第三次挥手： 当服务端的数据发送完以后，也会向客户端发送一个FIN包请求断开连接{FIN=1，ASK=1,seq=w,ask=u+1}，服务端进入LAST-ASK状态第四次挥手： 客户端在接收到断开请求后，进入TIME-WAIT状态，并向服务端发送应答{ASK=1,seq=u+1,ask=w+1},服务端在接收到应答后，进入CLOSED转态，等客户端的TIME-WAIT结束后，客户端也进入CLOSED状态，此时服务端到客户端的连接断开 客户端在收到第三次挥手后为什么没有立即进入关闭状态呢？因为客户端要等服务端收到客户端的应答，如果服务端没有收到应答，服务端会从新发送断开连接的请求，而这时客户端已经关闭了，那么服务端到客户端的连接将永远不能关闭]]></content>
      <categories>
        <category>计算机网络基础</category>
      </categories>
      <tags>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础之OSI参考模型]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[1. OSI参考模型 OSI参考模型的七层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层! 1.1 为什么要分层 分层可以让网络通信系统更加的灵活，每层之间用接口连接，每一层互补干扰，即使有一层发生了改变，但整个系统不受影响 比如上图的通话系统分为语言层和通信设备层，如果把通信设备层的电话机换成无线电照样可以实现通话，同样的把语言层的汉语变成英语，也可以实现通话 1.2 各层的作用 物理层：完成数模和模数转换，完成模拟信号和0和1的比特流之间的转化 数据链路层：互联的设备之间互传数据帧，数据帧和比特流之间的转换 网络层：路由的选择，完成到目的IP地址的路由 传输层：实现可靠的端对端的传输 会话层：何时建立连接何时断开连接，以及收发的顺序 表示层：统一数据的格式，将不同的数据格式转换为网络统一的数据格式 应用层： 针对特定应用的协议1.3 OSI参考模型通信处理举例 当A用户用主机A给使用B主机的B用户发送邮件时在OSI七层参考模型中是怎样处理的呢？假定用户A给用户B发送邮件的内容是“早上好”，接下来我们逐层分析 应用层： 当用户A在软件中输入收件人为B，内容是“早上好”，点击发送后，应用层的协议就开始处理了，应用层的协议会在发送的数据的加上一个头部信息，头部信息包括收件人是用户B内容是“早上好”，然后把数据交给表示层 表示层： 由于不同的机器用的数据格式不一样，如果不统一数据格式的话，到达接收方数据就会乱套，所以表示层协议要做的就是在头部加上数据格式的信息 会话层： 会话层协议处理的就是何时建立连接，何时断开连接，假如用户A要给用户B发送5个邮件，会话层要处理的就是这些邮件的发送顺序，把这些信息加到数据的头部 传输层： 在传输层主机A和主机B之间通信，并建立连接，然后开始发送数据，数据发送完成以后，就断开连接，如果发送的数据有丢失的A会从新发送丢失的数据，所以也会在头部加上相应的信息 网络层： 在主机A和主机B之间的联通是有很多网络组成的，网络层就是地址管理，路由管理，找到目标IP地址，网络层并不能确保数据到达了目标，所以要配合传输层，实现可靠的传输 数据链路层和物理层： 总结：其实整个过程就是一层层的加头部信息，然后B收到数据后一层一层的根据头部信息把头部信息去掉，最后拿到数据]]></content>
      <categories>
        <category>计算机网络基础</category>
      </categories>
      <tags>
        <tag>OSI参考模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+Quartz最简单的HelloWorld入门示例]]></title>
    <url>%2FSpring%2BQuartz%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84HelloWorld%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B.html</url>
    <content type="text"><![CDATA[实现的效果，定时执行有关Quartz不做介绍，可自行学习首先添加依赖 spring相关的依赖根据自己的版本添加，注意要加spring-context-support的依赖，版本和spring的版本保持一致就可以了 123456789101112&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; 写一个要定时执行的类1234567891011public class HelloWordJob &#123; public void sayHi()&#123; try &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date = simpleDateFormat.format(new Date()); System.out.println("hi "+date); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; XML的配置 在spring的配置文件中加入以下代码，其中id=helloWordJob的bean就是你要定时实行的类，其他的不用改 1234567891011121314151617181920212223&lt;!-- job --&gt; &lt;bean id="helloWordJob" class="com.imooc.myo2o.service.impl.HelloWordJob"/&gt; &lt;!-- 使用MethodInvokingJobDetailFactoryBean，任务类可以不实现Job接口，通过targetMethod指定调用方法--&gt; &lt;!-- jobDetail --&gt; &lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="helloWordJob"/&gt; &lt;property name="targetMethod" value="sayHi"/&gt; &lt;!--false表示等上一个任务执行完后再开启新的任务,这里和上一遍博客中的注解@DisallowConcurrentExecution一个道理--&gt; &lt;property name="concurrent" value="false"/&gt; &lt;/bean&gt; &lt;!-- Trigger--&gt; &lt;bean id="helloWordJobCronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="jobDetail"/&gt; &lt;property name="cronExpression" value="0/3 * * * * ?"/&gt; &lt;/bean&gt; &lt;!--Scheduler --&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="helloWordJobCronTrigger"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 这样启动你的Tomcat就可以看到效果了让目标方法按照自己指定的时间执行，可修改 Trigger的cronExpression，可参考在线Cron表达式生成器：https://www.pppet.net/]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java如何利用google的zxing生成二维码，只要两步，超级简单]]></title>
    <url>%2Fjava%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8google%E7%9A%84zxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html</url>
    <content type="text"><![CDATA[实现的效果,在页面中直接引入 12345&lt;html&gt; &lt;body&gt; &lt;img alt="二维码" src="/myo2o/qrcode/generateqrcode"&gt; &lt;/body&gt;&lt;/html&gt; 打开页面，静态页面src地址要写全，前面要加http://localhost:8080首先添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 写一个二维码生成工具类1234567891011121314151617181920212223public static BitMatrix generateQRCodeStream(String content,HttpServletResponse response) &#123; //给相应添加头部信息，主要告诉浏览器返回的是图片流 response.setHeader("Cache-Control", "no-store"); // 不设置缓存 response.setHeader("Pragma", "no-cache"); response.setDateHeader("Expires", 0); response.setContentType("image/png"); //设置图片的文字编码以及内边框 Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;&gt;(); //编码 hints.put(EncodeHintType.CHARACTER_SET, "UTF-8"); //边框距 hints.put(EncodeHintType.MARGIN, 0); BitMatrix bitMatrix; try &#123; //参数分别为：编码内容、编码类型、图片宽度、图片高度，设置参数 bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, 300, 300,hints); &#125;catch(WriterException e) &#123; e.printStackTrace(); return null; &#125; return bitMatrix; &#125; 写一个响应的Controller，在页面的img标签中src写的就是这个地址1234567891011121314151617181920@Controller@RequestMapping("/qrcode")public class QRCodeTestController &#123; @RequestMapping(value = "/generateqrcode", method = RequestMethod.GET) @ResponseBody public void generateQRCode4Product(HttpServletRequest request, HttpServletResponse response) &#123; String longUrl; try &#123; longUrl = "https://blog.csdn.net/victoyr"; // 转换成短url String shortUrl = BaiduDwz.createShortUrl(longUrl); // 生成二维码 BitMatrix qRcodeImg = CodeUtil.generateQRCodeStream(shortUrl, response); // 将二维码输出到页面中 MatrixToImageWriter.writeToStream(qRcodeImg, "png", response.getOutputStream()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 二维码生成的链接不能太长，所以把长链接转换成了短链接，转换方法：https://blog.csdn.net/victoyr/article/details/89679363 ，如果链接不是很长可以不用 Ok啦，是不是很简单呢。]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>zxing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用百度短链接接口将一个长链接变成短链接]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%8E%A5%E5%8F%A3%E5%B0%86%E4%B8%80%E4%B8%AA%E9%95%BF%E9%93%BE%E6%8E%A5%E5%8F%98%E6%88%90%E7%9F%AD%E9%93%BE%E6%8E%A5.html</url>
    <content type="text"><![CDATA[短网址服务可以帮助你把一个长网址缩短，方便你在社交网络和第三方平台上分享链接，投放广告等等。 我们提供超简单的方式使用短网址服务：访问百度短网址首页https://dwz.cn，输入你要缩短的原网址，生成对应的短网址。你还可以调用百度短网址服务API服务，查看数据统计与分析……更多功能，等你来探索！ 官方文档：https://dwz.cn/console/apidoc首先添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; 然后去百度官方文档https://dwz.cn/console/apidoc复制示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.imooc.myo2o.util.baidu;import java.io.IOException;import java.io.OutputStreamWriter;import java.net.HttpURLConnection;import java.net.URL;import java.io.BufferedReader;import java.io.InputStreamReader;import com.google.gson.Gson;import com.google.gson.annotations.SerializedName;public class BaiduDwz &#123; final static String CREATE_API = "https://dwz.cn/admin/v2/create"; final static String TOKEN = "你的token"; // TODO:设置Token class UrlResponse &#123; @SerializedName("Code") private int code; @SerializedName("ErrMsg") private String errMsg; @SerializedName("LongUrl") private String longUrl; @SerializedName("ShortUrl") private String shortUrl; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getErrMsg() &#123; return errMsg; &#125; public void setErrMsg(String errMsg) &#123; this.errMsg = errMsg; &#125; public String getLongUrl() &#123; return longUrl; &#125; public void setLongUrl(String longUrl) &#123; this.longUrl = longUrl; &#125; public String getShortUrl() &#123; return shortUrl; &#125; public void setShortUrl(String shortUrl) &#123; this.shortUrl = shortUrl; &#125; &#125; /** * 创建短网址 * * @param longUrl * 长网址：即原网址 * @return 成功：短网址 * 失败：返回空字符串 */ public static String createShortUrl(String longUrl) &#123; String params = "&#123;\"url\":\""+ longUrl + "\"&#125;"; BufferedReader reader = null; try &#123; // 创建连接 URL url = new URL(CREATE_API); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); connection.setRequestMethod("POST"); // 设置请求方式 connection.setRequestProperty("Content-Type", "application/json"); // 设置发送数据的格式 connection.setRequestProperty("Token", TOKEN); // 设置发送数据的格式"); // 发起请求 connection.connect(); OutputStreamWriter out = new OutputStreamWriter(connection.getOutputStream(), "UTF-8"); // utf-8编码 out.append(params); out.flush(); out.close(); // 读取响应 reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8")); String line; String res = ""; while ((line = reader.readLine()) != null) &#123; res += line; &#125; reader.close(); // 抽取生成短网址 UrlResponse urlResponse = new Gson().fromJson(res, UrlResponse.class); if (urlResponse.getCode() == 0) &#123; return urlResponse.getShortUrl(); &#125; else &#123; System.out.println(urlResponse.getErrMsg()); &#125; return ""; // TODO：自定义错误信息 &#125; catch (IOException e) &#123; // TODO e.printStackTrace(); &#125; return ""; // TODO：自定义错误信息 &#125; public static void main(String[] args) &#123; String res = createShortUrl("你的长网址"); System.out.println(res); &#125;&#125; 把代码中的token换成你的token在官方文档https://dwz.cn/console/apidoc中获取token到此就ok了，可以在main方法中试一下效果]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>百度短链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号如何授权登录、获取用户信息(openid)]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%A6%82%E4%BD%95%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E3%80%81%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF(openid).html</url>
    <content type="text"><![CDATA[首先看一下实现的效果，在公众号中，用户进入你的应用之前，会弹出一个授权页面，当用户点击确认后，你就可以获取用户的信息 首先访问微信测试号登录页面，通过打开自己手机的微信，扫一扫登录https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login进入到测试号页面后，分别看到如下信息【测试号信息】appID:开发者ID，是公众号开发识别码，配合开发者密码可以调用微信公众号接口，如获取微信昵称等appsecret:开发者密码，是检验公众号开发者身份的密码，具有极高的安全性。切记不要把密码交给第三方开发者或者编写到代码里【接口配置信息】URL: 是开发者用来接收微信消息和事件的接口URL，要用域名不能用ipToken:由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性） 当你填完URL和Token点击提交后，微信会访问你填写的URL，所以要在后台写一个servlet来处理这个请求 处理请求的Controller 1234567891011121314151617181920212223242526272829@Controller@RequestMapping("wechat")public class WeiXinController &#123; @RequestMapping(method = &#123; RequestMethod.GET &#125;) public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; // 微信加密签名 String signature = request.getParameter("signature"); // 时间戳 String timestamp = request.getParameter("timestamp"); // 随机数 String nonce = request.getParameter("nonce"); // 随机字符串 String echostr = request.getParameter("echostr"); // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败 PrintWriter out = null; try &#123; out = response.getWriter(); if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123; log.debug("weixin get success...."); out.print(echostr); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (out != null) out.close(); &#125; &#125;&#125; 微信请求校验工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 微信请求校验工具类 */public class SignUtil &#123; // 与接口配置信息中的Token要一致 private static String token = "mytoken"; /** * 验证签名 * @param signature * @param timestamp * @param nonce * @return */ public static boolean checkSignature(String signature, String timestamp, String nonce) &#123; String[] arr = new String[] &#123; token, timestamp, nonce &#125;; // 将token、timestamp、nonce三个参数进行字典序排序 Arrays.sort(arr); StringBuilder content = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; content.append(arr[i]); &#125; MessageDigest md = null; String tmpStr = null; try &#123; md = MessageDigest.getInstance("SHA-1"); // 将三个参数字符串拼接成一个字符串进行sha1加密 byte[] digest = md.digest(content.toString().getBytes()); tmpStr = byteToStr(digest); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; content = null; // 将sha1加密后的字符串可与signature对比，标识该请求来源于微信 return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false; &#125; /** * 将字节数组转换为十六进制字符串 * @param byteArray * @return */ private static String byteToStr(byte[] byteArray) &#123; String strDigest = ""; for (int i = 0; i &lt; byteArray.length; i++) &#123; strDigest += byteToHexStr(byteArray[i]); &#125; return strDigest; &#125; /** * 将字节转换为十六进制字符串 * @param mByte * @return */ private static String byteToHexStr(byte mByte) &#123; char[] Digit = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' &#125;; char[] tempArr = new char[2]; tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F]; tempArr[1] = Digit[mByte &amp; 0X0F]; String s = new String(tempArr); return s; &#125;&#125; 请求的处理程序写完后把项目重新打包发布到服务器上去，再提交你填写的URL和Token，接口配置信息就Ok啦 【JS接口安全域名】域名：想调用jssdk(如想要通过微信公众号js接口获取地图等工具)必须得填写此域名，在此域名的范围内才能调用jssdk工具，注意这里必须是域名，不是带有http之类的URL【测试号二维码】里面包含了测试号二维码以及已经关注了的用户信息【体验接口权限表】这里主要介绍【网页服务】里面的【网页帐号】网页帐号主要用来设置OAuth2.0里面的网页授权域名，用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。沙盒号回调地址支持域名和ip，正式公众号回调地址只支持域名。接下来需要编写自己的程序以获取关注此公众号的用户信息需要编写5个类 WechatLoginController.java，UserAccessToken.java，WechatUser.java，WechatUtil.java以及MyX509TrustManager.java【WechatLoginController】主要用来获取已关注此微信号的用户信息并做相应处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Controller@RequestMapping("wechatlogin")/** * 获取关注公众号之后的微信用户信息的接口，如果在微信浏览器里访问 * https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appId&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect * 则这里将会获取到code,之后再可以通过code获取到access_token 进而获取到用户信息 */public class WechatLoginController &#123; private static Logger log = LoggerFactory.getLogger(WechatLoginController.class); @RequestMapping(value = "/logincheck", method = &#123; RequestMethod.GET &#125;) public String doGet(HttpServletRequest request, HttpServletResponse response) &#123; log.debug("weixin login get..."); // 获取微信公众号传输过来的code,通过code可获取access_token,进而获取用户信息 String code = request.getParameter("code"); // 这个state可以用来传我们自定义的信息，方便程序调用，这里也可以不用 // String roleType = request.getParameter("state"); log.debug("weixin login code:" + code); WechatUser user = null; String openId = null; if (null != code) &#123; UserAccessToken token; try &#123; // 通过code获取access_token token = WechatUtil.getUserAccessToken(code); log.debug("weixin login token:" + token.toString()); // 通过token获取accessToken String accessToken = token.getAccessToken(); // 通过token获取openId openId = token.getOpenId(); // 通过access_token和openId获取用户昵称等信息 user = WechatUtil.getUserInfo(accessToken, openId); log.debug("weixin login user:" + user.toString()); request.getSession().setAttribute("openId", openId); &#125; catch (IOException e) &#123; log.error("error in getUserAccessToken or getUserInfo or findByOpenId: " + e.toString()); e.printStackTrace(); &#125; &#125; // ======todo begin====== // 前面咱们获取到openId后，可以通过它去数据库判断该微信帐号是否在我们网站里有对应的帐号了， // 没有的话这里可以自动创建上，直接实现微信与咱们网站的无缝对接。 // ======todo end====== if (user != null) &#123; // 获取到微信验证的信息后返回到指定的路由（需要自己设定） return "frontend/index"; &#125; else &#123; return null; &#125; &#125;&#125; 【UserAccessToken】用户AccessToken实体类，用来接收accesstoken以及openid等信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 用户授权token * */public class UserAccessToken &#123; // 获取到的凭证 @JsonProperty("access_token") private String accessToken; // 凭证有效时间，单位：秒 @JsonProperty("expires_in") private String expiresIn; // 表示更新令牌，用来获取下一次的访问令牌，这里没太大用处 @JsonProperty("refresh_token") private String refreshToken; // 该用户在此公众号下的身份标识，对于此微信号具有唯一性 @JsonProperty("openid") private String openId; // 表示权限范围，这里可省略 @JsonProperty("scope") private String scope; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public String getExpiresIn() &#123; return expiresIn; &#125; public void setExpiresIn(String expiresIn) &#123; this.expiresIn = expiresIn; &#125; public String getRefreshToken() &#123; return refreshToken; &#125; public void setRefreshToken(String refreshToken) &#123; this.refreshToken = refreshToken; &#125; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public String getScope() &#123; return scope; &#125; public void setScope(String scope) &#123; this.scope = scope; &#125; @Override public String toString() &#123; return "accessToken:" + this.getAccessToken() + ",openId:" + this.getOpenId(); &#125;&#125; 【WechatUser】微信用户实体类，用来接收昵称 openid等用户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * 微信用户实体类 */public class WechatUser implements Serializable &#123; private static final long serialVersionUID = -4684067645282292327L; // openId,标识该公众号下面的该用户的唯一Id @JsonProperty("openid") private String openId; // 用户昵称 @JsonProperty("nickname") private String nickName; // 性别 @JsonProperty("sex") private int sex; // 省份 @JsonProperty("province") private String province; // 城市 @JsonProperty("city") private String city; // 区 @JsonProperty("country") private String country; // 头像图片地址 @JsonProperty("headimgurl") private String headimgurl; // 语言 @JsonProperty("language") private String language; // 用户权限，这里没什么作用 @JsonProperty("privilege") private String[] privilege; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getCountry() &#123; return country; &#125; public void setCountry(String country) &#123; this.country = country; &#125; public String getHeadimgurl() &#123; return headimgurl; &#125; public void setHeadimgurl(String headimgurl) &#123; this.headimgurl = headimgurl; &#125; public String getLanguage() &#123; return language; &#125; public void setLanguage(String language) &#123; this.language = language; &#125; public String[] getPrivilege() &#123; return privilege; &#125; public void setPrivilege(String[] privilege) &#123; this.privilege = privilege; &#125; @Override public String toString() &#123; return "openId:" + this.getOpenId() + ",nikename:" + this.getNickName(); &#125;&#125; 【WechatUtil】主要用来提交https请求给微信获取用户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 微信工具类 */public class WechatUtil &#123; private static Logger log = LoggerFactory.getLogger(WechatUtil.class); /** * 获取UserAccessToken实体类 * @param code * @return * @throws IOException */ public static UserAccessToken getUserAccessToken(String code) throws IOException &#123; // 测试号信息里的appId String appId = "您的appId"; log.debug("appId:" + appId); // 测试号信息里的appsecret String appsecret = "您的appsecret"; log.debug("secret:" + appsecret); // 根据传入的code,拼接出访问微信定义好的接口的URL String url = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=" + appId + "&amp;secret=" + appsecret + "&amp;code=" + code + "&amp;grant_type=authorization_code"; // 向相应URL发送请求获取token json字符串 String tokenStr = httpsRequest(url, "GET", null); log.debug("userAccessToken:" + tokenStr); UserAccessToken token = new UserAccessToken(); ObjectMapper objectMapper = new ObjectMapper(); try &#123; // 将json字符串转换成相应对象 token = objectMapper.readValue(tokenStr, UserAccessToken.class); &#125; catch (JsonParseException e) &#123; log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (IOException e) &#123; log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); &#125; if (token == null) &#123; log.error("获取用户accessToken失败。"); return null; &#125; return token; &#125; /** * 获取WechatUser实体类 * @param accessToken * @param openId * @return */ public static WechatUser getUserInfo(String accessToken, String openId) &#123; // 根据传入的accessToken以及openId拼接出访问微信定义的端口并获取用户信息的URL String url = "https://api.weixin.qq.com/sns/userinfo?access_token=" + accessToken + "&amp;openid=" + openId + "&amp;lang=zh_CN"; // 访问该URL获取用户信息json 字符串 String userStr = httpsRequest(url, "GET", null); log.debug("user info :" + userStr); WechatUser user = new WechatUser(); ObjectMapper objectMapper = new ObjectMapper(); try &#123; // 将json字符串转换成相应对象 user = objectMapper.readValue(userStr, WechatUser.class); &#125; catch (JsonParseException e) &#123; log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (IOException e) &#123; log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); &#125; if (user == null) &#123; log.error("获取用户信息失败。"); return null; &#125; return user; &#125; /** * 发起https请求并获取结果 * @param requestUrl * 请求地址 * @param requestMethod * 请求方式（GET、POST） * @param outputStr * 提交的数据 * @return json字符串 */ public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) &#123; StringBuffer buffer = new StringBuffer(); try &#123; // 创建SSLContext对象，并使用我们指定的信任管理器初始化 TrustManager[] tm = &#123; new MyX509TrustManager() &#125;; SSLContext sslContext = SSLContext.getInstance("SSL", "SunJSSE"); sslContext.init(null, tm, new java.security.SecureRandom()); // 从上述SSLContext对象中得到SSLSocketFactory对象 SSLSocketFactory ssf = sslContext.getSocketFactory(); URL url = new URL(requestUrl); HttpsURLConnection httpUrlConn = (HttpsURLConnection) url.openConnection(); httpUrlConn.setSSLSocketFactory(ssf); httpUrlConn.setDoOutput(true); httpUrlConn.setDoInput(true); httpUrlConn.setUseCaches(false); // 设置请求方式（GET/POST） httpUrlConn.setRequestMethod(requestMethod); if ("GET".equalsIgnoreCase(requestMethod)) httpUrlConn.connect(); // 当有数据需要提交时 if (null != outputStr) &#123; OutputStream outputStream = httpUrlConn.getOutputStream(); // 注意编码格式，防止中文乱码 outputStream.write(outputStr.getBytes("UTF-8")); outputStream.close(); &#125; // 将返回的输入流转换成字符串 InputStream inputStream = httpUrlConn.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream, "utf-8"); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String str = null; while ((str = bufferedReader.readLine()) != null) &#123; buffer.append(str); &#125; bufferedReader.close(); inputStreamReader.close(); // 释放资源 inputStream.close(); inputStream = null; httpUrlConn.disconnect(); log.debug("https buffer:" + buffer.toString()); &#125; catch (ConnectException ce) &#123; log.error("Weixin server connection timed out."); &#125; catch (Exception e) &#123; log.error("https request error:&#123;&#125;", e); &#125; return buffer.toString(); &#125;&#125; 【MyX509TrustManager】主要继承X509TrustManager做https证书信任管理器 12345678910111213141516/** * 证书信任管理器（用于https请求） * */public class MyX509TrustManager implements X509TrustManager &#123; public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; public X509Certificate[] getAcceptedIssuers() &#123; return null; &#125;&#125; 之后重新打包一个新的war包并发布到服务器tomcat webapps目录下发布成功后，关注你自己的测试号(即扫描测试号的那个二维码)，然后在手机微信里面或者微信开发者工具里访问相应链接：https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appId&amp;redirect_uri=WechatLoginController对应的地址&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>微信公众号开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下使用crontab如何实现mysql数据库每天自动备份定时备份]]></title>
    <url>%2Flinux%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%8F%E5%A4%A9%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%EF%BC%8C%E5%B9%B6%E5%8F%AA%E4%BF%9D%E7%95%99%E8%BF%917%E5%A4%A9%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[1. 编辑shell脚本 (备份&amp;清理)123456789101112131415#!/bin/bash#在此设置要备份的数据库名,以TEST为例DBNAME="TEST" #备份数据临时存放位置,备份完成之后自动删除. BACKDIR="/home/root/backup/" #获取系统时间DATE=`date +%Y%m%d`#备份文件名以时间命名 FILENAME=dump_$&#123;DATE&#125;.sql #进入备份目录cd $&#123;BACKDIR&#125; #备份数据库并追加日志mysqldump -uroot -proot --databases TEST &gt; $&#123;BACKDIR&#125;$&#123;FILENAME&#125; &gt;&gt; db_backup.log#删除近7天文件find $&#123;BACKDIR&#125; -mtime +7 -name "*.sql" -exec rm -rf &#123;&#125; \; 2. 将脚本加入crontab自动执行计划添加计划 1crontab -e 加入一行:12#每天晚上11点半, 执行对应路径下的脚本.30 23 * * * /home/root/backup.sh 保存退出(vim命令) 3. Cron 各项的描述以下是 crontab 文件的格式： {minute} {hour} {day-of-month} {month} {day-of-week} {full-path-to-shell-script}minute: 区间为 0 – 59hour: 区间为0 – 23day-of-month: 区间为0 – 31month: 区间为1 – 12. 1 是1月. 12是12月.Day-of-week: 区间为0 – 7. 周日可以是0或7. 4.Crontab 示例 在 12:01 a.m 运行，即每天凌晨过一分钟。这是一个恰当的进行备份的时间，因为此时系统负载不大。 11 0 * * * /root/bin/backup.sh 每个工作日(Mon – Fri) 11:59 p.m 都进行备份作业。 1259 11 * * 1,2,3,4,5 /root/bin/backup.sh#或者59 11 * * 1-5 /root/bin/backup.sh效果一样 每5分钟运行一次命令 1*/5 * * * * /root/bin/check-status.sh 每个月的第一天 1:10 p.m 运行 110 13 1 * * /root/bin/full-backup.sh 每个工作日 11 p.m 运行。 10 23 * * 1-5 /root/bin/incremental-backup.sh 5. crontab常用的命令 12345678910service crond start //启动服务service crond stop //关闭服务service crond restart //重启服务service crond reload //重新载入配置service crond status //查看服务状态 crontab –e //往 cron 中添加一个作业crontab –e //修改 crontab 文件. 如果文件不存在会自动创建。 crontab –l //显示 crontab 文件。 crontab -r //删除 crontab 文件。crontab -ir //删除 crontab 文件前提醒用户]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对项目中关键的配置信息进行加密]]></title>
    <url>%2F%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B3%E9%94%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86.html</url>
    <content type="text"><![CDATA[我们在搭键一个项目的时候，有一些信息，比如数据库的连接信息通常会放在一个配置文件中，存放的是明码，我们可以对关键信息比如用户名和密码进行加密，就算别人获取了也没有用 加密后的效果 1234db.username = WnplV/ietfQ=db.password = j9ZTgFZm4H7r0AteGA6A7A==db.driver = com.mysql.jdbc.Driverdb.url = jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf8 一、首先创建一个加密的工具类，对信息进行加密我用的是DES对称加密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.edward.o2o.util;import java.security.Key;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;public class DESUtils &#123; private static Key key; private static String KEY_STR = "myKey"; private static String CHARSETNAME = "UTF-8"; private static String ALGORITHM = "DES"; static &#123; try &#123; KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM); SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG"); secureRandom.setSeed(KEY_STR.getBytes()); generator.init(secureRandom); key = generator.generateKey(); generator = null; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static String getEncryptString(String str) &#123; BASE64Encoder base64encoder = new BASE64Encoder(); try &#123; byte[] bytes = str.getBytes(CHARSETNAME); Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] doFinal = cipher.doFinal(bytes); return base64encoder.encode(doFinal); &#125; catch (Exception e) &#123; // TODO: handle exception throw new RuntimeException(e); &#125; &#125; public static String getDecryptString(String str) &#123; BASE64Decoder base64decoder = new BASE64Decoder(); try &#123; byte[] bytes = base64decoder.decodeBuffer(str); Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, key); byte[] doFinal = cipher.doFinal(bytes); return new String(doFinal, CHARSETNAME); &#125; catch (Exception e) &#123; // TODO: handle exception throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; System.out.println(getEncryptString("root")); System.out.println(getEncryptString("123456abCD.")); System.out.println(getEncryptString("wxd7f6c5b8899fba83")); System.out.println(getEncryptString("665ae80dba31fc91ab6191e7da4d676d")); &#125;&#125; 通过main方法，把要加密的信息输出到控制台得到密文,再把对应的明文换成加密后的密文 二、创建一个PropertyPlaceholderConfigurer的后置处理器，在spring中解析配置文件1234567891011121314151617181920212223242526package com.edward.o2o.util;import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;public class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer &#123; private String[] encryptPropNames = &#123; "db.username", "db.password" &#125;; @Override protected String convertProperty(String propertyName, String propertyValue) &#123; if (isEncryptProp(propertyName)) &#123; String decryptValue = DESUtils.getDecryptString(propertyValue); return decryptValue; &#125; else &#123; return propertyValue; &#125; &#125; private boolean isEncryptProp(String propertyName) &#123; for (String encryptpropertyName : encryptPropNames) &#123; if (encryptpropertyName.equals(propertyName)) return true; &#125; return false; &#125;&#125; 三、把配置文件加载到spring的配置文件中12345678910&lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;&lt;!--&lt;context:property-placeholder location="classpath:db.properties"/&gt;--&gt;&lt;bean class="com.edward.o2o.util.EncryptPropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="fileEncoding" value="UTF-8" /&gt;&lt;/bean&gt; class就是第二步中用于解析配置文件的类 总结： 整个过程就是利用加密的工具类对关键信息加密把原文替换成密文，然后在spring的配置文件中加载需要的配置文件（比如数据库的配置文件），加载过程中PropertyPlaceholderConfigurer后置处理器会调用加密工具类中的解密文件返回明文 PropertyPlaceholderConfigurer是个bean工厂后置处理器的实现，也就是 BeanFactoryPostProcessor接口的一个实现。PropertyPlaceholderConfigurer可以将上下文（配置文 件）中的属性值放在另一个单独的标准java Properties文件中去。在XML文件中用${key}替换指定的properties文件中的值。这样的话，只需要对properties文件进 行修改，而不用对xml配置文件进行修改。]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合逐层配置]]></title>
    <url>%2FSSM%E6%95%B4%E5%90%88%E9%80%90%E5%B1%82%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[使用SSM（Spring、SpringMVC和Mybatis）已经有三个多月了，项目在技术上已经没有什么难点了，基于现有的技术就可以实现想要的功能，当然肯定有很多可以改进的地方。之前没有记录SSM整合的过程，这次刚刚好基于自己的一个小项目重新搭建了一次，而且比项目搭建的要更好一些。以前解决问题的过程和方法并没有及时记录，以后在自己的小项目中遇到我再整理分享一下。这次，先说说三大框架整合过程。个人认为使用框架并不是很难，关键要理解其思想，这对于我们提高编程水平很有帮助。不过，如果用都不会，谈思想就变成纸上谈兵了！！！先技术，再思想。实践出真知。 一、Dao层配置1.spring-dao.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name="driverClass" value="$&#123;db.driver&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;db.url&#125;" /&gt; &lt;property name="user" value="$&#123;db.username&#125;" /&gt; &lt;property name="password" value="$&#123;db.password&#125;" /&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name="maxPoolSize" value="30" /&gt; &lt;property name="minPoolSize" value="10" /&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name="autoCommitOnClose" value="false" /&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="10000" /&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2" /&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.edward.o2o.entity" /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.edward.o2o.dao" /&gt; &lt;/bean&gt;&lt;/beans&gt; 2.db.properties1234db.username = rootdb.password = 123456abcddb.driver = com.mysql.jdbc.Driverdb.url = jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf8 3.mybatis-config.xml12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;!-- 打印查询语句 --&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt;&lt;/configuration&gt; 二、service层配置spring-service.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="com.edward.o2o.service" /&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; 三、web层配置spring-web.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解模式 --&gt; &lt;!-- 简化配置： (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 --&gt; &lt;mvc:annotation-driven &gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes" value="text/html;charset=UTF-8"/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用"/"做整体映射 --&gt; &lt;mvc:resources mapping="/resources/**" location="/resources/" /&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 3.定义视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/html/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".html"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package="com.edward.o2o.web" /&gt;&lt;/beans&gt; 四、最后配置web.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;filter&gt; &lt;filter-name&gt;SpringEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SpringEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - &gt; spring -&gt; springmvc --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot 2.1.3配置Druid数据源]]></title>
    <url>%2Fspring-boot%202.1.3%E9%85%8D%E7%BD%AEDruid%E6%95%B0%E6%8D%AE%E6%BA%90.html</url>
    <content type="text"><![CDATA[1.在pom文件添加依赖 12345678910111213&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j yml配置文件中filters: stat,wall,log4j所以要加此依赖，否侧会报错--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 2.在配置文件中配置数据库信息1234567891011121314151617181920212223242526spring: datasource:# 数据源基本配置 username: root password: 123456abcd driver-class-name: com.mysql.cj.jdbc.Driver #注意要配置serverTimezone等信息 url: jdbc:mysql://localhost:3306/books?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false type: com.alibaba.druid.pool.DruidDataSource# 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 3.添加Druid的配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.edward.springbootmybaties.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig &#123; @Bean //这样yml配置文件才会起作用，和Druid类绑定起来 @ConfigurationProperties(prefix = "spring.datasource") public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125;]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>

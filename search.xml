<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL的InnoDB索引原理详解]]></title>
    <url>%2FMySQL%E7%9A%84InnoDB%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[摘要： 本篇介绍下Mysql的InnoDB索引相关知识，从各种树到索引原理到存储的细节。 InnoDB是Mysql的默认存储引擎(Mysql5.5.5之前是MyISAM，文档)。本着高效学习的目的，本篇以介绍InnoDB为主，少量涉及MyISAM作为对比。 这篇文章是我在学习过程中总结完成的，内容主要来自书本和博客(参考文献会给出)，过程中加入了一些自己的理解，描述不准确的地方烦请指出。 1 各种树形结构 本来不打算从二叉搜索树开始，因为网上已经有太多相关文章，但是考虑到清晰的图示对理解问题有很大帮助，也为了保证文章完整性，最后还是加上了这部分。 先看看几种树形结构： 1 搜索二叉树：每个节点有两个子节点，数据量的增大必然导致高度的快速增加，显然这个不适合作为大量数据存储的基础结构。 2 B树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；一个节点的子节点数量会比关键字个数多1，这样关键字就变成了子节点的分割标志。一般会在图示中把关键字画到子节点中间，非常形象，也容易和后面的B+树区分。由于数据同时存在于叶子节点和非叶子结点中，无法简单完成按顺序遍历B树中的关键字，必须用中序遍历的方法。 3 B+树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m；子树的个数最多可以与关键字一样多。非叶节点存储的是子树里最小的关键字。同时数据节点只存在于叶子节点中，且叶子节点间增加了横向的指针，这样顺序遍历所有数据将变得非常容易。 4 B树：一棵m阶B树是一棵平衡的m路搜索树。最重要的两个性质是1每个非根节点所包含的关键字个数 j 满足：┌m2/3┐ - 1 &lt;= j &lt;= m；2非叶节点间添加了横向指针。 B/B+/B三种树有相似的操作，比如检索/插入/删除节点。这里只重点关注插入节点的情况，且只分析他们在当前节点已满情况下的插入操作，因为这个动作稍微复杂且能充分体现几种树的差异。与之对比的是检索节点比较容易实现，而删除节点只要完成与插入相反的过程即可（在实际应用中删除并不是插入的完全逆操作，往往只删除数据而保留下空间为后续使用）。 先看B树的分裂，下图的红色值即为每次新插入的节点。每当一个节点满后，就需要发生分裂（分裂是一个递归过程，参考下面7的插入导致了两层分裂），由于B树的非叶子节点同样保存了键值，所以已满节点分裂后的值将分布在三个地方：1原节点，2原节点的父节点，3原节点的新建兄弟节点（参考5，7的插入过程）。分裂有可能导致树的高度增加（参考3，7的插入过程），也可能不影响树的高度（参考5，6的插入过程）。 B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟节点的指针。 B树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）。如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。可以看到B树的分裂非常巧妙，因为B树要保证分裂后的节点还要2/3满，如果采用B+树的方法，只是简单的将已满的节点一分为二，会导致每个节点只有1/2满，这不满足B树的要求了。所以B树采取的策略是在本节点满后，继续插入兄弟节点（这也是为什么B树需要在非叶子节点加一个兄弟间的链表），直到把兄弟节点也塞满，然后拉上兄弟节点一起凑份子，自己和兄弟节点各出资1/3成立新节点，这样的结果是3个节点刚好是2/3满，达到B树的要求，皆大欢喜。 B+树适合作为数据库的基础结构，完全是因为计算机的内存-机械硬盘两层存储结构。内存可以完成快速的随机访问（随机访问即给出任意一个地址，要求返回这个地址存储的数据）但是容量较小。而硬盘的随机访问要经过机械动作（1磁头移动 2盘片转动），访问效率比内存低几个数量级，但是硬盘容量较大。典型的数据库容量大大超过可用内存大小，这就决定了在B+树中检索一条数据很可能要借助几次磁盘IO操作来完成。如下图所示：通常向下读取一个节点的动作可能会是一次磁盘IO操作，不过非叶节点通常会在初始阶段载入内存以加快访问速度。同时为提高在节点间横向遍历速度，真实数据库中可能会将图中蓝色的CPU计算/内存读取优化成二叉搜索树（InnoDB中的page directory机制）。 真实数据库中的B+树应该是非常扁平的，可以通过向表中顺序插入足够数据的方式来验证InnoDB中的B+树到底有多扁平。我们通过如下图的CREATE语句建立一个只有简单字段的测试表，然后不断添加数据来填充这个表。通过下图的统计数据（来源见参考文献1）可以分析出几个直观的结论，这几个结论宏观的展现了数据库里B+树的尺度。 1 每个叶子节点存储了468行数据，每个非叶子节点存储了大约1200个键值，这是一棵平衡的1200路搜索树！ 2 对于一个22.1G容量的表，也只需要高度为3的B+树就能存储了，这个容量大概能满足很多应用的需要了。如果把高度增大到4，则B+树的存储容量立刻增大到25.9T之巨！ 3 对于一个22.1G容量的表，B+树的高度是3，如果要把非叶节点全部加载到内存也只需要少于18.8M的内存（如何得出的这个结论？因为对于高度为2的树，1203个叶子节点也只需要18.8M空间，而22.1G从良表的高度是3，非叶节点1204个。同时我们假设叶子节点的尺寸是大于非叶节点的，因为叶子节点存储了行数据而非叶节点只有键和少量数据。），只使用如此少的内存就可以保证只需要一次磁盘IO操作就检索出所需的数据，效率是非常之高的。 2 Mysql的存储引擎和索引 可以说数据库必须有索引，没有索引则检索过程变成了顺序查找，O(n)的时间复杂度几乎是不能忍受的。我们非常容易想象出一个只有单关键字组成的表如何使用B+树进行索引，只要将关键字存储到树的节点即可。当数据库一条记录里包含多个字段时，一棵B+树就只能存储主键，如果检索的是非主键字段，则主键索引失去作用，又变成顺序查找了。这时应该在第二个要检索的列上建立第二套索引。 &nbsp;这个索引由独立的B+树来组织。有两种常见的方法可以解决多个B+树访问同一套表数据的问题，一种叫做聚簇索引（clustered index&nbsp;），一种叫做非聚簇索引（secondary index）。这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种数据存储方式。对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。对于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。 InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。 MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。 为了更形象说明这两种索引的区别，我们假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。 我们重点关注聚簇索引，看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？ 1 由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。 2 辅助索引使用主键作为”指针” 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”。也就是说行的位置（实现中通过16K的Page来定位，后面会涉及）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。 3 Page结构 如果说前面的内容偏向于解释原理，那后面就开始涉及具体实现了。 理解InnoDB的实现不得不提Page结构，Page是整个InnoDB存储的最基本构件，也是InnoDB磁盘管理的最小单位，与数据库相关的所有内容都存储在这种Page结构里。Page分为几种类型，常见的页类型有数据页（B-tree Node）Undo页（Undo Log Page）系统页（System Page） 事务数据页（Transaction System Page）等。单个Page的大小是16K（编译宏UNIV_PAGE_SIZE控制），每个Page使用一个32位的int值来唯一标识，这也正好对应InnoDB最大64TB的存储容量（16Kib 2^32 = 64Tib）。一个Page的基本结构如下图所示： 每个Page都有通用的头和尾，但是中部的内容根据Page的类型不同而发生变化。Page的头部里有我们关心的一些数据，下图把Page的头部详细信息显示出来：&nbsp; 我们重点关注和数据组织结构相关的字段：Page的头部保存了两个指针，分别指向前一个Page和后一个Page，头部还有Page的类型信息和用来唯一标识Page的编号。根据这两个指针我们很容易想象出Page链接起来就是一个双向链表的结构。 再看看Page的主体内容，我们主要关注行数据和索引的存储，他们都位于Page的User Records部分，User Records占据Page的大部分空间，User Records由一条一条的Record组成，每条记录代表索引树上的一个节点（非叶子节点和叶子节点）。在一个Page内部，单链表的头尾由固定内容的两条记录来表示，字符串形式的”Infimum”代表开头，”Supremum”代表结尾。这两个用来代表开头结尾的Record存储在System Records的段里，这个System Records和User Records是两个平行的段。InnoDB存在4种不同的Record，它们分别是1主键索引树非叶节点 2主键索引树叶子节点 3辅助键索引树非叶节点 4辅助键索引树叶子节点。这4种节点的Record格式有一些差异，但是它们都存储着Next指针指向下一个Record。后续我们会详细介绍这4种节点，现在只需要把Record当成一个存储了数据同时含有Next指针的单链表节点即可。 User Record在Page内以单链表的形式存在，最初数据是按照插入的先后顺序排列的，但是随着新数据的插入和旧数据的删除，数据物理顺序会变得混乱，但他们依然保持着逻辑上的先后顺序。 把User Record的组织形式和若干Page组合起来，就看到了稍微完整的形式。 现在看下如何定位一个Record： 1 通过根节点开始遍历一个索引的B+树，通过各层非叶子节点最终到达一个Page，这个Page里存放的都是叶子节点。 2 在Page内从”Infimum”节点开始遍历单链表（这种遍历往往会被优化），如果找到该键则成功返回。如果记录到达了”supremum”，说明当前Page里没有合适的键，这时要借助Page的Next Page指针，跳转到下一个Page继续从”Infimum”开始逐个查找。 详细看下不同类型的Record里到底存储了什么数据，根据B+树节点的不同，User Record可以被分成四种格式，下图种按照颜色予以区分。 1 主索引树非叶节点（绿色） 1 子节点存储的主键里最小的值（Min Cluster Key on Child），这是B+树必须的，作用是在一个Page里定位到具体的记录的位置。 2 最小的值所在的Page的编号（Child Page Number），作用是定位Record。 2 主索引树叶子节点（黄色） 1 主键（Cluster Key Fields），B+树必须的，也是数据行的一部分 2 除去主键以外的所有列（Non-Key Fields），这是数据行的除去主键的其他所有列的集合。 这里的1和2两部分加起来就是一个完整的数据行。 3 辅助索引树非叶节点非（蓝色） 1 子节点里存储的辅助键值里的最小的值（Min Secondary-Key on Child），这是B+树必须的，作用是在一个Page里定位到具体的记录的位置。 2 主键值（Cluster Key Fields），非叶子节点为什么要存储主键呢？因为辅助索引是可以不唯一的，但是B+树要求键的值必须唯一，所以这里把辅助键的值和主键的值合并起来作为在B+树中的真正键值，保证了唯一性。但是这也导致在辅助索引B+树中非叶节点反而比叶子节点多了4个字节。（即下图中蓝色节点反而比红色多了4字节） 3 最小的值所在的Page的编号（Child Page Number），作用是定位Record。 4 辅助索引树叶子节点（红色） 1 辅助索引键值（Secondary Key Fields），这是B+树必须的。 2 主键值（Cluster Key Fields），用来在主索引树里再做一次B+树检索来找到整条记录。 下面是本篇最重要的部分了，结合B+树的结构和前面介绍的4种Record的内容，我们终于可以画出一幅全景图。由于辅助索引的B+树与主键索引有相似的结构，这里只画出了主键索引树的结构图，只包含了”主键非叶节点”和”主键叶子节点”两种节点，也就是上图的的绿色和黄色的部分。 把上图还原成下面这个更简洁的树形示意图，这就是B+树的一部分。注意Page和B+树节点之间并没有一一对应的关系，Page只是作为一个Record的保存容器，它存在的目的是便于对磁盘空间进行批量管理，上图中的编号为47的Page在树形结构上就被拆分成了两个独立节点。 至此本篇就算结束了，本篇只是对InnoDB索引相关的数据结构和实现进行了一些梳理总结，并未涉及到Mysql的实战经验。这主要是基于几点原因： 1 原理是基石，只有充分了解InnoDB索引的工作方式，我们才有能力高效的使用好它。 2 原理性知识特别适合使用图示，我个人非常喜欢这种表达方式。 3 关于InnoDB优化，在《高性能Mysql》里有更加全面的介绍，对优化Mysql感兴趣的同学完全可以自己获取相关知识，我自己的积累还未达到能分享这些内容的地步。 另：对InnoDB实现有更多兴趣的同学可以看看Jeremy Cole的博客（参考文献三篇文章的来源），这位老兄曾先后在Mysql，Yahoo，Twitter，Google从事数据库相关工作，他的文章非常棒！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql数据库知识点总结02-索引]]></title>
    <url>%2FMySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9302-%E7%B4%A2%E5%BC%95.html</url>
    <content type="text"><![CDATA[数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。 索引是什么？&nbsp; &nbsp; &nbsp;数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。 索引原理&nbsp; &nbsp; &nbsp;索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等。磁盘IO与预读&nbsp; &nbsp; &nbsp;考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。索引的两大类型Hash索引和B树索引&nbsp; &nbsp; &nbsp;Hash类型的索引：查询单条快，范围查询慢。&nbsp; &nbsp; &nbsp;B树类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）。&nbsp; 不同的存储引擎支持的索引类型也不一样&nbsp; &nbsp; &nbsp;InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引。&nbsp; &nbsp; &nbsp;MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引。&nbsp; &nbsp; &nbsp;Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引。Hash索引的限制&nbsp; &nbsp; &nbsp;1.由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。&nbsp; &nbsp; &nbsp;2.不能使用hash索引排序。&nbsp; &nbsp; &nbsp;3.Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。&nbsp; &nbsp; &nbsp;4.Hash索引只支持等值比较，例如使用=，IN( )和&lt;=&gt;。对于WHERE price&gt;100并不能加速查询。索引数据结构为什么采用B+树&nbsp; &nbsp; &nbsp;为了尽量减少I/O操作，磁盘读取每次都会预读，大小通常为页的整数倍。即使只需要读取一个字节，磁盘也会读取一页的数据(通常为4K)放入内存，内存与磁盘以页为单位交换数据。因为局部性原理认为，通常一个数据被用到，其附近的数据也会立马被用到。&nbsp; &nbsp; &nbsp;B树：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。&nbsp; &nbsp; &nbsp;B+树：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。&nbsp; &nbsp; &nbsp;由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。&nbsp; &nbsp; &nbsp;B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。索引的优缺点&nbsp; &nbsp;优点：&nbsp; &nbsp; &nbsp;1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。&nbsp; &nbsp; &nbsp;2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。&nbsp; &nbsp; &nbsp;3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。&nbsp; &nbsp; &nbsp;4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。&nbsp; &nbsp; &nbsp;5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。&nbsp; &nbsp;缺点：&nbsp; &nbsp; &nbsp;1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。&nbsp; &nbsp; &nbsp;2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。&nbsp; &nbsp; &nbsp;3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。哪些字段适合建索引&nbsp; &nbsp; &nbsp;1.在经常需要搜索的列上，可以加快搜索的速度；&nbsp; &nbsp; &nbsp;2.在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；&nbsp; &nbsp; &nbsp;3.在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；&nbsp; &nbsp; &nbsp;4.在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；&nbsp; &nbsp; &nbsp;5.在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；&nbsp; &nbsp; &nbsp;6.在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。哪些字段不适合建索引&nbsp; &nbsp; &nbsp;1.对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。&nbsp; &nbsp; &nbsp;2.对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。&nbsp; &nbsp; &nbsp;3.对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。&nbsp; &nbsp; &nbsp;4.当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚集索引与非聚集索引]]></title>
    <url>%2F%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.html</url>
    <content type="text"><![CDATA[聚集索引就是存放的物理顺序和列中的顺序一样。一般设置主键索引就为聚集索引。 聚集索引&nbsp; &nbsp; &nbsp;聚集索引就是存放的物理顺序和列中的顺序一样。一般设置主键索引就为聚集索引。&nbsp; &nbsp; &nbsp;一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是平衡树结构，换句话说，就是整个表就变成了一个索引，也就是所谓的聚集索引。 这就是为什么一个表只能有一个主键， 一个表只能有一个聚集索引，因为主键的作用就是把表的数据格式转换成索引（平衡树）的格式放置。&nbsp; &nbsp; &nbsp;上图就是带有主键的表（聚集索引）的结构图。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 假如我们执行一个SQL语句：select * from table where id = 1256&nbsp; &nbsp; &nbsp;首先根据索引定位到1256这个值所在的叶结点，然后再通过叶结点取到id等于1256的数据行。 这里不讲解平衡树的运行细节， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图&nbsp; &nbsp; &nbsp;然而， 事物都是有两面的， 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。非聚集索引&nbsp; &nbsp; 讲完聚集索引 ， 接下来聊一下非聚集索引， 也就是我们平时经常提起和使用的常规索引。&nbsp; &nbsp; 非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。&nbsp;如下图&nbsp; &nbsp; &nbsp;每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。&nbsp; 非聚集索引和聚集索引的区别在于：&nbsp; &nbsp; &nbsp;通过聚集索引可以一次查到需要查找的数据， 而通过非聚集索引第一次只能查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。&nbsp; &nbsp; &nbsp;聚集索引一张表只能有一个，而非聚集索引一张表可以有多个。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql数据库知识点总结01]]></title>
    <url>%2FMySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%9301.html</url>
    <content type="text"><![CDATA[数据库架构 MySql数据库从大的方面可以分为两大部分，分别为底层的存储系统也就是文件系统，和上层的程序实例组成，程序实例有存储管理、缓存管理、日志管理、权限管理、容灾管理、SQL解析、索引、锁等 程序实：存储管理、缓存管理、日志管理、权限管理、容灾管理、SQL解析、索引、锁等 存储：文件系统 乐观锁和悲观锁 悲观锁：对数据持一种悲观的态度，认为在事务执行期间总是有别的事务修改数据，所以每一次操作都加锁乐观锁：对数据持一种乐观的态度，所以不加锁，乐观锁中每一项数据都有一个版本号，在事务提交的时候，通过版本号来看是否是否在事务A期间，事务B修改了数据，比如有两个事务，事务A先查询数据，此时数据的版本号为0，事务B查询版本也为0，当A修改了数据并且版本变为1，在提交是版本号1&gt;0提交成功，此时事务也修改了数据把版本加一变为1，在提交时版本号1不大于1，所以提交被驳回，数据过期 三范式 第一范式：字段不可分，只要是数据库中存在的表都符合1NF第二范式：消除了非主属性对码的部分依赖第三范式：消除了非主属性对码的传递依赖 数据库ACID的特性 A:原子性—-一次事务是数据库的最小执行单位，要么事务内的所有操作做完，要么全不做，事务期间只要有一个操作不成功，就回滚，回到事务开始之前C:一致性—-事务从一个一致性状态转移到另一个一致性转态，比如：账户A有100，账户B也有100，加起来是200，当A给B转了50后，A为50，B为150，加起来还是200，感觉有一点能量守恒的意思I:隔离线—-一个事务的操作在提交之前是对其他不可见的D:持久性—-一旦事务提交数据会被保存到磁盘永久有效 leftjoin和rightjoin、innerjoin的区别 leftjoin(左联接) ：包含左表的全部数据和右表中联结字段相等的记录rightjoin(右联接)： 返回包括右表中的所有记录和左表中联结字段相等的记录innerjoin(等值连接)： 只返回两个表中联结字段相等的行 DROP，DELETE与TRUNCATE的区别 DROP会把一个表删掉DELETE删除一个表的数据，一般配合where使用TRUNCATE清空表中的数据，下一次在插入数据时自增长Id从1开始 UNION/ALL、EXCEPT/ALL和INTERSECT/ALL union 合并两个查询结果，把两个结果做并集并且删除重复的行，union all不会删除重复的行expect 把两个结果做查，包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行，expect all不消除重复的行insert 把两个结果集做交集 只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表 expect all不消除重复的行 InnoDB和MyISAM InnoDB MyISAM MySQL默认的引擎，支持行级锁和表级锁 ，支持事务 只支持表级锁，不支持事务 适用大量的INSERT或UPDATE操作 适用大量的SELECT查询 为什么MyISAM会比InnoDB的查询速度快？ InnoDB要缓存数据块，而MyISAM只需要缓存索引快 InnoDB寻址要先映射到数据块在到数据行，而MyISAM记录的直接是数据的OFESET，定位比InooDB块 InnoDB还需要维护MVCC一致 隔离级别 脏读 读取了一个事务还未提交的数据 不可重复读 在同一个事务中两次读取的结果不一样，和幻读相比更侧重数据的修改 幻读 在同一个事务中两次读取的记录数量不一样，更偏向于插入操作带来的不一样 事务隔离级别 更新丢失 脏读 不可重复读 幻读 读未提交 （Read uncommitted） × √ √ √ 读已提交 （Read committed） × × √ √ 可重复读（Repeatable read） × × × √ 序列化（Serializable） × × × × MySql在RR隔离级别下是如何避免幻读的 表象：快照读也叫非阻塞读 –伪MVVC 内在： next-key锁（行锁+gap锁） 快照读和当前读？当前读：加了锁的增删改查语句 快照读：不加锁的非阻塞读,快照读顾名思义会生成快照，在RC（Read Committed）隔离级别下每一次的select语句都会产生一个快照，所以会产生幻读，在RR级别下，select语句执行的时间不同，生成的快照也会不同，如果有个事务的select语句执行的时候另一个事务还没提交那么这个事务就看不到另一个事务的修改，反之如果一个事务在另一个事务提交后执行了select语句那这个事务就可以看到另一个事务的修改也就是查询可以看到自己之前已提的所有事务所做的更改，看不到在查询开始之后的事务提交的更改 next-key锁？ MySql在RR隔离级别下实际上是通过next-key锁避免幻读的，next-key锁就是行锁+gap锁，gap会把一个范围锁起来，比如一个表的索引是1,3,5,当执行select * from table where id &gt; 3;就会把&gt;3的范围锁起来，当在另一个事务中插入一条id为4的数据时，就会被阻塞，只有当事务提交以后，另一个事务才能继续执行插入语句]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后台开发面试考点汇总]]></title>
    <url>%2FJava%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[一、JavaSE部分❤1、Java基础1、为什么重写equals还要重写hashcode2、说一下map的分类和常见的情况 3、Object若不重写hashCode()的话，hashCode()如何计算出来的？4、==比较的是什么？ 5、若对一个类不重写，它的equals()方法是如何比较的？6、java8新特性 7、说说Lamda表达式的优缺点。 8、一个十进制的数在内存中是怎么存的？ 9、为啥有时会出现4.0-3.6=0.40000001这种现象？ 10、Java支持的数据类型有哪些？什么是自动拆装箱？ 11、什么是值传递和引用传递？ 12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？ 13、你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？ 14、String是最基本的数据类型吗? 15、int 和 Integer 有什么区别 16、String 和StringBuffer的区别 17、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？ 18、int和Integer有什么区别？ 19、&amp;和&amp;&amp;的区别？ 20、在Java中，如何跳出当前的多重嵌套循环？ 21、你能比较一下Java和JavaSciprt吗？ 22、简述正则表达式及其用途。 23、Java中是如何支持正则表达式操作的？ 24、请你说说Java和PHP的区别？ ❤2、关键字 1、介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？2、介绍一下volatile？ 3、锁有了解嘛，说一下Synchronized和lock 4、讲一讲Java里面的final关键字怎么用的？ ❤3、面向对象1、wait方法底层原理 2、Java有哪些特性，举个多态的例子。 3、String为啥不可变？ 4、类和对象的区别 5、请列举你所知道的Object类的方法。 6、重载和重写的区别？相同参数不同返回值能重载吗？ 7、”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ 8、String能继承吗？ 9、StringBuffer和StringBuilder有什么区别，底层实现上呢？ 10、类加载机制，双亲委派模型，好处是什么？ 11、静态变量存在哪? 12、讲讲什么是泛型？ 13、解释extends 和super 泛型限定符-上界不存下界不取 14、是否可以在static环境中访问非static变量？ 15、谈谈如何通过反射创建对象？ 16、Java支持多继承么？ 17、接口和抽象类的区别是什么？ 18、Comparable和Comparator接口是干什么的？列出它们的区别。 19、面向对象的特征有哪些方面 20、final, finally, finalize的区别。 21、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? 22、abstract class和interface有什么区别? 23、Static Nested Class 和 Inner Class的不同 24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 25、Java的接口和C++的虚类的相同和不同处。 26、JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ 27、内部类可以引用他包含类的成员吗？有没有什么限制？ 28、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code说法是否正确？ 29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 30、如何通过反射获取和设置对象私有字段的值？ 31、谈一下面向对象的”六原则一法则”。 32、请问Query接口的list方法和iterate方法有什么区别？ 33、Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？ 34、Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？ 35、hashCode()和equals()方法有什么联系？ ❤4、集合1、Map和ConcurrentHashMap的区别？ 2、hashMap内部具体如何实现的？ 3、如果hashMap的key是一个自定义的类，怎么办？ 4、ArrayList和LinkedList的区别，如果一直在list的尾部添加元素，用哪个效率高？ 5、HashMap底层，负载因子，为啥是2^n？ 6、ConcurrentHashMap锁加在了哪些地方？ 7、TreeMap底层，红黑树原理？ 8、concurrenthashmap有啥优势，1.7，1.8区别？ 9、ArrayList是否会越界？ 10、什么是TreeMap? 11、ConcurrentHashMap的原理是什么？ 12、Java集合类框架的基本接口有哪些？ 13、为什么集合类没有实现Cloneable和Serializable接口？ 14、什么是迭代器？ 15、Iterator和ListIterator的区别是什么？ 16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ 17、HashMap和Hashtable有什么区别？ 18、ArrayList和LinkedList有什么区别？ 19、ArrayList,Vector,LinkedList的存储性能和特性是什么？ 20、Collection 和 Collections的区别。 21、你所知道的集合类都有哪些？主要方法？ 22、List、Set、Map是否继承自Collection接口？ 23、阐述ArrayList、Vector、LinkedList的存储性能和特性 24、List、Map、Set三个接口存取元素时，各有什么特点？ ❤5、线程1、多线程中的i++线程安全吗？为什么？2、如何线程安全的实现一个计数器？ 3、多线程同步的方法 4、介绍一下生产者消费者模式？ 5、线程，进程，然后线程创建有很大开销，怎么优化？ 6、线程池运行流程，参数，策略 7、讲一下AQS吧。 8、创建线程的方法，哪个更好，为什么？ 9、Java中有几种方式启动一个线程？ 10、Java中有几种线程池？ 11、线程池有什么好处？ 12、cyclicbarrier和countdownlatch的区别 13、如何理解Java多线程回调方法？ 14、创建线程有几种不同的方式？你喜欢哪一种？为什么？ 15、概括的解释下线程的几种可用状态。 16、同步方法和同步代码块的区别是什么？ 17、启动线程有哪几种方式，线程池有哪几种？ 18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 19、sleep() 和 wait() 有什么区别？ 20、同步和异步有何异同，在什么情况下分别使用他们？举例说明。 21、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。使用内部类实现线程，对j增减的时候没有考虑顺序问题。 22、启动一个线程是用run()还是start()? 23、请说出你所知道的线程同步的方法 24、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 25、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？ 26、线程的sleep()方法和yield()方法有什么区别？ 27、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 28、请说出与线程同步以及线程调度相关的方法。 29、举例说明同步和异步 30、什么是线程池（thread pool）？ 31、说说线程的基本状态以及状态之间的关系？ 32、如何保证线程安全？ ❤6、锁 1、讲一下非公平锁和公平锁在reetrantlock里的实现。2、讲一下synchronized，可重入怎么实现。 3、锁和同步的区别。 4、什么是死锁(deadlock)？ 5、如何确保N个线程可以访问N个资源同时又不导致死锁？ 6、请你简述synchronized和java.util.concurrent.locks.Lock的异同？ ❤7、JDK 1、Java中的LongAdder和AtomicLong的区别2、JDK和JRE的区别是什么？ ❤8、反射1、反射的实现与作用 ❤9、JVM1、JVM回收算法和回收器，CMS采用哪种回收算法，怎么解决内存碎片问题？ 2、类加载过程 3、JVM分区 4、eden区，survial区? 5、JAVA虚拟机的作用? 6、GC中如何判断对象需要被回收？ 7、JAVA虚拟机中，哪些可作为ROOT对象？8、JVM内存模型是什么？ 9、jvm是如何实现线程？ 10、jvm最大内存限制多少 11、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ 12、描述一下JVM加载class文件的原理机制? ❤10、GC 1、java中内存泄露是啥，什么时候出现内存泄露？2、minor gc如果运行的很频繁，可能是什么原因引起的，minor gc如果运行的很慢，可能是什么原因引起的? 3、阐述GC算法 4、GC是什么? 为什么要有GC? 5、垃圾回收的优点和原理。并考虑2种回收机制 6、java中会存在内存泄漏吗，请简单描述。 7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（垃圾回收） ❤11、IO和NIO、AIO1、怎么打印日志？ 2、运行时异常与一般异常有何异同？ 3、error和exception有什么区别? 4、给我一个你最常见到的runtime exception 5、Java中的异常处理机制的简单原理和应用。 6、java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？ 7、什么是java序列化，如何实现java序列化？ 8、运行时异常与受检异常有什么区别？ 二、JavaEE部分❤1、Spring1、说一下IOC和AOP? 2、介绍一下bean的生命周期 3、Spring里面注解用过没有？autowired 和resource区别？ 4、@Controller和@RestController的区别？ 5、依赖注入的方式有几种，哪几种？ 6、springIOC原理？自己实现IOC要怎么做，哪些步骤？ 7、Spring中BeanFactory和ApplicationContext的区别？、 8、什么是IoC和DI？DI是如何实现的？ 9、请问Spring中Bean的作用域有哪些？ 10、谈谈Spring中自动装配的方式有哪些？ 11、aop的应用场景？ 12、AOP的原理是什么？ 13、你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？ 14、Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？ 15、介绍一下spring？ 16、Struts拦截器和Spring AOP区别？ 17、spring框架的优点？ 18、选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？ 19、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？ ❤2、Hibernate1、阐述实体对象的三种状态以及转换关系。 2、Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？ 3、Hibernate中Session的load和get方法的区别是什么？ 4、如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？ 4、简述Hibernate常见优化策略。 5、锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。 6、Hibernate如何实现分页查询？ 7、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。 ❤3、Struts1、说说STRUTS的应用 ❤4、Mybatis1、解释一下MyBatis中命名空间（namespace）的作用。 2、MyBatis中的动态SQL是什么意思？ ❤5、MVC1、Spring MVC注解的优点 2、springmvc和spring-boot区别？ 3、SpringMVC的运行机制，运行机制的每一部分的相关知识？ 4、谈谈Spring MVC的工作原理是怎样的？ ❤6、各框架对比与项目优化1、Mybatis和Hibernate区别？ 2、介绍一下你了解的Java领域的Web Service框架。 ❤7、JPA1、EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。 2、EJB与JAVA BEAN的区别？ 3、EJB包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？ 4、EJB的角色和三个对象是什么？ 5、说说EJB规范规定EJB中禁止的操作有哪些？ 6、EJB的激活机制是什么？ 7、EJB的几种类型分别是什么 8、EJB需直接实现它的业务接口或Home接口吗，请简述理由。 三、Java web编程❤1、web编程基础1、启动项目时如何实现不在链接里输入项目名就能启动? 2、1分钟之内只能处理1000个请求，你怎么实现，手撕代码? 3、什么时候用assert 4、JAVA应用服务器有那些？ 5、JSP的内置对象及方法。 6、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？（JSP） 7、说一说四种会话跟踪技术 8、讲讲Request对象的主要方法 9、说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然后在浏览器上就可打入主机？ 10、jsp有哪些动作?作用分别是什么? 11、请谈谈JSP有哪些内置对象？作用分别是什么？ 12、说一下表达式语言（EL）的隐式对象及其作用 13、JSP中的静态包含和动态包含有什么区别？ 14、过滤器有哪些作用和用法？ 15、请谈谈你对Javaweb开发中的监听器的理解？ 16、说说web.xml文件中可以配置哪些内容？ ❤2、web编程进阶1、forward与redirect区别，说一下你知道的状态码，redirect的状态码是多少？ 2、servlet生命周期，是否单例，为什么是单例。 3、说出Servlet的生命周期，并说出Servlet和CGI的区别。 4、Servlet执行时一般实现哪几个方法？ 5、阐述一下阐述Servlet和CGI的区别? 6、说说Servlet接口中有哪些方法？ 7、Servlet 3中的异步处理指的是什么？ 8、如何在基于Java的Web项目中实现文件上传和下载？ 9、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()方法？ 10、Servlet中如何获取用户提交的查询参数或表单数据？ 11、Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？ 12、讲一下redis的主从复制怎么做的？ 13、redis为什么读写速率快性能好？ 14、redis为什么是单线程？ 15、缓存的优点？ 16、aof，rdb，优点，区别？ 17、redis的List能用做什么场景？ 18、说说MVC的各个部分都有那些技术来实现?如何实现? 19、什么是DAO模式？ 20、请问Java Web开发的Model 1和Model 2分别指的是什么？ 21、你的项目中使用过哪些JSTL标签？ 22、使用标签库有什么好处？如何自定义JSP标签？（JSP标签） ❤3、web编程原理1、get和post区别？ 2、请谈谈转发和重定向的区别？ 3、说说你对get和post请求，并且说说它们之间的区别？ 4、cookie 和session 的区别？ 5、forward 和redirect的区别 6、BS与CS的联系与区别。 7、如何设置请求的编码以及响应内容的类型？ 8、什么是Web Service（Web服务）？ 9、谈谈Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？ 10、大型网站在架构上应当考虑哪些问题？ 11、请对J2EE中常用的名词进行解释(或简单描述) 四、JDBC编程 ❤1、SQL基础1、写SQL：找出每个城市的最新一条记录。2、一个学生表，一个课程成绩表，怎么找出学生课程的最高分数 3、有一组合索引（A,B,C），会出现哪几种查询方式？tag:sql语句 ❤2、JDBC基础1、数据库水平切分，垂直切分2、数据库索引介绍一下。介绍一下什么时候用Innodb什么时候用MyISAM。 3、数据库两种引擎 4、索引了解嘛，底层怎么实现的，什么时候会失效 5、问了数据库的隔离级别 6、数据库乐观锁和悲观锁 7、数据库的三范式？ 8、讲一下数据库ACID的特性？ 9、mysql主从复制？ 10、leftjoin和rightjoin的区别？ 11、数据库优化方法 12、谈一下你对继承映射的理解。 13、说出数据连接池的工作机制是什么? 14、事务的ACID是指什么？ 15、JDBC中如何进行事务处理？ ❤3、JDBC进阶1、JDBC的反射，反射都是什么？2、Jdo是什么? 3、Statement和PreparedStatement有什么区别？哪个性能更好？ 4、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？ 五、XML❤1、XML基础1、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ ❤2、Web Service1、WEB SERVICE名词解释，JSWDL开发包的介绍，JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。 2、请你谈谈对SOAP、WSDL、UDDI的了解？ 3、谈谈Java规范中和Web Service相关的规范有哪些？ 六、计算机网络 ❤1、网络概述1、TCP协议在哪一层？IP协议在那一层？HTTP在哪一层？ ❤2、运输层1、讲一下TCP的连接和释放连接。2、TCP有哪些应用场景 3、tcp为什么可靠 4、tcp为什么要建立连接 5、阐述TCP的4次挥手 6、讲一下浏览器从接收到一个URL到最后展示出页面，经历了哪些过程。tag 7、http和https的区别 8、http的请求有哪些，应答码502和504有什么区别 9、http1.1和1.0的区别 10、说说ssl四次握手的过程 11、304状态码有什么含义？ ❤3、网络层1、arp协议，arp攻击2、icmp协议 3、讲一下路由器和交换机的区别？ ❤4、应用层1、DNS寻址过程2、负载均衡反向代理模式优点及缺点 七、操作系统❤1、操作系统概论1、CentOS 和 Linux的关系？2、64位和32位的区别？ ❤2、进程的描述与控制1、怎么杀死进程？ 2、线程，进程区别 3、系统线程数量上限是多少？ 4、进程和线程的区别是什么？ 5、解释一下LINUX下线程，GDI类。 ❤3、输入输出系统1、socket编程，BIO，NIO，epoll？ ❤4、存储器管理1、什么是页式存储？ 2、操作系统里的内存碎片你怎么理解，有什么解决办法？ ❤5、处理机调度与死锁1、什么情况下会发生死锁，解决策略有哪些？ 2、系统CPU比较高是什么原因？ 3、系统如何提高并发性？ 八、算法与数据结构 ❤1、哈希1、hashset存的数是有序的吗？2、Object作为HashMap的key的话，对Object有什么要求吗？ 3、一致性哈希算法 4、什么是hashmap? 5、Java中的HashMap的工作原理是什么？ 6、hashCode()和equals()方法的重要性体现在什么地方？ ❤2、树1、说一下B+树和B-树？2、怎么求一个二叉树的深度?手撕代码? 3、算法题：二叉树层序遍历，进一步提问：要求每层打印出一个换行符 4、二叉树任意两个节点之间路径的最大长度 5、如何实现二叉树的深度？ 6、如何打印二叉树每层的节点？ 7、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？ ❤3、遍历1、编程题：写一个函数，找到一个文件夹下所有文件，包括子文件夹2、二叉树 Z 字型遍历 ❤4、链表1、反转单链表2、随机链表的复制 3、链表-奇数位升序偶数位降序-让链表变成升序 4、bucket如果用链表存储，它的缺点是什么？ 5、如何判断链表检测环 ❤5、数组1、寻找一数组中前K个最大的数2、求一个数组中连续子向量的最大和 3、找出数组中和为S的一对组合，找出一组就行 4、一个数组，除一个元素外其它都是两两相等，求那个元素? 5、算法题：将一个二维数组顺时针旋转90度，说一下思路。 ❤6、排序1、排序算法知道哪些，时间复杂度是多少，解释一下快排？2、如何得到一个数据流中的中位数？ 3、堆排序的原理是什么？ 4、归并排序的原理是什么？ 5、排序都有哪几种方法？请列举出来。 6、如何用java写一个冒泡排序？ ❤7、堆与栈1、堆与栈的不同是什么？2、heap和stack有什么区别。 3、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。 ❤8、队列1、什么是Java优先级队列(Priority Queue)？ ❤9、高级算法1、题目：Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted. Could you do both operations in O(1) time complexity? 2、id全局唯一且自增，如何实现？ 3、如何设计算法压缩一段URL？ 4、为什么要设计后缀表达式，有什么好处？ 5、LRU算法的实现原理？ 九、设计模式❤1、结构型模式1、java中有哪些代理模式？2、如何实现动态代理 3、IO流熟悉吗，用的什么设计模式？ ❤2、创建型模式1、介绍一下单例模式？懒汉式的单例模式如何实现单例？ ❤3、行为型模式1、介绍一下策略模式？2、设计模式了解哪些，手写一下观察者模式？ ❤4、模式汇总1、说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法2、j2ee常用的设计模式？说明工厂模式。 3、开发中都用到了那些设计模式?用在什么场合? 4、简述一下你了解的Java设计模式 十、场景题❤1、场景题汇总1、情景题：如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？2、场景题：美团首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？可以借鉴下stackoverflow，视频网站等等的推荐算法。3、场景题：微信抢红包问题悲观锁，乐观锁，存储过程放在mysql数据库中。4、场景题：1000个任务，分给10个人做，你怎么分配，先在纸上写个最简单的版本，然后优化。全局队列，把1000任务放在一个队列里面，然后每个人都是取，完成任务。分为10个队列，每个人分别到自己对应的队列中去取务。5、场景题：保证发送消息的有序性，消息处理的有序性。6、如何把一个文件快速下发到100w个服务器7、给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的?8、10亿个数，找出最大的10个。建议一个大小为10的小根堆。9、有几台机器存储着几亿淘宝搜索日志，你只有一台2g的电脑，怎么选出搜索热度最高的十个搜索关键词？10、分布式集群中如何保证线程安全？11、给个淘宝场景，怎么设计一消息队列？12、10万个数，输出从小到大？先划分成多个小文件，送进内存排序，然后再采用多路归并排序。13、有十万个单词，找出重复次数最高十个？十一、UML ❤1、UML1、请你谈一下UML中有哪些常用的图？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三次握手和四次挥手]]></title>
    <url>%2F%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</url>
    <content type="text"><![CDATA[在建立TCP连接时需要三次握手，在断开连接时需要四次挥手 三次握手第一次握手： 客户端向服务端发送SYN包{SYN=1，seq=x}，客户端进入SYN_SENT状态第二次握手： 服务端向客户端发送应答的ASK包和SYN包{ASK=1,SYN=1,ask=x+1,seq=y},服务端进入SYN_RCVD状态第三次握手： 客户端向服务端发送应答的ASK包{ASK=1，ask=y+1,seq=x+1}，客户端进入ESTABLISHED状态，服务端收到ASK包后也进入ESTABLISHED状态 建立连接为什么是三次握手，而不是两次呢？加入是两次的话对客户端 是没有影响的，客户端开始在收到服务端的ASK-SYN包后进入ESTABLISHED状态，客户端向服务端发送数据是没问题的，但对于服务端来说，在接收到客户端的ASk连接请求后就进入了ESTABLISHED状态，并发送向客户端发送ASK-SYN包，如果这时客户端没有收到ASK-SYN包，没有进入ESTABLISHED状态，但服务端就给客户端发送数据，肯定是失败的，服务端将会一直等待下去，这样浪费服务端连接资源。 四次挥手由于TCP传输是全双工的，客户端向服务器发送数据的同时服务端也可以向客户端发送数据，所以断开连接需要四次挥手，前两次断开一个方向的连接，后两次断开另一个方向的连接第一次挥手： 当客户端的数据发送完后，向服务端发送一个FIN包请求断开连接{FIN=1,seq=u},客户端进入FIN-WAIT1状态第二次挥手： 服务端收到客户端发来的FIN断开请求后，通知应用程序客户端发送数据完成，不会再发数据了，同时做出应答给客户端发送一个ASK包，{ASK=1,ask=u+1,seq=v},服务端进入CLOSE-WAIT状态，客户端在收到应答后进入FIN-WAIT2状态，此时从客户端到服务端的连接断开，客户端不会发送数据，服务端也不会在接收数据，但这时候服务端还可以向客户端发送数据，还需要接下来的两次挥手第三次挥手： 当服务端的数据发送完以后，也会向客户端发送一个FIN包请求断开连接{FIN=1，ASK=1,seq=w,ask=u+1}，服务端进入LAST-ASK状态第四次挥手： 客户端在接收到断开请求后，进入TIME-WAIT状态，并向服务端发送应答{ASK=1,seq=u+1,ask=w+1},服务端在接收到应答后，进入CLOSED转态，等客户端的TIME-WAIT结束后，客户端也进入CLOSED状态，此时服务端到客户端的连接断开 客户端在收到第三次挥手后为什么没有立即进入关闭状态呢？因为客户端要等服务端收到客户端的应答，如果服务端没有收到应答，服务端会从新发送断开连接的请求，而这时客户端已经关闭了，那么服务端到客户端的连接将永远不能关闭]]></content>
      <categories>
        <category>计算机网络基础</category>
      </categories>
      <tags>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础之OSI参考模型]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8BOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[1. OSI参考模型 OSI参考模型的七层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层! 1.1 为什么要分层 分层可以让网络通信系统更加的灵活，每层之间用接口连接，每一层互补干扰，即使有一层发生了改变，但整个系统不受影响 比如上图的通话系统分为语言层和通信设备层，如果把通信设备层的电话机换成无线电照样可以实现通话，同样的把语言层的汉语变成英语，也可以实现通话 1.2 各层的作用 物理层：完成数模和模数转换，完成模拟信号和0和1的比特流之间的转化 数据链路层：互联的设备之间互传数据帧，数据帧和比特流之间的转换 网络层：路由的选择，完成到目的IP地址的路由 传输层：实现可靠的端对端的传输 会话层：何时建立连接何时断开连接，以及收发的顺序 表示层：统一数据的格式，将不同的数据格式转换为网络统一的数据格式 应用层： 针对特定应用的协议1.3 OSI参考模型通信处理举例 当A用户用主机A给使用B主机的B用户发送邮件时在OSI七层参考模型中是怎样处理的呢？假定用户A给用户B发送邮件的内容是“早上好”，接下来我们逐层分析 应用层： 当用户A在软件中输入收件人为B，内容是“早上好”，点击发送后，应用层的协议就开始处理了，应用层的协议会在发送的数据的加上一个头部信息，头部信息包括收件人是用户B内容是“早上好”，然后把数据交给表示层 表示层： 由于不同的机器用的数据格式不一样，如果不统一数据格式的话，到达接收方数据就会乱套，所以表示层协议要做的就是在头部加上数据格式的信息 会话层： 会话层协议处理的就是何时建立连接，何时断开连接，假如用户A要给用户B发送5个邮件，会话层要处理的就是这些邮件的发送顺序，把这些信息加到数据的头部 传输层： 在传输层主机A和主机B之间通信，并建立连接，然后开始发送数据，数据发送完成以后，就断开连接，如果发送的数据有丢失的A会从新发送丢失的数据，所以也会在头部加上相应的信息 网络层： 在主机A和主机B之间的联通是有很多网络组成的，网络层就是地址管理，路由管理，找到目标IP地址，网络层并不能确保数据到达了目标，所以要配合传输层，实现可靠的传输 数据链路层和物理层： 总结：其实整个过程就是一层层的加头部信息，然后B收到数据后一层一层的根据头部信息把头部信息去掉，最后拿到数据]]></content>
      <categories>
        <category>计算机网络基础</category>
      </categories>
      <tags>
        <tag>OSI参考模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+Quartz最简单的HelloWorld入门示例]]></title>
    <url>%2FSpring%2BQuartz%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84HelloWorld%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B.html</url>
    <content type="text"><![CDATA[实现的效果，定时执行有关Quartz不做介绍，可自行学习首先添加依赖 spring相关的依赖根据自己的版本添加，注意要加spring-context-support的依赖，版本和spring的版本保持一致就可以了 123456789101112&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; 写一个要定时执行的类1234567891011public class HelloWordJob &#123; public void sayHi()&#123; try &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date = simpleDateFormat.format(new Date()); System.out.println("hi "+date); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; XML的配置 在spring的配置文件中加入以下代码，其中id=helloWordJob的bean就是你要定时实行的类，其他的不用改 1234567891011121314151617181920212223&lt;!-- job --&gt; &lt;bean id="helloWordJob" class="com.imooc.myo2o.service.impl.HelloWordJob"/&gt; &lt;!-- 使用MethodInvokingJobDetailFactoryBean，任务类可以不实现Job接口，通过targetMethod指定调用方法--&gt; &lt;!-- jobDetail --&gt; &lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="helloWordJob"/&gt; &lt;property name="targetMethod" value="sayHi"/&gt; &lt;!--false表示等上一个任务执行完后再开启新的任务,这里和上一遍博客中的注解@DisallowConcurrentExecution一个道理--&gt; &lt;property name="concurrent" value="false"/&gt; &lt;/bean&gt; &lt;!-- Trigger--&gt; &lt;bean id="helloWordJobCronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="jobDetail"/&gt; &lt;property name="cronExpression" value="0/3 * * * * ?"/&gt; &lt;/bean&gt; &lt;!--Scheduler --&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="helloWordJobCronTrigger"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 这样启动你的Tomcat就可以看到效果了让目标方法按照自己指定的时间执行，可修改 Trigger的cronExpression，可参考在线Cron表达式生成器：https://www.pppet.net/]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java如何利用google的zxing生成二维码，只要两步，超级简单]]></title>
    <url>%2Fjava%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8google%E7%9A%84zxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html</url>
    <content type="text"><![CDATA[实现的效果,在页面中直接引入 12345&lt;html&gt; &lt;body&gt; &lt;img alt="二维码" src="/myo2o/qrcode/generateqrcode"&gt; &lt;/body&gt;&lt;/html&gt; 打开页面，静态页面src地址要写全，前面要加http://localhost:8080首先添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 写一个二维码生成工具类1234567891011121314151617181920212223public static BitMatrix generateQRCodeStream(String content,HttpServletResponse response) &#123; //给相应添加头部信息，主要告诉浏览器返回的是图片流 response.setHeader("Cache-Control", "no-store"); // 不设置缓存 response.setHeader("Pragma", "no-cache"); response.setDateHeader("Expires", 0); response.setContentType("image/png"); //设置图片的文字编码以及内边框 Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;&gt;(); //编码 hints.put(EncodeHintType.CHARACTER_SET, "UTF-8"); //边框距 hints.put(EncodeHintType.MARGIN, 0); BitMatrix bitMatrix; try &#123; //参数分别为：编码内容、编码类型、图片宽度、图片高度，设置参数 bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, 300, 300,hints); &#125;catch(WriterException e) &#123; e.printStackTrace(); return null; &#125; return bitMatrix; &#125; 写一个响应的Controller，在页面的img标签中src写的就是这个地址1234567891011121314151617181920@Controller@RequestMapping("/qrcode")public class QRCodeTestController &#123; @RequestMapping(value = "/generateqrcode", method = RequestMethod.GET) @ResponseBody public void generateQRCode4Product(HttpServletRequest request, HttpServletResponse response) &#123; String longUrl; try &#123; longUrl = "https://blog.csdn.net/victoyr"; // 转换成短url String shortUrl = BaiduDwz.createShortUrl(longUrl); // 生成二维码 BitMatrix qRcodeImg = CodeUtil.generateQRCodeStream(shortUrl, response); // 将二维码输出到页面中 MatrixToImageWriter.writeToStream(qRcodeImg, "png", response.getOutputStream()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 二维码生成的链接不能太长，所以把长链接转换成了短链接，转换方法：https://blog.csdn.net/victoyr/article/details/89679363 ，如果链接不是很长可以不用 Ok啦，是不是很简单呢。]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>zxing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用百度短链接接口将一个长链接变成短链接]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%8E%A5%E5%8F%A3%E5%B0%86%E4%B8%80%E4%B8%AA%E9%95%BF%E9%93%BE%E6%8E%A5%E5%8F%98%E6%88%90%E7%9F%AD%E9%93%BE%E6%8E%A5.html</url>
    <content type="text"><![CDATA[短网址服务可以帮助你把一个长网址缩短，方便你在社交网络和第三方平台上分享链接，投放广告等等。 我们提供超简单的方式使用短网址服务：访问百度短网址首页https://dwz.cn，输入你要缩短的原网址，生成对应的短网址。你还可以调用百度短网址服务API服务，查看数据统计与分析……更多功能，等你来探索！ 官方文档：https://dwz.cn/console/apidoc首先添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; 然后去百度官方文档https://dwz.cn/console/apidoc复制示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.imooc.myo2o.util.baidu;import java.io.IOException;import java.io.OutputStreamWriter;import java.net.HttpURLConnection;import java.net.URL;import java.io.BufferedReader;import java.io.InputStreamReader;import com.google.gson.Gson;import com.google.gson.annotations.SerializedName;public class BaiduDwz &#123; final static String CREATE_API = "https://dwz.cn/admin/v2/create"; final static String TOKEN = "你的token"; // TODO:设置Token class UrlResponse &#123; @SerializedName("Code") private int code; @SerializedName("ErrMsg") private String errMsg; @SerializedName("LongUrl") private String longUrl; @SerializedName("ShortUrl") private String shortUrl; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getErrMsg() &#123; return errMsg; &#125; public void setErrMsg(String errMsg) &#123; this.errMsg = errMsg; &#125; public String getLongUrl() &#123; return longUrl; &#125; public void setLongUrl(String longUrl) &#123; this.longUrl = longUrl; &#125; public String getShortUrl() &#123; return shortUrl; &#125; public void setShortUrl(String shortUrl) &#123; this.shortUrl = shortUrl; &#125; &#125; /** * 创建短网址 * * @param longUrl * 长网址：即原网址 * @return 成功：短网址 * 失败：返回空字符串 */ public static String createShortUrl(String longUrl) &#123; String params = "&#123;\"url\":\""+ longUrl + "\"&#125;"; BufferedReader reader = null; try &#123; // 创建连接 URL url = new URL(CREATE_API); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); connection.setRequestMethod("POST"); // 设置请求方式 connection.setRequestProperty("Content-Type", "application/json"); // 设置发送数据的格式 connection.setRequestProperty("Token", TOKEN); // 设置发送数据的格式"); // 发起请求 connection.connect(); OutputStreamWriter out = new OutputStreamWriter(connection.getOutputStream(), "UTF-8"); // utf-8编码 out.append(params); out.flush(); out.close(); // 读取响应 reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8")); String line; String res = ""; while ((line = reader.readLine()) != null) &#123; res += line; &#125; reader.close(); // 抽取生成短网址 UrlResponse urlResponse = new Gson().fromJson(res, UrlResponse.class); if (urlResponse.getCode() == 0) &#123; return urlResponse.getShortUrl(); &#125; else &#123; System.out.println(urlResponse.getErrMsg()); &#125; return ""; // TODO：自定义错误信息 &#125; catch (IOException e) &#123; // TODO e.printStackTrace(); &#125; return ""; // TODO：自定义错误信息 &#125; public static void main(String[] args) &#123; String res = createShortUrl("你的长网址"); System.out.println(res); &#125;&#125; 把代码中的token换成你的token在官方文档https://dwz.cn/console/apidoc中获取token到此就ok了，可以在main方法中试一下效果]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>百度短链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号如何授权登录、获取用户信息(openid)]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%A6%82%E4%BD%95%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E3%80%81%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF(openid).html</url>
    <content type="text"><![CDATA[首先看一下实现的效果，在公众号中，用户进入你的应用之前，会弹出一个授权页面，当用户点击确认后，你就可以获取用户的信息 首先访问微信测试号登录页面，通过打开自己手机的微信，扫一扫登录https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login进入到测试号页面后，分别看到如下信息【测试号信息】appID:开发者ID，是公众号开发识别码，配合开发者密码可以调用微信公众号接口，如获取微信昵称等appsecret:开发者密码，是检验公众号开发者身份的密码，具有极高的安全性。切记不要把密码交给第三方开发者或者编写到代码里【接口配置信息】URL: 是开发者用来接收微信消息和事件的接口URL，要用域名不能用ipToken:由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性） 当你填完URL和Token点击提交后，微信会访问你填写的URL，所以要在后台写一个servlet来处理这个请求 处理请求的Controller 1234567891011121314151617181920212223242526272829@Controller@RequestMapping("wechat")public class WeiXinController &#123; @RequestMapping(method = &#123; RequestMethod.GET &#125;) public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; // 微信加密签名 String signature = request.getParameter("signature"); // 时间戳 String timestamp = request.getParameter("timestamp"); // 随机数 String nonce = request.getParameter("nonce"); // 随机字符串 String echostr = request.getParameter("echostr"); // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败 PrintWriter out = null; try &#123; out = response.getWriter(); if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123; log.debug("weixin get success...."); out.print(echostr); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (out != null) out.close(); &#125; &#125;&#125; 微信请求校验工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 微信请求校验工具类 */public class SignUtil &#123; // 与接口配置信息中的Token要一致 private static String token = "mytoken"; /** * 验证签名 * @param signature * @param timestamp * @param nonce * @return */ public static boolean checkSignature(String signature, String timestamp, String nonce) &#123; String[] arr = new String[] &#123; token, timestamp, nonce &#125;; // 将token、timestamp、nonce三个参数进行字典序排序 Arrays.sort(arr); StringBuilder content = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; content.append(arr[i]); &#125; MessageDigest md = null; String tmpStr = null; try &#123; md = MessageDigest.getInstance("SHA-1"); // 将三个参数字符串拼接成一个字符串进行sha1加密 byte[] digest = md.digest(content.toString().getBytes()); tmpStr = byteToStr(digest); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; content = null; // 将sha1加密后的字符串可与signature对比，标识该请求来源于微信 return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false; &#125; /** * 将字节数组转换为十六进制字符串 * @param byteArray * @return */ private static String byteToStr(byte[] byteArray) &#123; String strDigest = ""; for (int i = 0; i &lt; byteArray.length; i++) &#123; strDigest += byteToHexStr(byteArray[i]); &#125; return strDigest; &#125; /** * 将字节转换为十六进制字符串 * @param mByte * @return */ private static String byteToHexStr(byte mByte) &#123; char[] Digit = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' &#125;; char[] tempArr = new char[2]; tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F]; tempArr[1] = Digit[mByte &amp; 0X0F]; String s = new String(tempArr); return s; &#125;&#125; 请求的处理程序写完后把项目重新打包发布到服务器上去，再提交你填写的URL和Token，接口配置信息就Ok啦 【JS接口安全域名】域名：想调用jssdk(如想要通过微信公众号js接口获取地图等工具)必须得填写此域名，在此域名的范围内才能调用jssdk工具，注意这里必须是域名，不是带有http之类的URL【测试号二维码】里面包含了测试号二维码以及已经关注了的用户信息【体验接口权限表】这里主要介绍【网页服务】里面的【网页帐号】网页帐号主要用来设置OAuth2.0里面的网页授权域名，用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。沙盒号回调地址支持域名和ip，正式公众号回调地址只支持域名。接下来需要编写自己的程序以获取关注此公众号的用户信息需要编写5个类 WechatLoginController.java，UserAccessToken.java，WechatUser.java，WechatUtil.java以及MyX509TrustManager.java【WechatLoginController】主要用来获取已关注此微信号的用户信息并做相应处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Controller@RequestMapping("wechatlogin")/** * 获取关注公众号之后的微信用户信息的接口，如果在微信浏览器里访问 * https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appId&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect * 则这里将会获取到code,之后再可以通过code获取到access_token 进而获取到用户信息 */public class WechatLoginController &#123; private static Logger log = LoggerFactory.getLogger(WechatLoginController.class); @RequestMapping(value = "/logincheck", method = &#123; RequestMethod.GET &#125;) public String doGet(HttpServletRequest request, HttpServletResponse response) &#123; log.debug("weixin login get..."); // 获取微信公众号传输过来的code,通过code可获取access_token,进而获取用户信息 String code = request.getParameter("code"); // 这个state可以用来传我们自定义的信息，方便程序调用，这里也可以不用 // String roleType = request.getParameter("state"); log.debug("weixin login code:" + code); WechatUser user = null; String openId = null; if (null != code) &#123; UserAccessToken token; try &#123; // 通过code获取access_token token = WechatUtil.getUserAccessToken(code); log.debug("weixin login token:" + token.toString()); // 通过token获取accessToken String accessToken = token.getAccessToken(); // 通过token获取openId openId = token.getOpenId(); // 通过access_token和openId获取用户昵称等信息 user = WechatUtil.getUserInfo(accessToken, openId); log.debug("weixin login user:" + user.toString()); request.getSession().setAttribute("openId", openId); &#125; catch (IOException e) &#123; log.error("error in getUserAccessToken or getUserInfo or findByOpenId: " + e.toString()); e.printStackTrace(); &#125; &#125; // ======todo begin====== // 前面咱们获取到openId后，可以通过它去数据库判断该微信帐号是否在我们网站里有对应的帐号了， // 没有的话这里可以自动创建上，直接实现微信与咱们网站的无缝对接。 // ======todo end====== if (user != null) &#123; // 获取到微信验证的信息后返回到指定的路由（需要自己设定） return "frontend/index"; &#125; else &#123; return null; &#125; &#125;&#125; 【UserAccessToken】用户AccessToken实体类，用来接收accesstoken以及openid等信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 用户授权token * */public class UserAccessToken &#123; // 获取到的凭证 @JsonProperty("access_token") private String accessToken; // 凭证有效时间，单位：秒 @JsonProperty("expires_in") private String expiresIn; // 表示更新令牌，用来获取下一次的访问令牌，这里没太大用处 @JsonProperty("refresh_token") private String refreshToken; // 该用户在此公众号下的身份标识，对于此微信号具有唯一性 @JsonProperty("openid") private String openId; // 表示权限范围，这里可省略 @JsonProperty("scope") private String scope; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public String getExpiresIn() &#123; return expiresIn; &#125; public void setExpiresIn(String expiresIn) &#123; this.expiresIn = expiresIn; &#125; public String getRefreshToken() &#123; return refreshToken; &#125; public void setRefreshToken(String refreshToken) &#123; this.refreshToken = refreshToken; &#125; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public String getScope() &#123; return scope; &#125; public void setScope(String scope) &#123; this.scope = scope; &#125; @Override public String toString() &#123; return "accessToken:" + this.getAccessToken() + ",openId:" + this.getOpenId(); &#125;&#125; 【WechatUser】微信用户实体类，用来接收昵称 openid等用户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * 微信用户实体类 */public class WechatUser implements Serializable &#123; private static final long serialVersionUID = -4684067645282292327L; // openId,标识该公众号下面的该用户的唯一Id @JsonProperty("openid") private String openId; // 用户昵称 @JsonProperty("nickname") private String nickName; // 性别 @JsonProperty("sex") private int sex; // 省份 @JsonProperty("province") private String province; // 城市 @JsonProperty("city") private String city; // 区 @JsonProperty("country") private String country; // 头像图片地址 @JsonProperty("headimgurl") private String headimgurl; // 语言 @JsonProperty("language") private String language; // 用户权限，这里没什么作用 @JsonProperty("privilege") private String[] privilege; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getCountry() &#123; return country; &#125; public void setCountry(String country) &#123; this.country = country; &#125; public String getHeadimgurl() &#123; return headimgurl; &#125; public void setHeadimgurl(String headimgurl) &#123; this.headimgurl = headimgurl; &#125; public String getLanguage() &#123; return language; &#125; public void setLanguage(String language) &#123; this.language = language; &#125; public String[] getPrivilege() &#123; return privilege; &#125; public void setPrivilege(String[] privilege) &#123; this.privilege = privilege; &#125; @Override public String toString() &#123; return "openId:" + this.getOpenId() + ",nikename:" + this.getNickName(); &#125;&#125; 【WechatUtil】主要用来提交https请求给微信获取用户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 微信工具类 */public class WechatUtil &#123; private static Logger log = LoggerFactory.getLogger(WechatUtil.class); /** * 获取UserAccessToken实体类 * @param code * @return * @throws IOException */ public static UserAccessToken getUserAccessToken(String code) throws IOException &#123; // 测试号信息里的appId String appId = "您的appId"; log.debug("appId:" + appId); // 测试号信息里的appsecret String appsecret = "您的appsecret"; log.debug("secret:" + appsecret); // 根据传入的code,拼接出访问微信定义好的接口的URL String url = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=" + appId + "&amp;secret=" + appsecret + "&amp;code=" + code + "&amp;grant_type=authorization_code"; // 向相应URL发送请求获取token json字符串 String tokenStr = httpsRequest(url, "GET", null); log.debug("userAccessToken:" + tokenStr); UserAccessToken token = new UserAccessToken(); ObjectMapper objectMapper = new ObjectMapper(); try &#123; // 将json字符串转换成相应对象 token = objectMapper.readValue(tokenStr, UserAccessToken.class); &#125; catch (JsonParseException e) &#123; log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (IOException e) &#123; log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); &#125; if (token == null) &#123; log.error("获取用户accessToken失败。"); return null; &#125; return token; &#125; /** * 获取WechatUser实体类 * @param accessToken * @param openId * @return */ public static WechatUser getUserInfo(String accessToken, String openId) &#123; // 根据传入的accessToken以及openId拼接出访问微信定义的端口并获取用户信息的URL String url = "https://api.weixin.qq.com/sns/userinfo?access_token=" + accessToken + "&amp;openid=" + openId + "&amp;lang=zh_CN"; // 访问该URL获取用户信息json 字符串 String userStr = httpsRequest(url, "GET", null); log.debug("user info :" + userStr); WechatUser user = new WechatUser(); ObjectMapper objectMapper = new ObjectMapper(); try &#123; // 将json字符串转换成相应对象 user = objectMapper.readValue(userStr, WechatUser.class); &#125; catch (JsonParseException e) &#123; log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (IOException e) &#123; log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); &#125; if (user == null) &#123; log.error("获取用户信息失败。"); return null; &#125; return user; &#125; /** * 发起https请求并获取结果 * @param requestUrl * 请求地址 * @param requestMethod * 请求方式（GET、POST） * @param outputStr * 提交的数据 * @return json字符串 */ public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) &#123; StringBuffer buffer = new StringBuffer(); try &#123; // 创建SSLContext对象，并使用我们指定的信任管理器初始化 TrustManager[] tm = &#123; new MyX509TrustManager() &#125;; SSLContext sslContext = SSLContext.getInstance("SSL", "SunJSSE"); sslContext.init(null, tm, new java.security.SecureRandom()); // 从上述SSLContext对象中得到SSLSocketFactory对象 SSLSocketFactory ssf = sslContext.getSocketFactory(); URL url = new URL(requestUrl); HttpsURLConnection httpUrlConn = (HttpsURLConnection) url.openConnection(); httpUrlConn.setSSLSocketFactory(ssf); httpUrlConn.setDoOutput(true); httpUrlConn.setDoInput(true); httpUrlConn.setUseCaches(false); // 设置请求方式（GET/POST） httpUrlConn.setRequestMethod(requestMethod); if ("GET".equalsIgnoreCase(requestMethod)) httpUrlConn.connect(); // 当有数据需要提交时 if (null != outputStr) &#123; OutputStream outputStream = httpUrlConn.getOutputStream(); // 注意编码格式，防止中文乱码 outputStream.write(outputStr.getBytes("UTF-8")); outputStream.close(); &#125; // 将返回的输入流转换成字符串 InputStream inputStream = httpUrlConn.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream, "utf-8"); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String str = null; while ((str = bufferedReader.readLine()) != null) &#123; buffer.append(str); &#125; bufferedReader.close(); inputStreamReader.close(); // 释放资源 inputStream.close(); inputStream = null; httpUrlConn.disconnect(); log.debug("https buffer:" + buffer.toString()); &#125; catch (ConnectException ce) &#123; log.error("Weixin server connection timed out."); &#125; catch (Exception e) &#123; log.error("https request error:&#123;&#125;", e); &#125; return buffer.toString(); &#125;&#125; 【MyX509TrustManager】主要继承X509TrustManager做https证书信任管理器 12345678910111213141516/** * 证书信任管理器（用于https请求） * */public class MyX509TrustManager implements X509TrustManager &#123; public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; public X509Certificate[] getAcceptedIssuers() &#123; return null; &#125;&#125; 之后重新打包一个新的war包并发布到服务器tomcat webapps目录下发布成功后，关注你自己的测试号(即扫描测试号的那个二维码)，然后在手机微信里面或者微信开发者工具里访问相应链接：https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appId&amp;redirect_uri=WechatLoginController对应的地址&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>微信公众号开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下使用crontab如何实现mysql数据库每天自动备份定时备份]]></title>
    <url>%2Flinux%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%8F%E5%A4%A9%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%EF%BC%8C%E5%B9%B6%E5%8F%AA%E4%BF%9D%E7%95%99%E8%BF%917%E5%A4%A9%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[1. 编辑shell脚本 (备份&amp;清理)123456789101112131415#!/bin/bash#在此设置要备份的数据库名,以TEST为例DBNAME="TEST" #备份数据临时存放位置,备份完成之后自动删除. BACKDIR="/home/root/backup/" #获取系统时间DATE=`date +%Y%m%d`#备份文件名以时间命名 FILENAME=dump_$&#123;DATE&#125;.sql #进入备份目录cd $&#123;BACKDIR&#125; #备份数据库并追加日志mysqldump -uroot -proot --databases TEST &gt; $&#123;BACKDIR&#125;$&#123;FILENAME&#125; &gt;&gt; db_backup.log#删除近7天文件find $&#123;BACKDIR&#125; -mtime +7 -name "*.sql" -exec rm -rf &#123;&#125; \; 2. 将脚本加入crontab自动执行计划添加计划 1crontab -e 加入一行:12#每天晚上11点半, 执行对应路径下的脚本.30 23 * * * /home/root/backup.sh 保存退出(vim命令) 3. Cron 各项的描述以下是 crontab 文件的格式： {minute} {hour} {day-of-month} {month} {day-of-week} {full-path-to-shell-script}minute: 区间为 0 – 59hour: 区间为0 – 23day-of-month: 区间为0 – 31month: 区间为1 – 12. 1 是1月. 12是12月.Day-of-week: 区间为0 – 7. 周日可以是0或7. 4.Crontab 示例 在 12:01 a.m 运行，即每天凌晨过一分钟。这是一个恰当的进行备份的时间，因为此时系统负载不大。 11 0 * * * /root/bin/backup.sh 每个工作日(Mon – Fri) 11:59 p.m 都进行备份作业。 1259 11 * * 1,2,3,4,5 /root/bin/backup.sh#或者59 11 * * 1-5 /root/bin/backup.sh效果一样 每5分钟运行一次命令 1*/5 * * * * /root/bin/check-status.sh 每个月的第一天 1:10 p.m 运行 110 13 1 * * /root/bin/full-backup.sh 每个工作日 11 p.m 运行。 10 23 * * 1-5 /root/bin/incremental-backup.sh 5. crontab常用的命令 12345678910service crond start //启动服务service crond stop //关闭服务service crond restart //重启服务service crond reload //重新载入配置service crond status //查看服务状态 crontab –e //往 cron 中添加一个作业crontab –e //修改 crontab 文件. 如果文件不存在会自动创建。 crontab –l //显示 crontab 文件。 crontab -r //删除 crontab 文件。crontab -ir //删除 crontab 文件前提醒用户]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对项目中关键的配置信息进行加密]]></title>
    <url>%2F%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B3%E9%94%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86.html</url>
    <content type="text"><![CDATA[我们在搭键一个项目的时候，有一些信息，比如数据库的连接信息通常会放在一个配置文件中，存放的是明码，我们可以对关键信息比如用户名和密码进行加密，就算别人获取了也没有用 加密后的效果 1234db.username = WnplV/ietfQ=db.password = j9ZTgFZm4H7r0AteGA6A7A==db.driver = com.mysql.jdbc.Driverdb.url = jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf8 一、首先创建一个加密的工具类，对信息进行加密我用的是DES对称加密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.edward.o2o.util;import java.security.Key;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;public class DESUtils &#123; private static Key key; private static String KEY_STR = "myKey"; private static String CHARSETNAME = "UTF-8"; private static String ALGORITHM = "DES"; static &#123; try &#123; KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM); SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG"); secureRandom.setSeed(KEY_STR.getBytes()); generator.init(secureRandom); key = generator.generateKey(); generator = null; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static String getEncryptString(String str) &#123; BASE64Encoder base64encoder = new BASE64Encoder(); try &#123; byte[] bytes = str.getBytes(CHARSETNAME); Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] doFinal = cipher.doFinal(bytes); return base64encoder.encode(doFinal); &#125; catch (Exception e) &#123; // TODO: handle exception throw new RuntimeException(e); &#125; &#125; public static String getDecryptString(String str) &#123; BASE64Decoder base64decoder = new BASE64Decoder(); try &#123; byte[] bytes = base64decoder.decodeBuffer(str); Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, key); byte[] doFinal = cipher.doFinal(bytes); return new String(doFinal, CHARSETNAME); &#125; catch (Exception e) &#123; // TODO: handle exception throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; System.out.println(getEncryptString("root")); System.out.println(getEncryptString("123456abCD.")); System.out.println(getEncryptString("wxd7f6c5b8899fba83")); System.out.println(getEncryptString("665ae80dba31fc91ab6191e7da4d676d")); &#125;&#125; 通过main方法，把要加密的信息输出到控制台得到密文,再把对应的明文换成加密后的密文 二、创建一个PropertyPlaceholderConfigurer的后置处理器，在spring中解析配置文件1234567891011121314151617181920212223242526package com.edward.o2o.util;import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;public class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer &#123; private String[] encryptPropNames = &#123; "db.username", "db.password" &#125;; @Override protected String convertProperty(String propertyName, String propertyValue) &#123; if (isEncryptProp(propertyName)) &#123; String decryptValue = DESUtils.getDecryptString(propertyValue); return decryptValue; &#125; else &#123; return propertyValue; &#125; &#125; private boolean isEncryptProp(String propertyName) &#123; for (String encryptpropertyName : encryptPropNames) &#123; if (encryptpropertyName.equals(propertyName)) return true; &#125; return false; &#125;&#125; 三、把配置文件加载到spring的配置文件中12345678910&lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;&lt;!--&lt;context:property-placeholder location="classpath:db.properties"/&gt;--&gt;&lt;bean class="com.edward.o2o.util.EncryptPropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="fileEncoding" value="UTF-8" /&gt;&lt;/bean&gt; class就是第二步中用于解析配置文件的类 总结： 整个过程就是利用加密的工具类对关键信息加密把原文替换成密文，然后在spring的配置文件中加载需要的配置文件（比如数据库的配置文件），加载过程中PropertyPlaceholderConfigurer后置处理器会调用加密工具类中的解密文件返回明文 PropertyPlaceholderConfigurer是个bean工厂后置处理器的实现，也就是 BeanFactoryPostProcessor接口的一个实现。PropertyPlaceholderConfigurer可以将上下文（配置文 件）中的属性值放在另一个单独的标准java Properties文件中去。在XML文件中用${key}替换指定的properties文件中的值。这样的话，只需要对properties文件进 行修改，而不用对xml配置文件进行修改。]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot 2.1.3配置Druid数据源]]></title>
    <url>%2Fspring-boot%202.1.3%E9%85%8D%E7%BD%AEDruid%E6%95%B0%E6%8D%AE%E6%BA%90.html</url>
    <content type="text"><![CDATA[1.在pom文件添加依赖 12345678910111213&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j yml配置文件中filters: stat,wall,log4j所以要加此依赖，否侧会报错--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 2.在配置文件中配置数据库信息1234567891011121314151617181920212223242526spring: datasource:# 数据源基本配置 username: root password: 123456abcd driver-class-name: com.mysql.cj.jdbc.Driver #注意要配置serverTimezone等信息 url: jdbc:mysql://localhost:3306/books?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false type: com.alibaba.druid.pool.DruidDataSource# 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 3.添加Druid的配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.edward.springbootmybaties.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig &#123; @Bean //这样yml配置文件才会起作用，和Druid类绑定起来 @ConfigurationProperties(prefix = "spring.datasource") public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125;]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合逐层配置]]></title>
    <url>%2FSSM%E6%95%B4%E5%90%88%E9%80%90%E5%B1%82%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[使用SSM（Spring、SpringMVC和Mybatis）已经有三个多月了，项目在技术上已经没有什么难点了，基于现有的技术就可以实现想要的功能，当然肯定有很多可以改进的地方。之前没有记录SSM整合的过程，这次刚刚好基于自己的一个小项目重新搭建了一次，而且比项目搭建的要更好一些。以前解决问题的过程和方法并没有及时记录，以后在自己的小项目中遇到我再整理分享一下。这次，先说说三大框架整合过程。个人认为使用框架并不是很难，关键要理解其思想，这对于我们提高编程水平很有帮助。不过，如果用都不会，谈思想就变成纸上谈兵了！！！先技术，再思想。实践出真知。 一、Dao层配置1.spring-dao.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name="driverClass" value="$&#123;db.driver&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;db.url&#125;" /&gt; &lt;property name="user" value="$&#123;db.username&#125;" /&gt; &lt;property name="password" value="$&#123;db.password&#125;" /&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name="maxPoolSize" value="30" /&gt; &lt;property name="minPoolSize" value="10" /&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name="autoCommitOnClose" value="false" /&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="10000" /&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2" /&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.edward.o2o.entity" /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.edward.o2o.dao" /&gt; &lt;/bean&gt;&lt;/beans&gt; 2.db.properties1234db.username = rootdb.password = 123456abcddb.driver = com.mysql.jdbc.Driverdb.url = jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf8 3.mybatis-config.xml12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;!-- 打印查询语句 --&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt;&lt;/configuration&gt; 二、service层配置spring-service.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="com.edward.o2o.service" /&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; 三、web层配置spring-web.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解模式 --&gt; &lt;!-- 简化配置： (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 --&gt; &lt;mvc:annotation-driven &gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes" value="text/html;charset=UTF-8"/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用"/"做整体映射 --&gt; &lt;mvc:resources mapping="/resources/**" location="/resources/" /&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 3.定义视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/html/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".html"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package="com.edward.o2o.web" /&gt;&lt;/beans&gt; 四、最后配置web.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;filter&gt; &lt;filter-name&gt;SpringEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SpringEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - &gt; spring -&gt; springmvc --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>

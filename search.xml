<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何利用百度短链接接口将一个长链接变成短链接]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%8E%A5%E5%8F%A3%E5%B0%86%E4%B8%80%E4%B8%AA%E9%95%BF%E9%93%BE%E6%8E%A5%E5%8F%98%E6%88%90%E7%9F%AD%E9%93%BE%E6%8E%A5.html</url>
    <content type="text"><![CDATA[短网址服务可以帮助你把一个长网址缩短，方便你在社交网络和第三方平台上分享链接，投放广告等等。 我们提供超简单的方式使用短网址服务：访问百度短网址首页https://dwz.cn，输入你要缩短的原网址，生成对应的短网址。你还可以调用百度短网址服务API服务，查看数据统计与分析……更多功能，等你来探索！ 官方文档：https://dwz.cn/console/apidoc首先添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; 然后去百度官方文档https://dwz.cn/console/apidoc复制示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.imooc.myo2o.util.baidu;import java.io.IOException;import java.io.OutputStreamWriter;import java.net.HttpURLConnection;import java.net.URL;import java.io.BufferedReader;import java.io.InputStreamReader;import com.google.gson.Gson;import com.google.gson.annotations.SerializedName;public class BaiduDwz &#123; final static String CREATE_API = "https://dwz.cn/admin/v2/create"; final static String TOKEN = "你的token"; // TODO:设置Token class UrlResponse &#123; @SerializedName("Code") private int code; @SerializedName("ErrMsg") private String errMsg; @SerializedName("LongUrl") private String longUrl; @SerializedName("ShortUrl") private String shortUrl; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getErrMsg() &#123; return errMsg; &#125; public void setErrMsg(String errMsg) &#123; this.errMsg = errMsg; &#125; public String getLongUrl() &#123; return longUrl; &#125; public void setLongUrl(String longUrl) &#123; this.longUrl = longUrl; &#125; public String getShortUrl() &#123; return shortUrl; &#125; public void setShortUrl(String shortUrl) &#123; this.shortUrl = shortUrl; &#125; &#125; /** * 创建短网址 * * @param longUrl * 长网址：即原网址 * @return 成功：短网址 * 失败：返回空字符串 */ public static String createShortUrl(String longUrl) &#123; String params = "&#123;\"url\":\""+ longUrl + "\"&#125;"; BufferedReader reader = null; try &#123; // 创建连接 URL url = new URL(CREATE_API); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); connection.setRequestMethod("POST"); // 设置请求方式 connection.setRequestProperty("Content-Type", "application/json"); // 设置发送数据的格式 connection.setRequestProperty("Token", TOKEN); // 设置发送数据的格式"); // 发起请求 connection.connect(); OutputStreamWriter out = new OutputStreamWriter(connection.getOutputStream(), "UTF-8"); // utf-8编码 out.append(params); out.flush(); out.close(); // 读取响应 reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8")); String line; String res = ""; while ((line = reader.readLine()) != null) &#123; res += line; &#125; reader.close(); // 抽取生成短网址 UrlResponse urlResponse = new Gson().fromJson(res, UrlResponse.class); if (urlResponse.getCode() == 0) &#123; return urlResponse.getShortUrl(); &#125; else &#123; System.out.println(urlResponse.getErrMsg()); &#125; return ""; // TODO：自定义错误信息 &#125; catch (IOException e) &#123; // TODO e.printStackTrace(); &#125; return ""; // TODO：自定义错误信息 &#125; public static void main(String[] args) &#123; String res = createShortUrl("你的长网址"); System.out.println(res); &#125;&#125; 把代码中的token换成你的token在官方文档https://dwz.cn/console/apidoc中获取token到此就ok了，可以在main方法中试一下效果]]></content>
      <categories>
        <category>编程杂记</category>
      </categories>
      <tags>
        <tag>百度短链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号如何授权登录、获取用户信息(openid)]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%A6%82%E4%BD%95%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E3%80%81%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF(openid).html</url>
    <content type="text"><![CDATA[首先看一下实现的效果，在公众号中，用户进入你的应用之前，会弹出一个授权页面，当用户点击确认后，你就可以获取用户的信息 首先访问微信测试号登录页面，通过打开自己手机的微信，扫一扫登录https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login进入到测试号页面后，分别看到如下信息【测试号信息】appID:开发者ID，是公众号开发识别码，配合开发者密码可以调用微信公众号接口，如获取微信昵称等appsecret:开发者密码，是检验公众号开发者身份的密码，具有极高的安全性。切记不要把密码交给第三方开发者或者编写到代码里【接口配置信息】URL: 是开发者用来接收微信消息和事件的接口URL，要用域名不能用ipToken:由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性） 当你填完URL和Token点击提交后，微信会访问你填写的URL，所以要在后台写一个servlet来处理这个请求 处理请求的Controller 1234567891011121314151617181920212223242526272829@Controller@RequestMapping("wechat")public class WeiXinController &#123; @RequestMapping(method = &#123; RequestMethod.GET &#125;) public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; // 微信加密签名 String signature = request.getParameter("signature"); // 时间戳 String timestamp = request.getParameter("timestamp"); // 随机数 String nonce = request.getParameter("nonce"); // 随机字符串 String echostr = request.getParameter("echostr"); // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败 PrintWriter out = null; try &#123; out = response.getWriter(); if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123; log.debug("weixin get success...."); out.print(echostr); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (out != null) out.close(); &#125; &#125;&#125; 微信请求校验工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 微信请求校验工具类 */public class SignUtil &#123; // 与接口配置信息中的Token要一致 private static String token = "mytoken"; /** * 验证签名 * @param signature * @param timestamp * @param nonce * @return */ public static boolean checkSignature(String signature, String timestamp, String nonce) &#123; String[] arr = new String[] &#123; token, timestamp, nonce &#125;; // 将token、timestamp、nonce三个参数进行字典序排序 Arrays.sort(arr); StringBuilder content = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; content.append(arr[i]); &#125; MessageDigest md = null; String tmpStr = null; try &#123; md = MessageDigest.getInstance("SHA-1"); // 将三个参数字符串拼接成一个字符串进行sha1加密 byte[] digest = md.digest(content.toString().getBytes()); tmpStr = byteToStr(digest); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; content = null; // 将sha1加密后的字符串可与signature对比，标识该请求来源于微信 return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false; &#125; /** * 将字节数组转换为十六进制字符串 * @param byteArray * @return */ private static String byteToStr(byte[] byteArray) &#123; String strDigest = ""; for (int i = 0; i &lt; byteArray.length; i++) &#123; strDigest += byteToHexStr(byteArray[i]); &#125; return strDigest; &#125; /** * 将字节转换为十六进制字符串 * @param mByte * @return */ private static String byteToHexStr(byte mByte) &#123; char[] Digit = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' &#125;; char[] tempArr = new char[2]; tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F]; tempArr[1] = Digit[mByte &amp; 0X0F]; String s = new String(tempArr); return s; &#125;&#125; 请求的处理程序写完后把项目重新打包发布到服务器上去，再提交你填写的URL和Token，接口配置信息就Ok啦 【JS接口安全域名】域名：想调用jssdk(如想要通过微信公众号js接口获取地图等工具)必须得填写此域名，在此域名的范围内才能调用jssdk工具，注意这里必须是域名，不是带有http之类的URL【测试号二维码】里面包含了测试号二维码以及已经关注了的用户信息【体验接口权限表】这里主要介绍【网页服务】里面的【网页帐号】网页帐号主要用来设置OAuth2.0里面的网页授权域名，用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。沙盒号回调地址支持域名和ip，正式公众号回调地址只支持域名。接下来需要编写自己的程序以获取关注此公众号的用户信息需要编写5个类 WechatLoginController.java，UserAccessToken.java，WechatUser.java，WechatUtil.java以及MyX509TrustManager.java【WechatLoginController】主要用来获取已关注此微信号的用户信息并做相应处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Controller@RequestMapping("wechatlogin")/** * 获取关注公众号之后的微信用户信息的接口，如果在微信浏览器里访问 * https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appId&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect * 则这里将会获取到code,之后再可以通过code获取到access_token 进而获取到用户信息 */public class WechatLoginController &#123; private static Logger log = LoggerFactory.getLogger(WechatLoginController.class); @RequestMapping(value = "/logincheck", method = &#123; RequestMethod.GET &#125;) public String doGet(HttpServletRequest request, HttpServletResponse response) &#123; log.debug("weixin login get..."); // 获取微信公众号传输过来的code,通过code可获取access_token,进而获取用户信息 String code = request.getParameter("code"); // 这个state可以用来传我们自定义的信息，方便程序调用，这里也可以不用 // String roleType = request.getParameter("state"); log.debug("weixin login code:" + code); WechatUser user = null; String openId = null; if (null != code) &#123; UserAccessToken token; try &#123; // 通过code获取access_token token = WechatUtil.getUserAccessToken(code); log.debug("weixin login token:" + token.toString()); // 通过token获取accessToken String accessToken = token.getAccessToken(); // 通过token获取openId openId = token.getOpenId(); // 通过access_token和openId获取用户昵称等信息 user = WechatUtil.getUserInfo(accessToken, openId); log.debug("weixin login user:" + user.toString()); request.getSession().setAttribute("openId", openId); &#125; catch (IOException e) &#123; log.error("error in getUserAccessToken or getUserInfo or findByOpenId: " + e.toString()); e.printStackTrace(); &#125; &#125; // ======todo begin====== // 前面咱们获取到openId后，可以通过它去数据库判断该微信帐号是否在我们网站里有对应的帐号了， // 没有的话这里可以自动创建上，直接实现微信与咱们网站的无缝对接。 // ======todo end====== if (user != null) &#123; // 获取到微信验证的信息后返回到指定的路由（需要自己设定） return "frontend/index"; &#125; else &#123; return null; &#125; &#125;&#125; 【UserAccessToken】用户AccessToken实体类，用来接收accesstoken以及openid等信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 用户授权token * */public class UserAccessToken &#123; // 获取到的凭证 @JsonProperty("access_token") private String accessToken; // 凭证有效时间，单位：秒 @JsonProperty("expires_in") private String expiresIn; // 表示更新令牌，用来获取下一次的访问令牌，这里没太大用处 @JsonProperty("refresh_token") private String refreshToken; // 该用户在此公众号下的身份标识，对于此微信号具有唯一性 @JsonProperty("openid") private String openId; // 表示权限范围，这里可省略 @JsonProperty("scope") private String scope; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public String getExpiresIn() &#123; return expiresIn; &#125; public void setExpiresIn(String expiresIn) &#123; this.expiresIn = expiresIn; &#125; public String getRefreshToken() &#123; return refreshToken; &#125; public void setRefreshToken(String refreshToken) &#123; this.refreshToken = refreshToken; &#125; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public String getScope() &#123; return scope; &#125; public void setScope(String scope) &#123; this.scope = scope; &#125; @Override public String toString() &#123; return "accessToken:" + this.getAccessToken() + ",openId:" + this.getOpenId(); &#125;&#125; 【WechatUser】微信用户实体类，用来接收昵称 openid等用户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * 微信用户实体类 */public class WechatUser implements Serializable &#123; private static final long serialVersionUID = -4684067645282292327L; // openId,标识该公众号下面的该用户的唯一Id @JsonProperty("openid") private String openId; // 用户昵称 @JsonProperty("nickname") private String nickName; // 性别 @JsonProperty("sex") private int sex; // 省份 @JsonProperty("province") private String province; // 城市 @JsonProperty("city") private String city; // 区 @JsonProperty("country") private String country; // 头像图片地址 @JsonProperty("headimgurl") private String headimgurl; // 语言 @JsonProperty("language") private String language; // 用户权限，这里没什么作用 @JsonProperty("privilege") private String[] privilege; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getCountry() &#123; return country; &#125; public void setCountry(String country) &#123; this.country = country; &#125; public String getHeadimgurl() &#123; return headimgurl; &#125; public void setHeadimgurl(String headimgurl) &#123; this.headimgurl = headimgurl; &#125; public String getLanguage() &#123; return language; &#125; public void setLanguage(String language) &#123; this.language = language; &#125; public String[] getPrivilege() &#123; return privilege; &#125; public void setPrivilege(String[] privilege) &#123; this.privilege = privilege; &#125; @Override public String toString() &#123; return "openId:" + this.getOpenId() + ",nikename:" + this.getNickName(); &#125;&#125; 【WechatUtil】主要用来提交https请求给微信获取用户信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 微信工具类 */public class WechatUtil &#123; private static Logger log = LoggerFactory.getLogger(WechatUtil.class); /** * 获取UserAccessToken实体类 * @param code * @return * @throws IOException */ public static UserAccessToken getUserAccessToken(String code) throws IOException &#123; // 测试号信息里的appId String appId = "您的appId"; log.debug("appId:" + appId); // 测试号信息里的appsecret String appsecret = "您的appsecret"; log.debug("secret:" + appsecret); // 根据传入的code,拼接出访问微信定义好的接口的URL String url = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=" + appId + "&amp;secret=" + appsecret + "&amp;code=" + code + "&amp;grant_type=authorization_code"; // 向相应URL发送请求获取token json字符串 String tokenStr = httpsRequest(url, "GET", null); log.debug("userAccessToken:" + tokenStr); UserAccessToken token = new UserAccessToken(); ObjectMapper objectMapper = new ObjectMapper(); try &#123; // 将json字符串转换成相应对象 token = objectMapper.readValue(tokenStr, UserAccessToken.class); &#125; catch (JsonParseException e) &#123; log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (IOException e) &#123; log.error("获取用户accessToken失败: " + e.getMessage()); e.printStackTrace(); &#125; if (token == null) &#123; log.error("获取用户accessToken失败。"); return null; &#125; return token; &#125; /** * 获取WechatUser实体类 * @param accessToken * @param openId * @return */ public static WechatUser getUserInfo(String accessToken, String openId) &#123; // 根据传入的accessToken以及openId拼接出访问微信定义的端口并获取用户信息的URL String url = "https://api.weixin.qq.com/sns/userinfo?access_token=" + accessToken + "&amp;openid=" + openId + "&amp;lang=zh_CN"; // 访问该URL获取用户信息json 字符串 String userStr = httpsRequest(url, "GET", null); log.debug("user info :" + userStr); WechatUser user = new WechatUser(); ObjectMapper objectMapper = new ObjectMapper(); try &#123; // 将json字符串转换成相应对象 user = objectMapper.readValue(userStr, WechatUser.class); &#125; catch (JsonParseException e) &#123; log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); &#125; catch (IOException e) &#123; log.error("获取用户信息失败: " + e.getMessage()); e.printStackTrace(); &#125; if (user == null) &#123; log.error("获取用户信息失败。"); return null; &#125; return user; &#125; /** * 发起https请求并获取结果 * @param requestUrl * 请求地址 * @param requestMethod * 请求方式（GET、POST） * @param outputStr * 提交的数据 * @return json字符串 */ public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) &#123; StringBuffer buffer = new StringBuffer(); try &#123; // 创建SSLContext对象，并使用我们指定的信任管理器初始化 TrustManager[] tm = &#123; new MyX509TrustManager() &#125;; SSLContext sslContext = SSLContext.getInstance("SSL", "SunJSSE"); sslContext.init(null, tm, new java.security.SecureRandom()); // 从上述SSLContext对象中得到SSLSocketFactory对象 SSLSocketFactory ssf = sslContext.getSocketFactory(); URL url = new URL(requestUrl); HttpsURLConnection httpUrlConn = (HttpsURLConnection) url.openConnection(); httpUrlConn.setSSLSocketFactory(ssf); httpUrlConn.setDoOutput(true); httpUrlConn.setDoInput(true); httpUrlConn.setUseCaches(false); // 设置请求方式（GET/POST） httpUrlConn.setRequestMethod(requestMethod); if ("GET".equalsIgnoreCase(requestMethod)) httpUrlConn.connect(); // 当有数据需要提交时 if (null != outputStr) &#123; OutputStream outputStream = httpUrlConn.getOutputStream(); // 注意编码格式，防止中文乱码 outputStream.write(outputStr.getBytes("UTF-8")); outputStream.close(); &#125; // 将返回的输入流转换成字符串 InputStream inputStream = httpUrlConn.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream, "utf-8"); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String str = null; while ((str = bufferedReader.readLine()) != null) &#123; buffer.append(str); &#125; bufferedReader.close(); inputStreamReader.close(); // 释放资源 inputStream.close(); inputStream = null; httpUrlConn.disconnect(); log.debug("https buffer:" + buffer.toString()); &#125; catch (ConnectException ce) &#123; log.error("Weixin server connection timed out."); &#125; catch (Exception e) &#123; log.error("https request error:&#123;&#125;", e); &#125; return buffer.toString(); &#125;&#125; 【MyX509TrustManager】主要继承X509TrustManager做https证书信任管理器 12345678910111213141516/** * 证书信任管理器（用于https请求） * */public class MyX509TrustManager implements X509TrustManager &#123; public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; public X509Certificate[] getAcceptedIssuers() &#123; return null; &#125;&#125; 之后重新打包一个新的war包并发布到服务器tomcat webapps目录下发布成功后，关注你自己的测试号(即扫描测试号的那个二维码)，然后在手机微信里面或者微信开发者工具里访问相应链接：https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appId&amp;redirect_uri=WechatLoginController对应的地址&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>微信公众号开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下使用crontab如何实现mysql数据库每天自动备份定时备份]]></title>
    <url>%2Flinux%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%8F%E5%A4%A9%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%EF%BC%8C%E5%B9%B6%E5%8F%AA%E4%BF%9D%E7%95%99%E8%BF%917%E5%A4%A9%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[1. 编辑shell脚本 (备份&amp;清理)123456789101112131415#!/bin/bash#在此设置要备份的数据库名,以TEST为例DBNAME="TEST" #备份数据临时存放位置,备份完成之后自动删除. BACKDIR="/home/root/backup/" #获取系统时间DATE=`date +%Y%m%d`#备份文件名以时间命名 FILENAME=dump_$&#123;DATE&#125;.sql #进入备份目录cd $&#123;BACKDIR&#125; #备份数据库并追加日志mysqldump -uroot -proot --databases TEST &gt; $&#123;BACKDIR&#125;$&#123;FILENAME&#125; &gt;&gt; db_backup.log#删除近7天文件find $&#123;BACKDIR&#125; -mtime +7 -name "*.sql" -exec rm -rf &#123;&#125; \; 2. 将脚本加入crontab自动执行计划添加计划 1crontab -e 加入一行:12#每天晚上11点半, 执行对应路径下的脚本.30 23 * * * /home/root/backup.sh 保存退出(vim命令) 3. Cron 各项的描述以下是 crontab 文件的格式： {minute} {hour} {day-of-month} {month} {day-of-week} {full-path-to-shell-script}minute: 区间为 0 – 59hour: 区间为0 – 23day-of-month: 区间为0 – 31month: 区间为1 – 12. 1 是1月. 12是12月.Day-of-week: 区间为0 – 7. 周日可以是0或7. 4.Crontab 示例 在 12:01 a.m 运行，即每天凌晨过一分钟。这是一个恰当的进行备份的时间，因为此时系统负载不大。 11 0 * * * /root/bin/backup.sh 每个工作日(Mon – Fri) 11:59 p.m 都进行备份作业。 1259 11 * * 1,2,3,4,5 /root/bin/backup.sh#或者59 11 * * 1-5 /root/bin/backup.sh效果一样 每5分钟运行一次命令 1*/5 * * * * /root/bin/check-status.sh 每个月的第一天 1:10 p.m 运行 110 13 1 * * /root/bin/full-backup.sh 每个工作日 11 p.m 运行。 10 23 * * 1-5 /root/bin/incremental-backup.sh 5. crontab常用的命令 12345678910service crond start //启动服务service crond stop //关闭服务service crond restart //重启服务service crond reload //重新载入配置service crond status //查看服务状态 crontab –e //往 cron 中添加一个作业crontab –e //修改 crontab 文件. 如果文件不存在会自动创建。 crontab –l //显示 crontab 文件。 crontab -r //删除 crontab 文件。crontab -ir //删除 crontab 文件前提醒用户]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对项目中关键的配置信息进行加密]]></title>
    <url>%2F%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B3%E9%94%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86.html</url>
    <content type="text"><![CDATA[我们在搭键一个项目的时候，有一些信息，比如数据库的连接信息通常会放在一个配置文件中，存放的是明码，我们可以对关键信息比如用户名和密码进行加密，就算别人获取了也没有用 加密后的效果 1234db.username = WnplV/ietfQ=db.password = j9ZTgFZm4H7r0AteGA6A7A==db.driver = com.mysql.jdbc.Driverdb.url = jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf8 一、首先创建一个加密的工具类，对信息进行加密我用的是DES对称加密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.edward.o2o.util;import java.security.Key;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;public class DESUtils &#123; private static Key key; private static String KEY_STR = "myKey"; private static String CHARSETNAME = "UTF-8"; private static String ALGORITHM = "DES"; static &#123; try &#123; KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM); SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG"); secureRandom.setSeed(KEY_STR.getBytes()); generator.init(secureRandom); key = generator.generateKey(); generator = null; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static String getEncryptString(String str) &#123; BASE64Encoder base64encoder = new BASE64Encoder(); try &#123; byte[] bytes = str.getBytes(CHARSETNAME); Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] doFinal = cipher.doFinal(bytes); return base64encoder.encode(doFinal); &#125; catch (Exception e) &#123; // TODO: handle exception throw new RuntimeException(e); &#125; &#125; public static String getDecryptString(String str) &#123; BASE64Decoder base64decoder = new BASE64Decoder(); try &#123; byte[] bytes = base64decoder.decodeBuffer(str); Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, key); byte[] doFinal = cipher.doFinal(bytes); return new String(doFinal, CHARSETNAME); &#125; catch (Exception e) &#123; // TODO: handle exception throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; System.out.println(getEncryptString("root")); System.out.println(getEncryptString("123456abCD.")); System.out.println(getEncryptString("wxd7f6c5b8899fba83")); System.out.println(getEncryptString("665ae80dba31fc91ab6191e7da4d676d")); &#125;&#125; 通过main方法，把要加密的信息输出到控制台得到密文,再把对应的明文换成加密后的密文 二、创建一个PropertyPlaceholderConfigurer的后置处理器，在spring中解析配置文件1234567891011121314151617181920212223242526package com.edward.o2o.util;import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;public class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer &#123; private String[] encryptPropNames = &#123; "db.username", "db.password" &#125;; @Override protected String convertProperty(String propertyName, String propertyValue) &#123; if (isEncryptProp(propertyName)) &#123; String decryptValue = DESUtils.getDecryptString(propertyValue); return decryptValue; &#125; else &#123; return propertyValue; &#125; &#125; private boolean isEncryptProp(String propertyName) &#123; for (String encryptpropertyName : encryptPropNames) &#123; if (encryptpropertyName.equals(propertyName)) return true; &#125; return false; &#125;&#125; 三、把配置文件加载到spring的配置文件中12345678910&lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;&lt;!--&lt;context:property-placeholder location="classpath:db.properties"/&gt;--&gt;&lt;bean class="com.edward.o2o.util.EncryptPropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="fileEncoding" value="UTF-8" /&gt;&lt;/bean&gt; class就是第二步中用于解析配置文件的类 总结： 整个过程就是利用加密的工具类对关键信息加密把原文替换成密文，然后在spring的配置文件中加载需要的配置文件（比如数据库的配置文件），加载过程中PropertyPlaceholderConfigurer后置处理器会调用加密工具类中的解密文件返回明文 PropertyPlaceholderConfigurer是个bean工厂后置处理器的实现，也就是 BeanFactoryPostProcessor接口的一个实现。PropertyPlaceholderConfigurer可以将上下文（配置文 件）中的属性值放在另一个单独的标准java Properties文件中去。在XML文件中用${key}替换指定的properties文件中的值。这样的话，只需要对properties文件进 行修改，而不用对xml配置文件进行修改。]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot 2.1.3配置Druid数据源]]></title>
    <url>%2Fspring-boot%202.1.3%E9%85%8D%E7%BD%AEDruid%E6%95%B0%E6%8D%AE%E6%BA%90.html</url>
    <content type="text"><![CDATA[1.在pom文件添加依赖 12345678910111213&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j yml配置文件中filters: stat,wall,log4j所以要加此依赖，否侧会报错--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 2.在配置文件中配置数据库信息1234567891011121314151617181920212223242526spring: datasource:# 数据源基本配置 username: root password: 123456abcd driver-class-name: com.mysql.cj.jdbc.Driver #注意要配置serverTimezone等信息 url: jdbc:mysql://localhost:3306/books?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false type: com.alibaba.druid.pool.DruidDataSource# 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 3.添加Druid的配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.edward.springbootmybaties.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig &#123; @Bean //这样yml配置文件才会起作用，和Druid类绑定起来 @ConfigurationProperties(prefix = "spring.datasource") public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125;]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>Spring-Boot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合逐层配置]]></title>
    <url>%2FSSM%E6%95%B4%E5%90%88%E9%80%90%E5%B1%82%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[使用SSM（Spring、SpringMVC和Mybatis）已经有三个多月了，项目在技术上已经没有什么难点了，基于现有的技术就可以实现想要的功能，当然肯定有很多可以改进的地方。之前没有记录SSM整合的过程，这次刚刚好基于自己的一个小项目重新搭建了一次，而且比项目搭建的要更好一些。以前解决问题的过程和方法并没有及时记录，以后在自己的小项目中遇到我再整理分享一下。这次，先说说三大框架整合过程。个人认为使用框架并不是很难，关键要理解其思想，这对于我们提高编程水平很有帮助。不过，如果用都不会，谈思想就变成纸上谈兵了！！！先技术，再思想。实践出真知。 一、Dao层配置1.spring-dao.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name="driverClass" value="$&#123;db.driver&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;db.url&#125;" /&gt; &lt;property name="user" value="$&#123;db.username&#125;" /&gt; &lt;property name="password" value="$&#123;db.password&#125;" /&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name="maxPoolSize" value="30" /&gt; &lt;property name="minPoolSize" value="10" /&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name="autoCommitOnClose" value="false" /&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="10000" /&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2" /&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.edward.o2o.entity" /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.edward.o2o.dao" /&gt; &lt;/bean&gt;&lt;/beans&gt; 2.db.properties1234db.username = rootdb.password = 123456abcddb.driver = com.mysql.jdbc.Driverdb.url = jdbc:mysql://localhost:3306/o2o?useUnicode=true&amp;characterEncoding=utf8 3.mybatis-config.xml12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;!-- 打印查询语句 --&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt;&lt;/configuration&gt; 二、service层配置spring-service.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="com.edward.o2o.service" /&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; 三、web层配置spring-web.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解模式 --&gt; &lt;!-- 简化配置： (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 --&gt; &lt;mvc:annotation-driven &gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes" value="text/html;charset=UTF-8"/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用"/"做整体映射 --&gt; &lt;mvc:resources mapping="/resources/**" location="/resources/" /&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 3.定义视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/html/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".html"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package="com.edward.o2o.web" /&gt;&lt;/beans&gt; 四、最后配置web.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;filter&gt; &lt;filter-name&gt;SpringEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SpringEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - &gt; spring -&gt; springmvc --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
